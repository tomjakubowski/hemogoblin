
/* (c)  oblong industries */

// this file is generated by libPlasma/c/t/gentest.pl

#include "libPlasma/c/pool.h"
#include "ilk-begotten-helper.c"
#include <stdlib.h>
#include <string.h>

typedef unsigned short rand_state[3];

#ifdef _MSC_VER

long jrand48 (unsigned short xsubi[3])
{
  unt64 x;

  x = (unt64) (unt16) xsubi[0] + ((unt64) (unt16) xsubi[1] << 16)
      + ((unt64) (unt16) xsubi[2] << 32);

  x = (0x5deece66dULL * x) + 0xb;

  xsubi[0] = (unsigned short) (unt16) x;
  xsubi[1] = (unsigned short) (unt16) (x >> 16);
  xsubi[2] = (unsigned short) (unt16) (x >> 32);

  return (long) (int32) (x >> 16);
}
#endif

static unt8 random_unt8 (rand_state s)
{
  return (unt8) jrand48 (s);
}

static int8 random_int8 (rand_state s)
{
  return (int8) jrand48 (s);
}

static unt16 random_unt16 (rand_state s)
{
  return (unt16) jrand48 (s);
}

static int16 random_int16 (rand_state s)
{
  return (int16) jrand48 (s);
}

static unt32 random_unt32 (rand_state s)
{
  return (unt32) jrand48 (s);
}

static int32 random_int32 (rand_state s)
{
  return (int32) jrand48 (s);
}

static unt64 random_unt64 (rand_state s)
{
  unt64 hi = random_unt32 (s);
  unt64 lo = random_unt32 (s);
  hi <<= 32;
  return (hi ^ lo);
}

static int64 random_int64 (rand_state s)
{
  return (int64) random_unt64 (s);
}

static float32 random_float32 (rand_state s)
{
  return (float32) random_int32 (s);
}

static float64 random_float64 (rand_state s)
{
  return (float64) random_int64 (s);
}

void exercise_int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int32 p001;
  int32 p002;
  int32 p003[560];
  int32 *p004;
  p001 = random_int32 (q1);
  p002 = random_int32 (q2);
  s = slaw_int32 (p001);
  TestAgainstPredicates (eSlawType_int32, s);
  if (memcmp (&p002, slaw_int32_emit (s), sizeof (int32)) != 0)
    error_exit ("compare failed for int32\n");
  if (memcmp (&p002, slaw_int32_emit_nocheck (s), sizeof (int32)) != 0)
    error_exit ("compare failed for int32\n");
  slaw_free (s);
  for (i = 0; i < 560; i++)
    {
      p003[i] = random_int32 (q3);
    }
  s1 = slaw_int32_array_raw (560, &p004);
  s2 = slaw_int32_array_empty (random_unt8 (q1));
  s3 = slaw_int32_array_filled (random_unt8 (q1), p001);
  s4 = slaw_int32_array (p003, 560);
  TestAgainstPredicates (eSlawType_int32_array, s1);
  TestAgainstPredicates (eSlawType_int32_array, s2);
  TestAgainstPredicates (eSlawType_int32_array, s3);
  TestAgainstPredicates (eSlawType_int32_array, s4);
  n = sizeof (int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p002, i + slaw_int32_array_emit (s3), sizeof (int32)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p004, p003, sizeof (p003));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int32_array_emit_nth (s3, i) != i + slaw_int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int32_arrays_concat (s3, s4, NULL);
  s = slaw_int32_array_empty (0);
  s6 = slaw_int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int32_array_concat_carray (s3, p003, 560);
  s8 = slaw_int32_array_concat_carray_f (s3, p003, 560);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt32 p005;
  unt32 p006;
  unt32 p007[830];
  unt32 *p008;
  p005 = random_unt32 (q1);
  p006 = random_unt32 (q2);
  s = slaw_unt32 (p005);
  TestAgainstPredicates (eSlawType_unt32, s);
  if (memcmp (&p006, slaw_unt32_emit (s), sizeof (unt32)) != 0)
    error_exit ("compare failed for unt32\n");
  if (memcmp (&p006, slaw_unt32_emit_nocheck (s), sizeof (unt32)) != 0)
    error_exit ("compare failed for unt32\n");
  slaw_free (s);
  for (i = 0; i < 830; i++)
    {
      p007[i] = random_unt32 (q3);
    }
  s1 = slaw_unt32_array_raw (830, &p008);
  s2 = slaw_unt32_array_empty (random_unt8 (q1));
  s3 = slaw_unt32_array_filled (random_unt8 (q1), p005);
  s4 = slaw_unt32_array (p007, 830);
  TestAgainstPredicates (eSlawType_unt32_array, s1);
  TestAgainstPredicates (eSlawType_unt32_array, s2);
  TestAgainstPredicates (eSlawType_unt32_array, s3);
  TestAgainstPredicates (eSlawType_unt32_array, s4);
  n = sizeof (unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p006, i + slaw_unt32_array_emit (s3), sizeof (unt32)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p008, p007, sizeof (p007));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt32_array_emit_nth (s3, i) != i + slaw_unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt32_arrays_concat (s3, s4, NULL);
  s = slaw_unt32_array_empty (0);
  s6 = slaw_unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt32_array_concat_carray (s3, p007, 830);
  s8 = slaw_unt32_array_concat_carray_f (s3, p007, 830);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int64 p009;
  int64 p010;
  int64 p011[1851];
  int64 *p012;
  p009 = random_int64 (q1);
  p010 = random_int64 (q2);
  s = slaw_int64 (p009);
  TestAgainstPredicates (eSlawType_int64, s);
  if (memcmp (&p010, slaw_int64_emit (s), sizeof (int64)) != 0)
    error_exit ("compare failed for int64\n");
  if (memcmp (&p010, slaw_int64_emit_nocheck (s), sizeof (int64)) != 0)
    error_exit ("compare failed for int64\n");
  slaw_free (s);
  for (i = 0; i < 1851; i++)
    {
      p011[i] = random_int64 (q3);
    }
  s1 = slaw_int64_array_raw (1851, &p012);
  s2 = slaw_int64_array_empty (random_unt8 (q1));
  s3 = slaw_int64_array_filled (random_unt8 (q1), p009);
  s4 = slaw_int64_array (p011, 1851);
  TestAgainstPredicates (eSlawType_int64_array, s1);
  TestAgainstPredicates (eSlawType_int64_array, s2);
  TestAgainstPredicates (eSlawType_int64_array, s3);
  TestAgainstPredicates (eSlawType_int64_array, s4);
  n = sizeof (int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p010, i + slaw_int64_array_emit (s3), sizeof (int64)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p012, p011, sizeof (p011));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int64_array_emit_nth (s3, i) != i + slaw_int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int64_arrays_concat (s3, s4, NULL);
  s = slaw_int64_array_empty (0);
  s6 = slaw_int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int64_array_concat_carray (s3, p011, 1851);
  s8 = slaw_int64_array_concat_carray_f (s3, p011, 1851);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt64 p013;
  unt64 p014;
  unt64 p015[260];
  unt64 *p016;
  p013 = random_unt64 (q1);
  p014 = random_unt64 (q2);
  s = slaw_unt64 (p013);
  TestAgainstPredicates (eSlawType_unt64, s);
  if (memcmp (&p014, slaw_unt64_emit (s), sizeof (unt64)) != 0)
    error_exit ("compare failed for unt64\n");
  if (memcmp (&p014, slaw_unt64_emit_nocheck (s), sizeof (unt64)) != 0)
    error_exit ("compare failed for unt64\n");
  slaw_free (s);
  for (i = 0; i < 260; i++)
    {
      p015[i] = random_unt64 (q3);
    }
  s1 = slaw_unt64_array_raw (260, &p016);
  s2 = slaw_unt64_array_empty (random_unt8 (q1));
  s3 = slaw_unt64_array_filled (random_unt8 (q1), p013);
  s4 = slaw_unt64_array (p015, 260);
  TestAgainstPredicates (eSlawType_unt64_array, s1);
  TestAgainstPredicates (eSlawType_unt64_array, s2);
  TestAgainstPredicates (eSlawType_unt64_array, s3);
  TestAgainstPredicates (eSlawType_unt64_array, s4);
  n = sizeof (unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p014, i + slaw_unt64_array_emit (s3), sizeof (unt64)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p016, p015, sizeof (p015));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt64_array_emit_nth (s3, i) != i + slaw_unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt64_arrays_concat (s3, s4, NULL);
  s = slaw_unt64_array_empty (0);
  s6 = slaw_unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt64_array_concat_carray (s3, p015, 260);
  s8 = slaw_unt64_array_concat_carray_f (s3, p015, 260);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  float32 p017;
  float32 p018;
  float32 p019[249];
  float32 *p020;
  p017 = random_float32 (q1);
  p018 = random_float32 (q2);
  s = slaw_float32 (p017);
  TestAgainstPredicates (eSlawType_float32, s);
  if (memcmp (&p018, slaw_float32_emit (s), sizeof (float32)) != 0)
    error_exit ("compare failed for float32\n");
  if (memcmp (&p018, slaw_float32_emit_nocheck (s), sizeof (float32)) != 0)
    error_exit ("compare failed for float32\n");
  slaw_free (s);
  for (i = 0; i < 249; i++)
    {
      p019[i] = random_float32 (q3);
    }
  s1 = slaw_float32_array_raw (249, &p020);
  s2 = slaw_float32_array_empty (random_unt8 (q1));
  s3 = slaw_float32_array_filled (random_unt8 (q1), p017);
  s4 = slaw_float32_array (p019, 249);
  TestAgainstPredicates (eSlawType_float32_array, s1);
  TestAgainstPredicates (eSlawType_float32_array, s2);
  TestAgainstPredicates (eSlawType_float32_array, s3);
  TestAgainstPredicates (eSlawType_float32_array, s4);
  n = sizeof (float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p018, i + slaw_float32_array_emit (s3), sizeof (float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p020, p019, sizeof (p019));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_float32_array_emit_nth (s3, i)
          != i + slaw_float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_float32_arrays_concat (s3, s4, NULL);
  s = slaw_float32_array_empty (0);
  s6 = slaw_float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_float32_array_concat_carray (s3, p019, 249);
  s8 = slaw_float32_array_concat_carray_f (s3, p019, 249);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  float64 p021;
  float64 p022;
  float64 p023[700];
  float64 *p024;
  p021 = random_float64 (q1);
  p022 = random_float64 (q2);
  s = slaw_float64 (p021);
  TestAgainstPredicates (eSlawType_float64, s);
  if (memcmp (&p022, slaw_float64_emit (s), sizeof (float64)) != 0)
    error_exit ("compare failed for float64\n");
  if (memcmp (&p022, slaw_float64_emit_nocheck (s), sizeof (float64)) != 0)
    error_exit ("compare failed for float64\n");
  slaw_free (s);
  for (i = 0; i < 700; i++)
    {
      p023[i] = random_float64 (q3);
    }
  s1 = slaw_float64_array_raw (700, &p024);
  s2 = slaw_float64_array_empty (random_unt8 (q1));
  s3 = slaw_float64_array_filled (random_unt8 (q1), p021);
  s4 = slaw_float64_array (p023, 700);
  TestAgainstPredicates (eSlawType_float64_array, s1);
  TestAgainstPredicates (eSlawType_float64_array, s2);
  TestAgainstPredicates (eSlawType_float64_array, s3);
  TestAgainstPredicates (eSlawType_float64_array, s4);
  n = sizeof (float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p022, i + slaw_float64_array_emit (s3), sizeof (float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p024, p023, sizeof (p023));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_float64_array_emit_nth (s3, i)
          != i + slaw_float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_float64_arrays_concat (s3, s4, NULL);
  s = slaw_float64_array_empty (0);
  s6 = slaw_float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_float64_array_concat_carray (s3, p023, 700);
  s8 = slaw_float64_array_concat_carray_f (s3, p023, 700);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int8 p025;
  int8 p026;
  int8 p027[1252];
  int8 *p028;
  p025 = random_int8 (q1);
  p026 = random_int8 (q2);
  s = slaw_int8 (p025);
  TestAgainstPredicates (eSlawType_int8, s);
  if (memcmp (&p026, slaw_int8_emit (s), sizeof (int8)) != 0)
    error_exit ("compare failed for int8\n");
  if (memcmp (&p026, slaw_int8_emit_nocheck (s), sizeof (int8)) != 0)
    error_exit ("compare failed for int8\n");
  slaw_free (s);
  for (i = 0; i < 1252; i++)
    {
      p027[i] = random_int8 (q3);
    }
  s1 = slaw_int8_array_raw (1252, &p028);
  s2 = slaw_int8_array_empty (random_unt8 (q1));
  s3 = slaw_int8_array_filled (random_unt8 (q1), p025);
  s4 = slaw_int8_array (p027, 1252);
  TestAgainstPredicates (eSlawType_int8_array, s1);
  TestAgainstPredicates (eSlawType_int8_array, s2);
  TestAgainstPredicates (eSlawType_int8_array, s3);
  TestAgainstPredicates (eSlawType_int8_array, s4);
  n = sizeof (int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p026, i + slaw_int8_array_emit (s3), sizeof (int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p028, p027, sizeof (p027));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int8_array_emit_nth (s3, i) != i + slaw_int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int8_arrays_concat (s3, s4, NULL);
  s = slaw_int8_array_empty (0);
  s6 = slaw_int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int8_array_concat_carray (s3, p027, 1252);
  s8 = slaw_int8_array_concat_carray_f (s3, p027, 1252);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt8 p029;
  unt8 p030;
  unt8 p031[1668];
  unt8 *p032;
  p029 = random_unt8 (q1);
  p030 = random_unt8 (q2);
  s = slaw_unt8 (p029);
  TestAgainstPredicates (eSlawType_unt8, s);
  if (memcmp (&p030, slaw_unt8_emit (s), sizeof (unt8)) != 0)
    error_exit ("compare failed for unt8\n");
  if (memcmp (&p030, slaw_unt8_emit_nocheck (s), sizeof (unt8)) != 0)
    error_exit ("compare failed for unt8\n");
  slaw_free (s);
  for (i = 0; i < 1668; i++)
    {
      p031[i] = random_unt8 (q3);
    }
  s1 = slaw_unt8_array_raw (1668, &p032);
  s2 = slaw_unt8_array_empty (random_unt8 (q1));
  s3 = slaw_unt8_array_filled (random_unt8 (q1), p029);
  s4 = slaw_unt8_array (p031, 1668);
  TestAgainstPredicates (eSlawType_unt8_array, s1);
  TestAgainstPredicates (eSlawType_unt8_array, s2);
  TestAgainstPredicates (eSlawType_unt8_array, s3);
  TestAgainstPredicates (eSlawType_unt8_array, s4);
  n = sizeof (unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p030, i + slaw_unt8_array_emit (s3), sizeof (unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p032, p031, sizeof (p031));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt8_array_emit_nth (s3, i) != i + slaw_unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt8_arrays_concat (s3, s4, NULL);
  s = slaw_unt8_array_empty (0);
  s6 = slaw_unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt8_array_concat_carray (s3, p031, 1668);
  s8 = slaw_unt8_array_concat_carray_f (s3, p031, 1668);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int16 p033;
  int16 p034;
  int16 p035[1390];
  int16 *p036;
  p033 = random_int16 (q1);
  p034 = random_int16 (q2);
  s = slaw_int16 (p033);
  TestAgainstPredicates (eSlawType_int16, s);
  if (memcmp (&p034, slaw_int16_emit (s), sizeof (int16)) != 0)
    error_exit ("compare failed for int16\n");
  if (memcmp (&p034, slaw_int16_emit_nocheck (s), sizeof (int16)) != 0)
    error_exit ("compare failed for int16\n");
  slaw_free (s);
  for (i = 0; i < 1390; i++)
    {
      p035[i] = random_int16 (q3);
    }
  s1 = slaw_int16_array_raw (1390, &p036);
  s2 = slaw_int16_array_empty (random_unt8 (q1));
  s3 = slaw_int16_array_filled (random_unt8 (q1), p033);
  s4 = slaw_int16_array (p035, 1390);
  TestAgainstPredicates (eSlawType_int16_array, s1);
  TestAgainstPredicates (eSlawType_int16_array, s2);
  TestAgainstPredicates (eSlawType_int16_array, s3);
  TestAgainstPredicates (eSlawType_int16_array, s4);
  n = sizeof (int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p034, i + slaw_int16_array_emit (s3), sizeof (int16)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p036, p035, sizeof (p035));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int16_array_emit_nth (s3, i) != i + slaw_int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int16_arrays_concat (s3, s4, NULL);
  s = slaw_int16_array_empty (0);
  s6 = slaw_int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int16_array_concat_carray (s3, p035, 1390);
  s8 = slaw_int16_array_concat_carray_f (s3, p035, 1390);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt16 p037;
  unt16 p038;
  unt16 p039[301];
  unt16 *p040;
  p037 = random_unt16 (q1);
  p038 = random_unt16 (q2);
  s = slaw_unt16 (p037);
  TestAgainstPredicates (eSlawType_unt16, s);
  if (memcmp (&p038, slaw_unt16_emit (s), sizeof (unt16)) != 0)
    error_exit ("compare failed for unt16\n");
  if (memcmp (&p038, slaw_unt16_emit_nocheck (s), sizeof (unt16)) != 0)
    error_exit ("compare failed for unt16\n");
  slaw_free (s);
  for (i = 0; i < 301; i++)
    {
      p039[i] = random_unt16 (q3);
    }
  s1 = slaw_unt16_array_raw (301, &p040);
  s2 = slaw_unt16_array_empty (random_unt8 (q1));
  s3 = slaw_unt16_array_filled (random_unt8 (q1), p037);
  s4 = slaw_unt16_array (p039, 301);
  TestAgainstPredicates (eSlawType_unt16_array, s1);
  TestAgainstPredicates (eSlawType_unt16_array, s2);
  TestAgainstPredicates (eSlawType_unt16_array, s3);
  TestAgainstPredicates (eSlawType_unt16_array, s4);
  n = sizeof (unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p038, i + slaw_unt16_array_emit (s3), sizeof (unt16)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p040, p039, sizeof (p039));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt16_array_emit_nth (s3, i) != i + slaw_unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt16_arrays_concat (s3, s4, NULL);
  s = slaw_unt16_array_empty (0);
  s6 = slaw_unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt16_array_concat_carray (s3, p039, 301);
  s8 = slaw_unt16_array_concat_carray_f (s3, p039, 301);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int32c p041;
  int32c p042;
  int32c p043[1563];
  int32c *p044;
  p041.re = random_int32 (q1);
  p041.im = random_int32 (q1);
  p042.re = random_int32 (q2);
  p042.im = random_int32 (q2);
  s = slaw_int32c (p041);
  TestAgainstPredicates (eSlawType_int32c, s);
  if (memcmp (&p042, slaw_int32c_emit (s), sizeof (int32c)) != 0)
    error_exit ("compare failed for int32c\n");
  if (memcmp (&p042, slaw_int32c_emit_nocheck (s), sizeof (int32c)) != 0)
    error_exit ("compare failed for int32c\n");
  slaw_free (s);
  for (i = 0; i < 1563; i++)
    {
      p043[i].re = random_int32 (q3);
      p043[i].im = random_int32 (q3);
    }
  s1 = slaw_int32c_array_raw (1563, &p044);
  s2 = slaw_int32c_array_empty (random_unt8 (q1));
  s3 = slaw_int32c_array_filled (random_unt8 (q1), p041);
  s4 = slaw_int32c_array (p043, 1563);
  TestAgainstPredicates (eSlawType_int32c_array, s1);
  TestAgainstPredicates (eSlawType_int32c_array, s2);
  TestAgainstPredicates (eSlawType_int32c_array, s3);
  TestAgainstPredicates (eSlawType_int32c_array, s4);
  n = sizeof (int32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p042, i + slaw_int32c_array_emit (s3), sizeof (int32c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p044, p043, sizeof (p043));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int32c_array_emit_nth (s3, i) != i + slaw_int32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int32c_arrays_concat (s3, s4, NULL);
  s = slaw_int32c_array_empty (0);
  s6 = slaw_int32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int32c_array_concat_carray (s3, p043, 1563);
  s8 = slaw_int32c_array_concat_carray_f (s3, p043, 1563);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt32c p045;
  unt32c p046;
  unt32c p047[734];
  unt32c *p048;
  p045.re = random_unt32 (q1);
  p045.im = random_unt32 (q1);
  p046.re = random_unt32 (q2);
  p046.im = random_unt32 (q2);
  s = slaw_unt32c (p045);
  TestAgainstPredicates (eSlawType_unt32c, s);
  if (memcmp (&p046, slaw_unt32c_emit (s), sizeof (unt32c)) != 0)
    error_exit ("compare failed for unt32c\n");
  if (memcmp (&p046, slaw_unt32c_emit_nocheck (s), sizeof (unt32c)) != 0)
    error_exit ("compare failed for unt32c\n");
  slaw_free (s);
  for (i = 0; i < 734; i++)
    {
      p047[i].re = random_unt32 (q3);
      p047[i].im = random_unt32 (q3);
    }
  s1 = slaw_unt32c_array_raw (734, &p048);
  s2 = slaw_unt32c_array_empty (random_unt8 (q1));
  s3 = slaw_unt32c_array_filled (random_unt8 (q1), p045);
  s4 = slaw_unt32c_array (p047, 734);
  TestAgainstPredicates (eSlawType_unt32c_array, s1);
  TestAgainstPredicates (eSlawType_unt32c_array, s2);
  TestAgainstPredicates (eSlawType_unt32c_array, s3);
  TestAgainstPredicates (eSlawType_unt32c_array, s4);
  n = sizeof (unt32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p046, i + slaw_unt32c_array_emit (s3), sizeof (unt32c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p048, p047, sizeof (p047));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt32c_array_emit_nth (s3, i) != i + slaw_unt32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt32c_arrays_concat (s3, s4, NULL);
  s = slaw_unt32c_array_empty (0);
  s6 = slaw_unt32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt32c_array_concat_carray (s3, p047, 734);
  s8 = slaw_unt32c_array_concat_carray_f (s3, p047, 734);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int64c p049;
  int64c p050;
  int64c p051[1874];
  int64c *p052;
  p049.re = random_int64 (q1);
  p049.im = random_int64 (q1);
  p050.re = random_int64 (q2);
  p050.im = random_int64 (q2);
  s = slaw_int64c (p049);
  TestAgainstPredicates (eSlawType_int64c, s);
  if (memcmp (&p050, slaw_int64c_emit (s), sizeof (int64c)) != 0)
    error_exit ("compare failed for int64c\n");
  if (memcmp (&p050, slaw_int64c_emit_nocheck (s), sizeof (int64c)) != 0)
    error_exit ("compare failed for int64c\n");
  slaw_free (s);
  for (i = 0; i < 1874; i++)
    {
      p051[i].re = random_int64 (q3);
      p051[i].im = random_int64 (q3);
    }
  s1 = slaw_int64c_array_raw (1874, &p052);
  s2 = slaw_int64c_array_empty (random_unt8 (q1));
  s3 = slaw_int64c_array_filled (random_unt8 (q1), p049);
  s4 = slaw_int64c_array (p051, 1874);
  TestAgainstPredicates (eSlawType_int64c_array, s1);
  TestAgainstPredicates (eSlawType_int64c_array, s2);
  TestAgainstPredicates (eSlawType_int64c_array, s3);
  TestAgainstPredicates (eSlawType_int64c_array, s4);
  n = sizeof (int64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p050, i + slaw_int64c_array_emit (s3), sizeof (int64c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p052, p051, sizeof (p051));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int64c_array_emit_nth (s3, i) != i + slaw_int64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int64c_arrays_concat (s3, s4, NULL);
  s = slaw_int64c_array_empty (0);
  s6 = slaw_int64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int64c_array_concat_carray (s3, p051, 1874);
  s8 = slaw_int64c_array_concat_carray_f (s3, p051, 1874);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt64c p053;
  unt64c p054;
  unt64c p055[291];
  unt64c *p056;
  p053.re = random_unt64 (q1);
  p053.im = random_unt64 (q1);
  p054.re = random_unt64 (q2);
  p054.im = random_unt64 (q2);
  s = slaw_unt64c (p053);
  TestAgainstPredicates (eSlawType_unt64c, s);
  if (memcmp (&p054, slaw_unt64c_emit (s), sizeof (unt64c)) != 0)
    error_exit ("compare failed for unt64c\n");
  if (memcmp (&p054, slaw_unt64c_emit_nocheck (s), sizeof (unt64c)) != 0)
    error_exit ("compare failed for unt64c\n");
  slaw_free (s);
  for (i = 0; i < 291; i++)
    {
      p055[i].re = random_unt64 (q3);
      p055[i].im = random_unt64 (q3);
    }
  s1 = slaw_unt64c_array_raw (291, &p056);
  s2 = slaw_unt64c_array_empty (random_unt8 (q1));
  s3 = slaw_unt64c_array_filled (random_unt8 (q1), p053);
  s4 = slaw_unt64c_array (p055, 291);
  TestAgainstPredicates (eSlawType_unt64c_array, s1);
  TestAgainstPredicates (eSlawType_unt64c_array, s2);
  TestAgainstPredicates (eSlawType_unt64c_array, s3);
  TestAgainstPredicates (eSlawType_unt64c_array, s4);
  n = sizeof (unt64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p054, i + slaw_unt64c_array_emit (s3), sizeof (unt64c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p056, p055, sizeof (p055));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt64c_array_emit_nth (s3, i) != i + slaw_unt64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt64c_arrays_concat (s3, s4, NULL);
  s = slaw_unt64c_array_empty (0);
  s6 = slaw_unt64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt64c_array_concat_carray (s3, p055, 291);
  s8 = slaw_unt64c_array_concat_carray_f (s3, p055, 291);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_float32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  float32c p057;
  float32c p058;
  float32c p059[1703];
  float32c *p060;
  p057.re = random_float32 (q1);
  p057.im = random_float32 (q1);
  p058.re = random_float32 (q2);
  p058.im = random_float32 (q2);
  s = slaw_float32c (p057);
  TestAgainstPredicates (eSlawType_float32c, s);
  if (memcmp (&p058, slaw_float32c_emit (s), sizeof (float32c)) != 0)
    error_exit ("compare failed for float32c\n");
  if (memcmp (&p058, slaw_float32c_emit_nocheck (s), sizeof (float32c)) != 0)
    error_exit ("compare failed for float32c\n");
  slaw_free (s);
  for (i = 0; i < 1703; i++)
    {
      p059[i].re = random_float32 (q3);
      p059[i].im = random_float32 (q3);
    }
  s1 = slaw_float32c_array_raw (1703, &p060);
  s2 = slaw_float32c_array_empty (random_unt8 (q1));
  s3 = slaw_float32c_array_filled (random_unt8 (q1), p057);
  s4 = slaw_float32c_array (p059, 1703);
  TestAgainstPredicates (eSlawType_float32c_array, s1);
  TestAgainstPredicates (eSlawType_float32c_array, s2);
  TestAgainstPredicates (eSlawType_float32c_array, s3);
  TestAgainstPredicates (eSlawType_float32c_array, s4);
  n = sizeof (float32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_float32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p058, i + slaw_float32c_array_emit (s3), sizeof (float32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p060, p059, sizeof (p059));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_float32c_array_emit_nth (s3, i)
          != i + slaw_float32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_float32c_arrays_concat (s3, s4, NULL);
  s = slaw_float32c_array_empty (0);
  s6 = slaw_float32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_float32c_array_concat_carray (s3, p059, 1703);
  s8 = slaw_float32c_array_concat_carray_f (s3, p059, 1703);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_float64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  float64c p061;
  float64c p062;
  float64c p063[240];
  float64c *p064;
  p061.re = random_float64 (q1);
  p061.im = random_float64 (q1);
  p062.re = random_float64 (q2);
  p062.im = random_float64 (q2);
  s = slaw_float64c (p061);
  TestAgainstPredicates (eSlawType_float64c, s);
  if (memcmp (&p062, slaw_float64c_emit (s), sizeof (float64c)) != 0)
    error_exit ("compare failed for float64c\n");
  if (memcmp (&p062, slaw_float64c_emit_nocheck (s), sizeof (float64c)) != 0)
    error_exit ("compare failed for float64c\n");
  slaw_free (s);
  for (i = 0; i < 240; i++)
    {
      p063[i].re = random_float64 (q3);
      p063[i].im = random_float64 (q3);
    }
  s1 = slaw_float64c_array_raw (240, &p064);
  s2 = slaw_float64c_array_empty (random_unt8 (q1));
  s3 = slaw_float64c_array_filled (random_unt8 (q1), p061);
  s4 = slaw_float64c_array (p063, 240);
  TestAgainstPredicates (eSlawType_float64c_array, s1);
  TestAgainstPredicates (eSlawType_float64c_array, s2);
  TestAgainstPredicates (eSlawType_float64c_array, s3);
  TestAgainstPredicates (eSlawType_float64c_array, s4);
  n = sizeof (float64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_float64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p062, i + slaw_float64c_array_emit (s3), sizeof (float64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p064, p063, sizeof (p063));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_float64c_array_emit_nth (s3, i)
          != i + slaw_float64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_float64c_arrays_concat (s3, s4, NULL);
  s = slaw_float64c_array_empty (0);
  s6 = slaw_float64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_float64c_array_concat_carray (s3, p063, 240);
  s8 = slaw_float64c_array_concat_carray_f (s3, p063, 240);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int8c p065;
  int8c p066;
  int8c p067[1636];
  int8c *p068;
  p065.re = random_int8 (q1);
  p065.im = random_int8 (q1);
  p066.re = random_int8 (q2);
  p066.im = random_int8 (q2);
  s = slaw_int8c (p065);
  TestAgainstPredicates (eSlawType_int8c, s);
  if (memcmp (&p066, slaw_int8c_emit (s), sizeof (int8c)) != 0)
    error_exit ("compare failed for int8c\n");
  if (memcmp (&p066, slaw_int8c_emit_nocheck (s), sizeof (int8c)) != 0)
    error_exit ("compare failed for int8c\n");
  slaw_free (s);
  for (i = 0; i < 1636; i++)
    {
      p067[i].re = random_int8 (q3);
      p067[i].im = random_int8 (q3);
    }
  s1 = slaw_int8c_array_raw (1636, &p068);
  s2 = slaw_int8c_array_empty (random_unt8 (q1));
  s3 = slaw_int8c_array_filled (random_unt8 (q1), p065);
  s4 = slaw_int8c_array (p067, 1636);
  TestAgainstPredicates (eSlawType_int8c_array, s1);
  TestAgainstPredicates (eSlawType_int8c_array, s2);
  TestAgainstPredicates (eSlawType_int8c_array, s3);
  TestAgainstPredicates (eSlawType_int8c_array, s4);
  n = sizeof (int8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p066, i + slaw_int8c_array_emit (s3), sizeof (int8c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p068, p067, sizeof (p067));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int8c_array_emit_nth (s3, i) != i + slaw_int8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int8c_arrays_concat (s3, s4, NULL);
  s = slaw_int8c_array_empty (0);
  s6 = slaw_int8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int8c_array_concat_carray (s3, p067, 1636);
  s8 = slaw_int8c_array_concat_carray_f (s3, p067, 1636);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt8c p069;
  unt8c p070;
  unt8c p071[789];
  unt8c *p072;
  p069.re = random_unt8 (q1);
  p069.im = random_unt8 (q1);
  p070.re = random_unt8 (q2);
  p070.im = random_unt8 (q2);
  s = slaw_unt8c (p069);
  TestAgainstPredicates (eSlawType_unt8c, s);
  if (memcmp (&p070, slaw_unt8c_emit (s), sizeof (unt8c)) != 0)
    error_exit ("compare failed for unt8c\n");
  if (memcmp (&p070, slaw_unt8c_emit_nocheck (s), sizeof (unt8c)) != 0)
    error_exit ("compare failed for unt8c\n");
  slaw_free (s);
  for (i = 0; i < 789; i++)
    {
      p071[i].re = random_unt8 (q3);
      p071[i].im = random_unt8 (q3);
    }
  s1 = slaw_unt8c_array_raw (789, &p072);
  s2 = slaw_unt8c_array_empty (random_unt8 (q1));
  s3 = slaw_unt8c_array_filled (random_unt8 (q1), p069);
  s4 = slaw_unt8c_array (p071, 789);
  TestAgainstPredicates (eSlawType_unt8c_array, s1);
  TestAgainstPredicates (eSlawType_unt8c_array, s2);
  TestAgainstPredicates (eSlawType_unt8c_array, s3);
  TestAgainstPredicates (eSlawType_unt8c_array, s4);
  n = sizeof (unt8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p070, i + slaw_unt8c_array_emit (s3), sizeof (unt8c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p072, p071, sizeof (p071));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt8c_array_emit_nth (s3, i) != i + slaw_unt8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt8c_arrays_concat (s3, s4, NULL);
  s = slaw_unt8c_array_empty (0);
  s6 = slaw_unt8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt8c_array_concat_carray (s3, p071, 789);
  s8 = slaw_unt8c_array_concat_carray_f (s3, p071, 789);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_int16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  int16c p073;
  int16c p074;
  int16c p075[1809];
  int16c *p076;
  p073.re = random_int16 (q1);
  p073.im = random_int16 (q1);
  p074.re = random_int16 (q2);
  p074.im = random_int16 (q2);
  s = slaw_int16c (p073);
  TestAgainstPredicates (eSlawType_int16c, s);
  if (memcmp (&p074, slaw_int16c_emit (s), sizeof (int16c)) != 0)
    error_exit ("compare failed for int16c\n");
  if (memcmp (&p074, slaw_int16c_emit_nocheck (s), sizeof (int16c)) != 0)
    error_exit ("compare failed for int16c\n");
  slaw_free (s);
  for (i = 0; i < 1809; i++)
    {
      p075[i].re = random_int16 (q3);
      p075[i].im = random_int16 (q3);
    }
  s1 = slaw_int16c_array_raw (1809, &p076);
  s2 = slaw_int16c_array_empty (random_unt8 (q1));
  s3 = slaw_int16c_array_filled (random_unt8 (q1), p073);
  s4 = slaw_int16c_array (p075, 1809);
  TestAgainstPredicates (eSlawType_int16c_array, s1);
  TestAgainstPredicates (eSlawType_int16c_array, s2);
  TestAgainstPredicates (eSlawType_int16c_array, s3);
  TestAgainstPredicates (eSlawType_int16c_array, s4);
  n = sizeof (int16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_int16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p074, i + slaw_int16c_array_emit (s3), sizeof (int16c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p076, p075, sizeof (p075));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_int16c_array_emit_nth (s3, i) != i + slaw_int16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_int16c_arrays_concat (s3, s4, NULL);
  s = slaw_int16c_array_empty (0);
  s6 = slaw_int16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_int16c_array_concat_carray (s3, p075, 1809);
  s8 = slaw_int16c_array_concat_carray_f (s3, p075, 1809);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_unt16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  unt16c p077;
  unt16c p078;
  unt16c p079[304];
  unt16c *p080;
  p077.re = random_unt16 (q1);
  p077.im = random_unt16 (q1);
  p078.re = random_unt16 (q2);
  p078.im = random_unt16 (q2);
  s = slaw_unt16c (p077);
  TestAgainstPredicates (eSlawType_unt16c, s);
  if (memcmp (&p078, slaw_unt16c_emit (s), sizeof (unt16c)) != 0)
    error_exit ("compare failed for unt16c\n");
  if (memcmp (&p078, slaw_unt16c_emit_nocheck (s), sizeof (unt16c)) != 0)
    error_exit ("compare failed for unt16c\n");
  slaw_free (s);
  for (i = 0; i < 304; i++)
    {
      p079[i].re = random_unt16 (q3);
      p079[i].im = random_unt16 (q3);
    }
  s1 = slaw_unt16c_array_raw (304, &p080);
  s2 = slaw_unt16c_array_empty (random_unt8 (q1));
  s3 = slaw_unt16c_array_filled (random_unt8 (q1), p077);
  s4 = slaw_unt16c_array (p079, 304);
  TestAgainstPredicates (eSlawType_unt16c_array, s1);
  TestAgainstPredicates (eSlawType_unt16c_array, s2);
  TestAgainstPredicates (eSlawType_unt16c_array, s3);
  TestAgainstPredicates (eSlawType_unt16c_array, s4);
  n = sizeof (unt16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_unt16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p078, i + slaw_unt16c_array_emit (s3), sizeof (unt16c)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p080, p079, sizeof (p079));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_unt16c_array_emit_nth (s3, i) != i + slaw_unt16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_unt16c_arrays_concat (s3, s4, NULL);
  s = slaw_unt16c_array_empty (0);
  s6 = slaw_unt16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_unt16c_array_concat_carray (s3, p079, 304);
  s8 = slaw_unt16c_array_concat_carray_f (s3, p079, 304);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int32 p081;
  v2int32 p082;
  v2int32 p083[1806];
  v2int32 *p084;
  p081.x = random_int32 (q1);
  p081.y = random_int32 (q1);
  p082.x = random_int32 (q2);
  p082.y = random_int32 (q2);
  s = slaw_v2int32 (p081);
  TestAgainstPredicates (eSlawType_v2int32, s);
  if (memcmp (&p082, slaw_v2int32_emit (s), sizeof (v2int32)) != 0)
    error_exit ("compare failed for v2int32\n");
  if (memcmp (&p082, slaw_v2int32_emit_nocheck (s), sizeof (v2int32)) != 0)
    error_exit ("compare failed for v2int32\n");
  slaw_free (s);
  for (i = 0; i < 1806; i++)
    {
      p083[i].x = random_int32 (q3);
      p083[i].y = random_int32 (q3);
    }
  s1 = slaw_v2int32_array_raw (1806, &p084);
  s2 = slaw_v2int32_array_empty (random_unt8 (q1));
  s3 = slaw_v2int32_array_filled (random_unt8 (q1), p081);
  s4 = slaw_v2int32_array (p083, 1806);
  TestAgainstPredicates (eSlawType_v2int32_array, s1);
  TestAgainstPredicates (eSlawType_v2int32_array, s2);
  TestAgainstPredicates (eSlawType_v2int32_array, s3);
  TestAgainstPredicates (eSlawType_v2int32_array, s4);
  n = sizeof (v2int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p082, i + slaw_v2int32_array_emit (s3), sizeof (v2int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p084, p083, sizeof (p083));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int32_array_emit_nth (s3, i)
          != i + slaw_v2int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int32_arrays_concat (s3, s4, NULL);
  s = slaw_v2int32_array_empty (0);
  s6 = slaw_v2int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int32_array_concat_carray (s3, p083, 1806);
  s8 = slaw_v2int32_array_concat_carray_f (s3, p083, 1806);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt32 p085;
  v2unt32 p086;
  v2unt32 p087[1053];
  v2unt32 *p088;
  p085.x = random_unt32 (q1);
  p085.y = random_unt32 (q1);
  p086.x = random_unt32 (q2);
  p086.y = random_unt32 (q2);
  s = slaw_v2unt32 (p085);
  TestAgainstPredicates (eSlawType_v2unt32, s);
  if (memcmp (&p086, slaw_v2unt32_emit (s), sizeof (v2unt32)) != 0)
    error_exit ("compare failed for v2unt32\n");
  if (memcmp (&p086, slaw_v2unt32_emit_nocheck (s), sizeof (v2unt32)) != 0)
    error_exit ("compare failed for v2unt32\n");
  slaw_free (s);
  for (i = 0; i < 1053; i++)
    {
      p087[i].x = random_unt32 (q3);
      p087[i].y = random_unt32 (q3);
    }
  s1 = slaw_v2unt32_array_raw (1053, &p088);
  s2 = slaw_v2unt32_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt32_array_filled (random_unt8 (q1), p085);
  s4 = slaw_v2unt32_array (p087, 1053);
  TestAgainstPredicates (eSlawType_v2unt32_array, s1);
  TestAgainstPredicates (eSlawType_v2unt32_array, s2);
  TestAgainstPredicates (eSlawType_v2unt32_array, s3);
  TestAgainstPredicates (eSlawType_v2unt32_array, s4);
  n = sizeof (v2unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p086, i + slaw_v2unt32_array_emit (s3), sizeof (v2unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p088, p087, sizeof (p087));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt32_array_emit_nth (s3, i)
          != i + slaw_v2unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt32_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt32_array_empty (0);
  s6 = slaw_v2unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt32_array_concat_carray (s3, p087, 1053);
  s8 = slaw_v2unt32_array_concat_carray_f (s3, p087, 1053);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int64 p089;
  v2int64 p090;
  v2int64 p091[583];
  v2int64 *p092;
  p089.x = random_int64 (q1);
  p089.y = random_int64 (q1);
  p090.x = random_int64 (q2);
  p090.y = random_int64 (q2);
  s = slaw_v2int64 (p089);
  TestAgainstPredicates (eSlawType_v2int64, s);
  if (memcmp (&p090, slaw_v2int64_emit (s), sizeof (v2int64)) != 0)
    error_exit ("compare failed for v2int64\n");
  if (memcmp (&p090, slaw_v2int64_emit_nocheck (s), sizeof (v2int64)) != 0)
    error_exit ("compare failed for v2int64\n");
  slaw_free (s);
  for (i = 0; i < 583; i++)
    {
      p091[i].x = random_int64 (q3);
      p091[i].y = random_int64 (q3);
    }
  s1 = slaw_v2int64_array_raw (583, &p092);
  s2 = slaw_v2int64_array_empty (random_unt8 (q1));
  s3 = slaw_v2int64_array_filled (random_unt8 (q1), p089);
  s4 = slaw_v2int64_array (p091, 583);
  TestAgainstPredicates (eSlawType_v2int64_array, s1);
  TestAgainstPredicates (eSlawType_v2int64_array, s2);
  TestAgainstPredicates (eSlawType_v2int64_array, s3);
  TestAgainstPredicates (eSlawType_v2int64_array, s4);
  n = sizeof (v2int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p090, i + slaw_v2int64_array_emit (s3), sizeof (v2int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p092, p091, sizeof (p091));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int64_array_emit_nth (s3, i)
          != i + slaw_v2int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int64_arrays_concat (s3, s4, NULL);
  s = slaw_v2int64_array_empty (0);
  s6 = slaw_v2int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int64_array_concat_carray (s3, p091, 583);
  s8 = slaw_v2int64_array_concat_carray_f (s3, p091, 583);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt64 p093;
  v2unt64 p094;
  v2unt64 p095[1704];
  v2unt64 *p096;
  p093.x = random_unt64 (q1);
  p093.y = random_unt64 (q1);
  p094.x = random_unt64 (q2);
  p094.y = random_unt64 (q2);
  s = slaw_v2unt64 (p093);
  TestAgainstPredicates (eSlawType_v2unt64, s);
  if (memcmp (&p094, slaw_v2unt64_emit (s), sizeof (v2unt64)) != 0)
    error_exit ("compare failed for v2unt64\n");
  if (memcmp (&p094, slaw_v2unt64_emit_nocheck (s), sizeof (v2unt64)) != 0)
    error_exit ("compare failed for v2unt64\n");
  slaw_free (s);
  for (i = 0; i < 1704; i++)
    {
      p095[i].x = random_unt64 (q3);
      p095[i].y = random_unt64 (q3);
    }
  s1 = slaw_v2unt64_array_raw (1704, &p096);
  s2 = slaw_v2unt64_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt64_array_filled (random_unt8 (q1), p093);
  s4 = slaw_v2unt64_array (p095, 1704);
  TestAgainstPredicates (eSlawType_v2unt64_array, s1);
  TestAgainstPredicates (eSlawType_v2unt64_array, s2);
  TestAgainstPredicates (eSlawType_v2unt64_array, s3);
  TestAgainstPredicates (eSlawType_v2unt64_array, s4);
  n = sizeof (v2unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p094, i + slaw_v2unt64_array_emit (s3), sizeof (v2unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p096, p095, sizeof (p095));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt64_array_emit_nth (s3, i)
          != i + slaw_v2unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt64_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt64_array_empty (0);
  s6 = slaw_v2unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt64_array_concat_carray (s3, p095, 1704);
  s8 = slaw_v2unt64_array_concat_carray_f (s3, p095, 1704);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2float32 p097;
  v2float32 p098;
  v2float32 p099[701];
  v2float32 *p100;
  p097.x = random_float32 (q1);
  p097.y = random_float32 (q1);
  p098.x = random_float32 (q2);
  p098.y = random_float32 (q2);
  s = slaw_v2float32 (p097);
  TestAgainstPredicates (eSlawType_v2float32, s);
  if (memcmp (&p098, slaw_v2float32_emit (s), sizeof (v2float32)) != 0)
    error_exit ("compare failed for v2float32\n");
  if (memcmp (&p098, slaw_v2float32_emit_nocheck (s), sizeof (v2float32)) != 0)
    error_exit ("compare failed for v2float32\n");
  slaw_free (s);
  for (i = 0; i < 701; i++)
    {
      p099[i].x = random_float32 (q3);
      p099[i].y = random_float32 (q3);
    }
  s1 = slaw_v2float32_array_raw (701, &p100);
  s2 = slaw_v2float32_array_empty (random_unt8 (q1));
  s3 = slaw_v2float32_array_filled (random_unt8 (q1), p097);
  s4 = slaw_v2float32_array (p099, 701);
  TestAgainstPredicates (eSlawType_v2float32_array, s1);
  TestAgainstPredicates (eSlawType_v2float32_array, s2);
  TestAgainstPredicates (eSlawType_v2float32_array, s3);
  TestAgainstPredicates (eSlawType_v2float32_array, s4);
  n = sizeof (v2float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p098, i + slaw_v2float32_array_emit (s3), sizeof (v2float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p100, p099, sizeof (p099));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2float32_array_emit_nth (s3, i)
          != i + slaw_v2float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2float32_arrays_concat (s3, s4, NULL);
  s = slaw_v2float32_array_empty (0);
  s6 = slaw_v2float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2float32_array_concat_carray (s3, p099, 701);
  s8 = slaw_v2float32_array_concat_carray_f (s3, p099, 701);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2float64 p101;
  v2float64 p102;
  v2float64 p103[1709];
  v2float64 *p104;
  p101.x = random_float64 (q1);
  p101.y = random_float64 (q1);
  p102.x = random_float64 (q2);
  p102.y = random_float64 (q2);
  s = slaw_v2float64 (p101);
  TestAgainstPredicates (eSlawType_v2float64, s);
  if (memcmp (&p102, slaw_v2float64_emit (s), sizeof (v2float64)) != 0)
    error_exit ("compare failed for v2float64\n");
  if (memcmp (&p102, slaw_v2float64_emit_nocheck (s), sizeof (v2float64)) != 0)
    error_exit ("compare failed for v2float64\n");
  slaw_free (s);
  for (i = 0; i < 1709; i++)
    {
      p103[i].x = random_float64 (q3);
      p103[i].y = random_float64 (q3);
    }
  s1 = slaw_v2float64_array_raw (1709, &p104);
  s2 = slaw_v2float64_array_empty (random_unt8 (q1));
  s3 = slaw_v2float64_array_filled (random_unt8 (q1), p101);
  s4 = slaw_v2float64_array (p103, 1709);
  TestAgainstPredicates (eSlawType_v2float64_array, s1);
  TestAgainstPredicates (eSlawType_v2float64_array, s2);
  TestAgainstPredicates (eSlawType_v2float64_array, s3);
  TestAgainstPredicates (eSlawType_v2float64_array, s4);
  n = sizeof (v2float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p102, i + slaw_v2float64_array_emit (s3), sizeof (v2float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p104, p103, sizeof (p103));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2float64_array_emit_nth (s3, i)
          != i + slaw_v2float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2float64_arrays_concat (s3, s4, NULL);
  s = slaw_v2float64_array_empty (0);
  s6 = slaw_v2float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2float64_array_concat_carray (s3, p103, 1709);
  s8 = slaw_v2float64_array_concat_carray_f (s3, p103, 1709);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int8 p105;
  v2int8 p106;
  v2int8 p107[1483];
  v2int8 *p108;
  p105.x = random_int8 (q1);
  p105.y = random_int8 (q1);
  p106.x = random_int8 (q2);
  p106.y = random_int8 (q2);
  s = slaw_v2int8 (p105);
  TestAgainstPredicates (eSlawType_v2int8, s);
  if (memcmp (&p106, slaw_v2int8_emit (s), sizeof (v2int8)) != 0)
    error_exit ("compare failed for v2int8\n");
  if (memcmp (&p106, slaw_v2int8_emit_nocheck (s), sizeof (v2int8)) != 0)
    error_exit ("compare failed for v2int8\n");
  slaw_free (s);
  for (i = 0; i < 1483; i++)
    {
      p107[i].x = random_int8 (q3);
      p107[i].y = random_int8 (q3);
    }
  s1 = slaw_v2int8_array_raw (1483, &p108);
  s2 = slaw_v2int8_array_empty (random_unt8 (q1));
  s3 = slaw_v2int8_array_filled (random_unt8 (q1), p105);
  s4 = slaw_v2int8_array (p107, 1483);
  TestAgainstPredicates (eSlawType_v2int8_array, s1);
  TestAgainstPredicates (eSlawType_v2int8_array, s2);
  TestAgainstPredicates (eSlawType_v2int8_array, s3);
  TestAgainstPredicates (eSlawType_v2int8_array, s4);
  n = sizeof (v2int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p106, i + slaw_v2int8_array_emit (s3), sizeof (v2int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p108, p107, sizeof (p107));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int8_array_emit_nth (s3, i) != i + slaw_v2int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int8_arrays_concat (s3, s4, NULL);
  s = slaw_v2int8_array_empty (0);
  s6 = slaw_v2int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int8_array_concat_carray (s3, p107, 1483);
  s8 = slaw_v2int8_array_concat_carray_f (s3, p107, 1483);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt8 p109;
  v2unt8 p110;
  v2unt8 p111[275];
  v2unt8 *p112;
  p109.x = random_unt8 (q1);
  p109.y = random_unt8 (q1);
  p110.x = random_unt8 (q2);
  p110.y = random_unt8 (q2);
  s = slaw_v2unt8 (p109);
  TestAgainstPredicates (eSlawType_v2unt8, s);
  if (memcmp (&p110, slaw_v2unt8_emit (s), sizeof (v2unt8)) != 0)
    error_exit ("compare failed for v2unt8\n");
  if (memcmp (&p110, slaw_v2unt8_emit_nocheck (s), sizeof (v2unt8)) != 0)
    error_exit ("compare failed for v2unt8\n");
  slaw_free (s);
  for (i = 0; i < 275; i++)
    {
      p111[i].x = random_unt8 (q3);
      p111[i].y = random_unt8 (q3);
    }
  s1 = slaw_v2unt8_array_raw (275, &p112);
  s2 = slaw_v2unt8_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt8_array_filled (random_unt8 (q1), p109);
  s4 = slaw_v2unt8_array (p111, 275);
  TestAgainstPredicates (eSlawType_v2unt8_array, s1);
  TestAgainstPredicates (eSlawType_v2unt8_array, s2);
  TestAgainstPredicates (eSlawType_v2unt8_array, s3);
  TestAgainstPredicates (eSlawType_v2unt8_array, s4);
  n = sizeof (v2unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p110, i + slaw_v2unt8_array_emit (s3), sizeof (v2unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p112, p111, sizeof (p111));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt8_array_emit_nth (s3, i) != i + slaw_v2unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt8_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt8_array_empty (0);
  s6 = slaw_v2unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt8_array_concat_carray (s3, p111, 275);
  s8 = slaw_v2unt8_array_concat_carray_f (s3, p111, 275);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int16 p113;
  v2int16 p114;
  v2int16 p115[1429];
  v2int16 *p116;
  p113.x = random_int16 (q1);
  p113.y = random_int16 (q1);
  p114.x = random_int16 (q2);
  p114.y = random_int16 (q2);
  s = slaw_v2int16 (p113);
  TestAgainstPredicates (eSlawType_v2int16, s);
  if (memcmp (&p114, slaw_v2int16_emit (s), sizeof (v2int16)) != 0)
    error_exit ("compare failed for v2int16\n");
  if (memcmp (&p114, slaw_v2int16_emit_nocheck (s), sizeof (v2int16)) != 0)
    error_exit ("compare failed for v2int16\n");
  slaw_free (s);
  for (i = 0; i < 1429; i++)
    {
      p115[i].x = random_int16 (q3);
      p115[i].y = random_int16 (q3);
    }
  s1 = slaw_v2int16_array_raw (1429, &p116);
  s2 = slaw_v2int16_array_empty (random_unt8 (q1));
  s3 = slaw_v2int16_array_filled (random_unt8 (q1), p113);
  s4 = slaw_v2int16_array (p115, 1429);
  TestAgainstPredicates (eSlawType_v2int16_array, s1);
  TestAgainstPredicates (eSlawType_v2int16_array, s2);
  TestAgainstPredicates (eSlawType_v2int16_array, s3);
  TestAgainstPredicates (eSlawType_v2int16_array, s4);
  n = sizeof (v2int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p114, i + slaw_v2int16_array_emit (s3), sizeof (v2int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p116, p115, sizeof (p115));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int16_array_emit_nth (s3, i)
          != i + slaw_v2int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int16_arrays_concat (s3, s4, NULL);
  s = slaw_v2int16_array_empty (0);
  s6 = slaw_v2int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int16_array_concat_carray (s3, p115, 1429);
  s8 = slaw_v2int16_array_concat_carray_f (s3, p115, 1429);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt16 p117;
  v2unt16 p118;
  v2unt16 p119[1706];
  v2unt16 *p120;
  p117.x = random_unt16 (q1);
  p117.y = random_unt16 (q1);
  p118.x = random_unt16 (q2);
  p118.y = random_unt16 (q2);
  s = slaw_v2unt16 (p117);
  TestAgainstPredicates (eSlawType_v2unt16, s);
  if (memcmp (&p118, slaw_v2unt16_emit (s), sizeof (v2unt16)) != 0)
    error_exit ("compare failed for v2unt16\n");
  if (memcmp (&p118, slaw_v2unt16_emit_nocheck (s), sizeof (v2unt16)) != 0)
    error_exit ("compare failed for v2unt16\n");
  slaw_free (s);
  for (i = 0; i < 1706; i++)
    {
      p119[i].x = random_unt16 (q3);
      p119[i].y = random_unt16 (q3);
    }
  s1 = slaw_v2unt16_array_raw (1706, &p120);
  s2 = slaw_v2unt16_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt16_array_filled (random_unt8 (q1), p117);
  s4 = slaw_v2unt16_array (p119, 1706);
  TestAgainstPredicates (eSlawType_v2unt16_array, s1);
  TestAgainstPredicates (eSlawType_v2unt16_array, s2);
  TestAgainstPredicates (eSlawType_v2unt16_array, s3);
  TestAgainstPredicates (eSlawType_v2unt16_array, s4);
  n = sizeof (v2unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p118, i + slaw_v2unt16_array_emit (s3), sizeof (v2unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p120, p119, sizeof (p119));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt16_array_emit_nth (s3, i)
          != i + slaw_v2unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt16_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt16_array_empty (0);
  s6 = slaw_v2unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt16_array_concat_carray (s3, p119, 1706);
  s8 = slaw_v2unt16_array_concat_carray_f (s3, p119, 1706);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int32 p121;
  v3int32 p122;
  v3int32 p123[1490];
  v3int32 *p124;
  p121.x = random_int32 (q1);
  p121.y = random_int32 (q1);
  p121.z = random_int32 (q1);
  p122.x = random_int32 (q2);
  p122.y = random_int32 (q2);
  p122.z = random_int32 (q2);
  s = slaw_v3int32 (p121);
  TestAgainstPredicates (eSlawType_v3int32, s);
  if (memcmp (&p122, slaw_v3int32_emit (s), sizeof (v3int32)) != 0)
    error_exit ("compare failed for v3int32\n");
  if (memcmp (&p122, slaw_v3int32_emit_nocheck (s), sizeof (v3int32)) != 0)
    error_exit ("compare failed for v3int32\n");
  slaw_free (s);
  for (i = 0; i < 1490; i++)
    {
      p123[i].x = random_int32 (q3);
      p123[i].y = random_int32 (q3);
      p123[i].z = random_int32 (q3);
    }
  s1 = slaw_v3int32_array_raw (1490, &p124);
  s2 = slaw_v3int32_array_empty (random_unt8 (q1));
  s3 = slaw_v3int32_array_filled (random_unt8 (q1), p121);
  s4 = slaw_v3int32_array (p123, 1490);
  TestAgainstPredicates (eSlawType_v3int32_array, s1);
  TestAgainstPredicates (eSlawType_v3int32_array, s2);
  TestAgainstPredicates (eSlawType_v3int32_array, s3);
  TestAgainstPredicates (eSlawType_v3int32_array, s4);
  n = sizeof (v3int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p122, i + slaw_v3int32_array_emit (s3), sizeof (v3int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p124, p123, sizeof (p123));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int32_array_emit_nth (s3, i)
          != i + slaw_v3int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int32_arrays_concat (s3, s4, NULL);
  s = slaw_v3int32_array_empty (0);
  s6 = slaw_v3int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int32_array_concat_carray (s3, p123, 1490);
  s8 = slaw_v3int32_array_concat_carray_f (s3, p123, 1490);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt32 p125;
  v3unt32 p126;
  v3unt32 p127[1872];
  v3unt32 *p128;
  p125.x = random_unt32 (q1);
  p125.y = random_unt32 (q1);
  p125.z = random_unt32 (q1);
  p126.x = random_unt32 (q2);
  p126.y = random_unt32 (q2);
  p126.z = random_unt32 (q2);
  s = slaw_v3unt32 (p125);
  TestAgainstPredicates (eSlawType_v3unt32, s);
  if (memcmp (&p126, slaw_v3unt32_emit (s), sizeof (v3unt32)) != 0)
    error_exit ("compare failed for v3unt32\n");
  if (memcmp (&p126, slaw_v3unt32_emit_nocheck (s), sizeof (v3unt32)) != 0)
    error_exit ("compare failed for v3unt32\n");
  slaw_free (s);
  for (i = 0; i < 1872; i++)
    {
      p127[i].x = random_unt32 (q3);
      p127[i].y = random_unt32 (q3);
      p127[i].z = random_unt32 (q3);
    }
  s1 = slaw_v3unt32_array_raw (1872, &p128);
  s2 = slaw_v3unt32_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt32_array_filled (random_unt8 (q1), p125);
  s4 = slaw_v3unt32_array (p127, 1872);
  TestAgainstPredicates (eSlawType_v3unt32_array, s1);
  TestAgainstPredicates (eSlawType_v3unt32_array, s2);
  TestAgainstPredicates (eSlawType_v3unt32_array, s3);
  TestAgainstPredicates (eSlawType_v3unt32_array, s4);
  n = sizeof (v3unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p126, i + slaw_v3unt32_array_emit (s3), sizeof (v3unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p128, p127, sizeof (p127));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt32_array_emit_nth (s3, i)
          != i + slaw_v3unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt32_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt32_array_empty (0);
  s6 = slaw_v3unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt32_array_concat_carray (s3, p127, 1872);
  s8 = slaw_v3unt32_array_concat_carray_f (s3, p127, 1872);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int64 p129;
  v3int64 p130;
  v3int64 p131[137];
  v3int64 *p132;
  p129.x = random_int64 (q1);
  p129.y = random_int64 (q1);
  p129.z = random_int64 (q1);
  p130.x = random_int64 (q2);
  p130.y = random_int64 (q2);
  p130.z = random_int64 (q2);
  s = slaw_v3int64 (p129);
  TestAgainstPredicates (eSlawType_v3int64, s);
  if (memcmp (&p130, slaw_v3int64_emit (s), sizeof (v3int64)) != 0)
    error_exit ("compare failed for v3int64\n");
  if (memcmp (&p130, slaw_v3int64_emit_nocheck (s), sizeof (v3int64)) != 0)
    error_exit ("compare failed for v3int64\n");
  slaw_free (s);
  for (i = 0; i < 137; i++)
    {
      p131[i].x = random_int64 (q3);
      p131[i].y = random_int64 (q3);
      p131[i].z = random_int64 (q3);
    }
  s1 = slaw_v3int64_array_raw (137, &p132);
  s2 = slaw_v3int64_array_empty (random_unt8 (q1));
  s3 = slaw_v3int64_array_filled (random_unt8 (q1), p129);
  s4 = slaw_v3int64_array (p131, 137);
  TestAgainstPredicates (eSlawType_v3int64_array, s1);
  TestAgainstPredicates (eSlawType_v3int64_array, s2);
  TestAgainstPredicates (eSlawType_v3int64_array, s3);
  TestAgainstPredicates (eSlawType_v3int64_array, s4);
  n = sizeof (v3int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p130, i + slaw_v3int64_array_emit (s3), sizeof (v3int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p132, p131, sizeof (p131));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int64_array_emit_nth (s3, i)
          != i + slaw_v3int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int64_arrays_concat (s3, s4, NULL);
  s = slaw_v3int64_array_empty (0);
  s6 = slaw_v3int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int64_array_concat_carray (s3, p131, 137);
  s8 = slaw_v3int64_array_concat_carray_f (s3, p131, 137);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt64 p133;
  v3unt64 p134;
  v3unt64 p135[1827];
  v3unt64 *p136;
  p133.x = random_unt64 (q1);
  p133.y = random_unt64 (q1);
  p133.z = random_unt64 (q1);
  p134.x = random_unt64 (q2);
  p134.y = random_unt64 (q2);
  p134.z = random_unt64 (q2);
  s = slaw_v3unt64 (p133);
  TestAgainstPredicates (eSlawType_v3unt64, s);
  if (memcmp (&p134, slaw_v3unt64_emit (s), sizeof (v3unt64)) != 0)
    error_exit ("compare failed for v3unt64\n");
  if (memcmp (&p134, slaw_v3unt64_emit_nocheck (s), sizeof (v3unt64)) != 0)
    error_exit ("compare failed for v3unt64\n");
  slaw_free (s);
  for (i = 0; i < 1827; i++)
    {
      p135[i].x = random_unt64 (q3);
      p135[i].y = random_unt64 (q3);
      p135[i].z = random_unt64 (q3);
    }
  s1 = slaw_v3unt64_array_raw (1827, &p136);
  s2 = slaw_v3unt64_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt64_array_filled (random_unt8 (q1), p133);
  s4 = slaw_v3unt64_array (p135, 1827);
  TestAgainstPredicates (eSlawType_v3unt64_array, s1);
  TestAgainstPredicates (eSlawType_v3unt64_array, s2);
  TestAgainstPredicates (eSlawType_v3unt64_array, s3);
  TestAgainstPredicates (eSlawType_v3unt64_array, s4);
  n = sizeof (v3unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p134, i + slaw_v3unt64_array_emit (s3), sizeof (v3unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p136, p135, sizeof (p135));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt64_array_emit_nth (s3, i)
          != i + slaw_v3unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt64_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt64_array_empty (0);
  s6 = slaw_v3unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt64_array_concat_carray (s3, p135, 1827);
  s8 = slaw_v3unt64_array_concat_carray_f (s3, p135, 1827);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3float32 p137;
  v3float32 p138;
  v3float32 p139[1238];
  v3float32 *p140;
  p137.x = random_float32 (q1);
  p137.y = random_float32 (q1);
  p137.z = random_float32 (q1);
  p138.x = random_float32 (q2);
  p138.y = random_float32 (q2);
  p138.z = random_float32 (q2);
  s = slaw_v3float32 (p137);
  TestAgainstPredicates (eSlawType_v3float32, s);
  if (memcmp (&p138, slaw_v3float32_emit (s), sizeof (v3float32)) != 0)
    error_exit ("compare failed for v3float32\n");
  if (memcmp (&p138, slaw_v3float32_emit_nocheck (s), sizeof (v3float32)) != 0)
    error_exit ("compare failed for v3float32\n");
  slaw_free (s);
  for (i = 0; i < 1238; i++)
    {
      p139[i].x = random_float32 (q3);
      p139[i].y = random_float32 (q3);
      p139[i].z = random_float32 (q3);
    }
  s1 = slaw_v3float32_array_raw (1238, &p140);
  s2 = slaw_v3float32_array_empty (random_unt8 (q1));
  s3 = slaw_v3float32_array_filled (random_unt8 (q1), p137);
  s4 = slaw_v3float32_array (p139, 1238);
  TestAgainstPredicates (eSlawType_v3float32_array, s1);
  TestAgainstPredicates (eSlawType_v3float32_array, s2);
  TestAgainstPredicates (eSlawType_v3float32_array, s3);
  TestAgainstPredicates (eSlawType_v3float32_array, s4);
  n = sizeof (v3float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p138, i + slaw_v3float32_array_emit (s3), sizeof (v3float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p140, p139, sizeof (p139));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3float32_array_emit_nth (s3, i)
          != i + slaw_v3float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3float32_arrays_concat (s3, s4, NULL);
  s = slaw_v3float32_array_empty (0);
  s6 = slaw_v3float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3float32_array_concat_carray (s3, p139, 1238);
  s8 = slaw_v3float32_array_concat_carray_f (s3, p139, 1238);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3float64 p141;
  v3float64 p142;
  v3float64 p143[1972];
  v3float64 *p144;
  p141.x = random_float64 (q1);
  p141.y = random_float64 (q1);
  p141.z = random_float64 (q1);
  p142.x = random_float64 (q2);
  p142.y = random_float64 (q2);
  p142.z = random_float64 (q2);
  s = slaw_v3float64 (p141);
  TestAgainstPredicates (eSlawType_v3float64, s);
  if (memcmp (&p142, slaw_v3float64_emit (s), sizeof (v3float64)) != 0)
    error_exit ("compare failed for v3float64\n");
  if (memcmp (&p142, slaw_v3float64_emit_nocheck (s), sizeof (v3float64)) != 0)
    error_exit ("compare failed for v3float64\n");
  slaw_free (s);
  for (i = 0; i < 1972; i++)
    {
      p143[i].x = random_float64 (q3);
      p143[i].y = random_float64 (q3);
      p143[i].z = random_float64 (q3);
    }
  s1 = slaw_v3float64_array_raw (1972, &p144);
  s2 = slaw_v3float64_array_empty (random_unt8 (q1));
  s3 = slaw_v3float64_array_filled (random_unt8 (q1), p141);
  s4 = slaw_v3float64_array (p143, 1972);
  TestAgainstPredicates (eSlawType_v3float64_array, s1);
  TestAgainstPredicates (eSlawType_v3float64_array, s2);
  TestAgainstPredicates (eSlawType_v3float64_array, s3);
  TestAgainstPredicates (eSlawType_v3float64_array, s4);
  n = sizeof (v3float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p142, i + slaw_v3float64_array_emit (s3), sizeof (v3float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p144, p143, sizeof (p143));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3float64_array_emit_nth (s3, i)
          != i + slaw_v3float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3float64_arrays_concat (s3, s4, NULL);
  s = slaw_v3float64_array_empty (0);
  s6 = slaw_v3float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3float64_array_concat_carray (s3, p143, 1972);
  s8 = slaw_v3float64_array_concat_carray_f (s3, p143, 1972);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int8 p145;
  v3int8 p146;
  v3int8 p147[482];
  v3int8 *p148;
  p145.x = random_int8 (q1);
  p145.y = random_int8 (q1);
  p145.z = random_int8 (q1);
  p146.x = random_int8 (q2);
  p146.y = random_int8 (q2);
  p146.z = random_int8 (q2);
  s = slaw_v3int8 (p145);
  TestAgainstPredicates (eSlawType_v3int8, s);
  if (memcmp (&p146, slaw_v3int8_emit (s), sizeof (v3int8)) != 0)
    error_exit ("compare failed for v3int8\n");
  if (memcmp (&p146, slaw_v3int8_emit_nocheck (s), sizeof (v3int8)) != 0)
    error_exit ("compare failed for v3int8\n");
  slaw_free (s);
  for (i = 0; i < 482; i++)
    {
      p147[i].x = random_int8 (q3);
      p147[i].y = random_int8 (q3);
      p147[i].z = random_int8 (q3);
    }
  s1 = slaw_v3int8_array_raw (482, &p148);
  s2 = slaw_v3int8_array_empty (random_unt8 (q1));
  s3 = slaw_v3int8_array_filled (random_unt8 (q1), p145);
  s4 = slaw_v3int8_array (p147, 482);
  TestAgainstPredicates (eSlawType_v3int8_array, s1);
  TestAgainstPredicates (eSlawType_v3int8_array, s2);
  TestAgainstPredicates (eSlawType_v3int8_array, s3);
  TestAgainstPredicates (eSlawType_v3int8_array, s4);
  n = sizeof (v3int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p146, i + slaw_v3int8_array_emit (s3), sizeof (v3int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p148, p147, sizeof (p147));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int8_array_emit_nth (s3, i) != i + slaw_v3int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int8_arrays_concat (s3, s4, NULL);
  s = slaw_v3int8_array_empty (0);
  s6 = slaw_v3int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int8_array_concat_carray (s3, p147, 482);
  s8 = slaw_v3int8_array_concat_carray_f (s3, p147, 482);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt8 p149;
  v3unt8 p150;
  v3unt8 p151[1100];
  v3unt8 *p152;
  p149.x = random_unt8 (q1);
  p149.y = random_unt8 (q1);
  p149.z = random_unt8 (q1);
  p150.x = random_unt8 (q2);
  p150.y = random_unt8 (q2);
  p150.z = random_unt8 (q2);
  s = slaw_v3unt8 (p149);
  TestAgainstPredicates (eSlawType_v3unt8, s);
  if (memcmp (&p150, slaw_v3unt8_emit (s), sizeof (v3unt8)) != 0)
    error_exit ("compare failed for v3unt8\n");
  if (memcmp (&p150, slaw_v3unt8_emit_nocheck (s), sizeof (v3unt8)) != 0)
    error_exit ("compare failed for v3unt8\n");
  slaw_free (s);
  for (i = 0; i < 1100; i++)
    {
      p151[i].x = random_unt8 (q3);
      p151[i].y = random_unt8 (q3);
      p151[i].z = random_unt8 (q3);
    }
  s1 = slaw_v3unt8_array_raw (1100, &p152);
  s2 = slaw_v3unt8_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt8_array_filled (random_unt8 (q1), p149);
  s4 = slaw_v3unt8_array (p151, 1100);
  TestAgainstPredicates (eSlawType_v3unt8_array, s1);
  TestAgainstPredicates (eSlawType_v3unt8_array, s2);
  TestAgainstPredicates (eSlawType_v3unt8_array, s3);
  TestAgainstPredicates (eSlawType_v3unt8_array, s4);
  n = sizeof (v3unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p150, i + slaw_v3unt8_array_emit (s3), sizeof (v3unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p152, p151, sizeof (p151));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt8_array_emit_nth (s3, i) != i + slaw_v3unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt8_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt8_array_empty (0);
  s6 = slaw_v3unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt8_array_concat_carray (s3, p151, 1100);
  s8 = slaw_v3unt8_array_concat_carray_f (s3, p151, 1100);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int16 p153;
  v3int16 p154;
  v3int16 p155[1794];
  v3int16 *p156;
  p153.x = random_int16 (q1);
  p153.y = random_int16 (q1);
  p153.z = random_int16 (q1);
  p154.x = random_int16 (q2);
  p154.y = random_int16 (q2);
  p154.z = random_int16 (q2);
  s = slaw_v3int16 (p153);
  TestAgainstPredicates (eSlawType_v3int16, s);
  if (memcmp (&p154, slaw_v3int16_emit (s), sizeof (v3int16)) != 0)
    error_exit ("compare failed for v3int16\n");
  if (memcmp (&p154, slaw_v3int16_emit_nocheck (s), sizeof (v3int16)) != 0)
    error_exit ("compare failed for v3int16\n");
  slaw_free (s);
  for (i = 0; i < 1794; i++)
    {
      p155[i].x = random_int16 (q3);
      p155[i].y = random_int16 (q3);
      p155[i].z = random_int16 (q3);
    }
  s1 = slaw_v3int16_array_raw (1794, &p156);
  s2 = slaw_v3int16_array_empty (random_unt8 (q1));
  s3 = slaw_v3int16_array_filled (random_unt8 (q1), p153);
  s4 = slaw_v3int16_array (p155, 1794);
  TestAgainstPredicates (eSlawType_v3int16_array, s1);
  TestAgainstPredicates (eSlawType_v3int16_array, s2);
  TestAgainstPredicates (eSlawType_v3int16_array, s3);
  TestAgainstPredicates (eSlawType_v3int16_array, s4);
  n = sizeof (v3int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p154, i + slaw_v3int16_array_emit (s3), sizeof (v3int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p156, p155, sizeof (p155));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int16_array_emit_nth (s3, i)
          != i + slaw_v3int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int16_arrays_concat (s3, s4, NULL);
  s = slaw_v3int16_array_empty (0);
  s6 = slaw_v3int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int16_array_concat_carray (s3, p155, 1794);
  s8 = slaw_v3int16_array_concat_carray_f (s3, p155, 1794);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt16 p157;
  v3unt16 p158;
  v3unt16 p159[1331];
  v3unt16 *p160;
  p157.x = random_unt16 (q1);
  p157.y = random_unt16 (q1);
  p157.z = random_unt16 (q1);
  p158.x = random_unt16 (q2);
  p158.y = random_unt16 (q2);
  p158.z = random_unt16 (q2);
  s = slaw_v3unt16 (p157);
  TestAgainstPredicates (eSlawType_v3unt16, s);
  if (memcmp (&p158, slaw_v3unt16_emit (s), sizeof (v3unt16)) != 0)
    error_exit ("compare failed for v3unt16\n");
  if (memcmp (&p158, slaw_v3unt16_emit_nocheck (s), sizeof (v3unt16)) != 0)
    error_exit ("compare failed for v3unt16\n");
  slaw_free (s);
  for (i = 0; i < 1331; i++)
    {
      p159[i].x = random_unt16 (q3);
      p159[i].y = random_unt16 (q3);
      p159[i].z = random_unt16 (q3);
    }
  s1 = slaw_v3unt16_array_raw (1331, &p160);
  s2 = slaw_v3unt16_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt16_array_filled (random_unt8 (q1), p157);
  s4 = slaw_v3unt16_array (p159, 1331);
  TestAgainstPredicates (eSlawType_v3unt16_array, s1);
  TestAgainstPredicates (eSlawType_v3unt16_array, s2);
  TestAgainstPredicates (eSlawType_v3unt16_array, s3);
  TestAgainstPredicates (eSlawType_v3unt16_array, s4);
  n = sizeof (v3unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p158, i + slaw_v3unt16_array_emit (s3), sizeof (v3unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p160, p159, sizeof (p159));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt16_array_emit_nth (s3, i)
          != i + slaw_v3unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt16_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt16_array_empty (0);
  s6 = slaw_v3unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt16_array_concat_carray (s3, p159, 1331);
  s8 = slaw_v3unt16_array_concat_carray_f (s3, p159, 1331);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int32 p161;
  v4int32 p162;
  v4int32 p163[1782];
  v4int32 *p164;
  p161.x = random_int32 (q1);
  p161.y = random_int32 (q1);
  p161.z = random_int32 (q1);
  p161.w = random_int32 (q1);
  p162.x = random_int32 (q2);
  p162.y = random_int32 (q2);
  p162.z = random_int32 (q2);
  p162.w = random_int32 (q2);
  s = slaw_v4int32 (p161);
  TestAgainstPredicates (eSlawType_v4int32, s);
  if (memcmp (&p162, slaw_v4int32_emit (s), sizeof (v4int32)) != 0)
    error_exit ("compare failed for v4int32\n");
  if (memcmp (&p162, slaw_v4int32_emit_nocheck (s), sizeof (v4int32)) != 0)
    error_exit ("compare failed for v4int32\n");
  slaw_free (s);
  for (i = 0; i < 1782; i++)
    {
      p163[i].x = random_int32 (q3);
      p163[i].y = random_int32 (q3);
      p163[i].z = random_int32 (q3);
      p163[i].w = random_int32 (q3);
    }
  s1 = slaw_v4int32_array_raw (1782, &p164);
  s2 = slaw_v4int32_array_empty (random_unt8 (q1));
  s3 = slaw_v4int32_array_filled (random_unt8 (q1), p161);
  s4 = slaw_v4int32_array (p163, 1782);
  TestAgainstPredicates (eSlawType_v4int32_array, s1);
  TestAgainstPredicates (eSlawType_v4int32_array, s2);
  TestAgainstPredicates (eSlawType_v4int32_array, s3);
  TestAgainstPredicates (eSlawType_v4int32_array, s4);
  n = sizeof (v4int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p162, i + slaw_v4int32_array_emit (s3), sizeof (v4int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p164, p163, sizeof (p163));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int32_array_emit_nth (s3, i)
          != i + slaw_v4int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int32_arrays_concat (s3, s4, NULL);
  s = slaw_v4int32_array_empty (0);
  s6 = slaw_v4int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int32_array_concat_carray (s3, p163, 1782);
  s8 = slaw_v4int32_array_concat_carray_f (s3, p163, 1782);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt32 p165;
  v4unt32 p166;
  v4unt32 p167[1281];
  v4unt32 *p168;
  p165.x = random_unt32 (q1);
  p165.y = random_unt32 (q1);
  p165.z = random_unt32 (q1);
  p165.w = random_unt32 (q1);
  p166.x = random_unt32 (q2);
  p166.y = random_unt32 (q2);
  p166.z = random_unt32 (q2);
  p166.w = random_unt32 (q2);
  s = slaw_v4unt32 (p165);
  TestAgainstPredicates (eSlawType_v4unt32, s);
  if (memcmp (&p166, slaw_v4unt32_emit (s), sizeof (v4unt32)) != 0)
    error_exit ("compare failed for v4unt32\n");
  if (memcmp (&p166, slaw_v4unt32_emit_nocheck (s), sizeof (v4unt32)) != 0)
    error_exit ("compare failed for v4unt32\n");
  slaw_free (s);
  for (i = 0; i < 1281; i++)
    {
      p167[i].x = random_unt32 (q3);
      p167[i].y = random_unt32 (q3);
      p167[i].z = random_unt32 (q3);
      p167[i].w = random_unt32 (q3);
    }
  s1 = slaw_v4unt32_array_raw (1281, &p168);
  s2 = slaw_v4unt32_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt32_array_filled (random_unt8 (q1), p165);
  s4 = slaw_v4unt32_array (p167, 1281);
  TestAgainstPredicates (eSlawType_v4unt32_array, s1);
  TestAgainstPredicates (eSlawType_v4unt32_array, s2);
  TestAgainstPredicates (eSlawType_v4unt32_array, s3);
  TestAgainstPredicates (eSlawType_v4unt32_array, s4);
  n = sizeof (v4unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p166, i + slaw_v4unt32_array_emit (s3), sizeof (v4unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p168, p167, sizeof (p167));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt32_array_emit_nth (s3, i)
          != i + slaw_v4unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt32_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt32_array_empty (0);
  s6 = slaw_v4unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt32_array_concat_carray (s3, p167, 1281);
  s8 = slaw_v4unt32_array_concat_carray_f (s3, p167, 1281);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int64 p169;
  v4int64 p170;
  v4int64 p171[317];
  v4int64 *p172;
  p169.x = random_int64 (q1);
  p169.y = random_int64 (q1);
  p169.z = random_int64 (q1);
  p169.w = random_int64 (q1);
  p170.x = random_int64 (q2);
  p170.y = random_int64 (q2);
  p170.z = random_int64 (q2);
  p170.w = random_int64 (q2);
  s = slaw_v4int64 (p169);
  TestAgainstPredicates (eSlawType_v4int64, s);
  if (memcmp (&p170, slaw_v4int64_emit (s), sizeof (v4int64)) != 0)
    error_exit ("compare failed for v4int64\n");
  if (memcmp (&p170, slaw_v4int64_emit_nocheck (s), sizeof (v4int64)) != 0)
    error_exit ("compare failed for v4int64\n");
  slaw_free (s);
  for (i = 0; i < 317; i++)
    {
      p171[i].x = random_int64 (q3);
      p171[i].y = random_int64 (q3);
      p171[i].z = random_int64 (q3);
      p171[i].w = random_int64 (q3);
    }
  s1 = slaw_v4int64_array_raw (317, &p172);
  s2 = slaw_v4int64_array_empty (random_unt8 (q1));
  s3 = slaw_v4int64_array_filled (random_unt8 (q1), p169);
  s4 = slaw_v4int64_array (p171, 317);
  TestAgainstPredicates (eSlawType_v4int64_array, s1);
  TestAgainstPredicates (eSlawType_v4int64_array, s2);
  TestAgainstPredicates (eSlawType_v4int64_array, s3);
  TestAgainstPredicates (eSlawType_v4int64_array, s4);
  n = sizeof (v4int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p170, i + slaw_v4int64_array_emit (s3), sizeof (v4int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p172, p171, sizeof (p171));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int64_array_emit_nth (s3, i)
          != i + slaw_v4int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int64_arrays_concat (s3, s4, NULL);
  s = slaw_v4int64_array_empty (0);
  s6 = slaw_v4int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int64_array_concat_carray (s3, p171, 317);
  s8 = slaw_v4int64_array_concat_carray_f (s3, p171, 317);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt64 p173;
  v4unt64 p174;
  v4unt64 p175[1056];
  v4unt64 *p176;
  p173.x = random_unt64 (q1);
  p173.y = random_unt64 (q1);
  p173.z = random_unt64 (q1);
  p173.w = random_unt64 (q1);
  p174.x = random_unt64 (q2);
  p174.y = random_unt64 (q2);
  p174.z = random_unt64 (q2);
  p174.w = random_unt64 (q2);
  s = slaw_v4unt64 (p173);
  TestAgainstPredicates (eSlawType_v4unt64, s);
  if (memcmp (&p174, slaw_v4unt64_emit (s), sizeof (v4unt64)) != 0)
    error_exit ("compare failed for v4unt64\n");
  if (memcmp (&p174, slaw_v4unt64_emit_nocheck (s), sizeof (v4unt64)) != 0)
    error_exit ("compare failed for v4unt64\n");
  slaw_free (s);
  for (i = 0; i < 1056; i++)
    {
      p175[i].x = random_unt64 (q3);
      p175[i].y = random_unt64 (q3);
      p175[i].z = random_unt64 (q3);
      p175[i].w = random_unt64 (q3);
    }
  s1 = slaw_v4unt64_array_raw (1056, &p176);
  s2 = slaw_v4unt64_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt64_array_filled (random_unt8 (q1), p173);
  s4 = slaw_v4unt64_array (p175, 1056);
  TestAgainstPredicates (eSlawType_v4unt64_array, s1);
  TestAgainstPredicates (eSlawType_v4unt64_array, s2);
  TestAgainstPredicates (eSlawType_v4unt64_array, s3);
  TestAgainstPredicates (eSlawType_v4unt64_array, s4);
  n = sizeof (v4unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p174, i + slaw_v4unt64_array_emit (s3), sizeof (v4unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p176, p175, sizeof (p175));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt64_array_emit_nth (s3, i)
          != i + slaw_v4unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt64_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt64_array_empty (0);
  s6 = slaw_v4unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt64_array_concat_carray (s3, p175, 1056);
  s8 = slaw_v4unt64_array_concat_carray_f (s3, p175, 1056);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4float32 p177;
  v4float32 p178;
  v4float32 p179[1852];
  v4float32 *p180;
  p177.x = random_float32 (q1);
  p177.y = random_float32 (q1);
  p177.z = random_float32 (q1);
  p177.w = random_float32 (q1);
  p178.x = random_float32 (q2);
  p178.y = random_float32 (q2);
  p178.z = random_float32 (q2);
  p178.w = random_float32 (q2);
  s = slaw_v4float32 (p177);
  TestAgainstPredicates (eSlawType_v4float32, s);
  if (memcmp (&p178, slaw_v4float32_emit (s), sizeof (v4float32)) != 0)
    error_exit ("compare failed for v4float32\n");
  if (memcmp (&p178, slaw_v4float32_emit_nocheck (s), sizeof (v4float32)) != 0)
    error_exit ("compare failed for v4float32\n");
  slaw_free (s);
  for (i = 0; i < 1852; i++)
    {
      p179[i].x = random_float32 (q3);
      p179[i].y = random_float32 (q3);
      p179[i].z = random_float32 (q3);
      p179[i].w = random_float32 (q3);
    }
  s1 = slaw_v4float32_array_raw (1852, &p180);
  s2 = slaw_v4float32_array_empty (random_unt8 (q1));
  s3 = slaw_v4float32_array_filled (random_unt8 (q1), p177);
  s4 = slaw_v4float32_array (p179, 1852);
  TestAgainstPredicates (eSlawType_v4float32_array, s1);
  TestAgainstPredicates (eSlawType_v4float32_array, s2);
  TestAgainstPredicates (eSlawType_v4float32_array, s3);
  TestAgainstPredicates (eSlawType_v4float32_array, s4);
  n = sizeof (v4float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p178, i + slaw_v4float32_array_emit (s3), sizeof (v4float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p180, p179, sizeof (p179));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4float32_array_emit_nth (s3, i)
          != i + slaw_v4float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4float32_arrays_concat (s3, s4, NULL);
  s = slaw_v4float32_array_empty (0);
  s6 = slaw_v4float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4float32_array_concat_carray (s3, p179, 1852);
  s8 = slaw_v4float32_array_concat_carray_f (s3, p179, 1852);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4float64 p181;
  v4float64 p182;
  v4float64 p183[924];
  v4float64 *p184;
  p181.x = random_float64 (q1);
  p181.y = random_float64 (q1);
  p181.z = random_float64 (q1);
  p181.w = random_float64 (q1);
  p182.x = random_float64 (q2);
  p182.y = random_float64 (q2);
  p182.z = random_float64 (q2);
  p182.w = random_float64 (q2);
  s = slaw_v4float64 (p181);
  TestAgainstPredicates (eSlawType_v4float64, s);
  if (memcmp (&p182, slaw_v4float64_emit (s), sizeof (v4float64)) != 0)
    error_exit ("compare failed for v4float64\n");
  if (memcmp (&p182, slaw_v4float64_emit_nocheck (s), sizeof (v4float64)) != 0)
    error_exit ("compare failed for v4float64\n");
  slaw_free (s);
  for (i = 0; i < 924; i++)
    {
      p183[i].x = random_float64 (q3);
      p183[i].y = random_float64 (q3);
      p183[i].z = random_float64 (q3);
      p183[i].w = random_float64 (q3);
    }
  s1 = slaw_v4float64_array_raw (924, &p184);
  s2 = slaw_v4float64_array_empty (random_unt8 (q1));
  s3 = slaw_v4float64_array_filled (random_unt8 (q1), p181);
  s4 = slaw_v4float64_array (p183, 924);
  TestAgainstPredicates (eSlawType_v4float64_array, s1);
  TestAgainstPredicates (eSlawType_v4float64_array, s2);
  TestAgainstPredicates (eSlawType_v4float64_array, s3);
  TestAgainstPredicates (eSlawType_v4float64_array, s4);
  n = sizeof (v4float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p182, i + slaw_v4float64_array_emit (s3), sizeof (v4float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p184, p183, sizeof (p183));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4float64_array_emit_nth (s3, i)
          != i + slaw_v4float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4float64_arrays_concat (s3, s4, NULL);
  s = slaw_v4float64_array_empty (0);
  s6 = slaw_v4float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4float64_array_concat_carray (s3, p183, 924);
  s8 = slaw_v4float64_array_concat_carray_f (s3, p183, 924);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int8 p185;
  v4int8 p186;
  v4int8 p187[400];
  v4int8 *p188;
  p185.x = random_int8 (q1);
  p185.y = random_int8 (q1);
  p185.z = random_int8 (q1);
  p185.w = random_int8 (q1);
  p186.x = random_int8 (q2);
  p186.y = random_int8 (q2);
  p186.z = random_int8 (q2);
  p186.w = random_int8 (q2);
  s = slaw_v4int8 (p185);
  TestAgainstPredicates (eSlawType_v4int8, s);
  if (memcmp (&p186, slaw_v4int8_emit (s), sizeof (v4int8)) != 0)
    error_exit ("compare failed for v4int8\n");
  if (memcmp (&p186, slaw_v4int8_emit_nocheck (s), sizeof (v4int8)) != 0)
    error_exit ("compare failed for v4int8\n");
  slaw_free (s);
  for (i = 0; i < 400; i++)
    {
      p187[i].x = random_int8 (q3);
      p187[i].y = random_int8 (q3);
      p187[i].z = random_int8 (q3);
      p187[i].w = random_int8 (q3);
    }
  s1 = slaw_v4int8_array_raw (400, &p188);
  s2 = slaw_v4int8_array_empty (random_unt8 (q1));
  s3 = slaw_v4int8_array_filled (random_unt8 (q1), p185);
  s4 = slaw_v4int8_array (p187, 400);
  TestAgainstPredicates (eSlawType_v4int8_array, s1);
  TestAgainstPredicates (eSlawType_v4int8_array, s2);
  TestAgainstPredicates (eSlawType_v4int8_array, s3);
  TestAgainstPredicates (eSlawType_v4int8_array, s4);
  n = sizeof (v4int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p186, i + slaw_v4int8_array_emit (s3), sizeof (v4int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p188, p187, sizeof (p187));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int8_array_emit_nth (s3, i) != i + slaw_v4int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int8_arrays_concat (s3, s4, NULL);
  s = slaw_v4int8_array_empty (0);
  s6 = slaw_v4int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int8_array_concat_carray (s3, p187, 400);
  s8 = slaw_v4int8_array_concat_carray_f (s3, p187, 400);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt8 p189;
  v4unt8 p190;
  v4unt8 p191[1930];
  v4unt8 *p192;
  p189.x = random_unt8 (q1);
  p189.y = random_unt8 (q1);
  p189.z = random_unt8 (q1);
  p189.w = random_unt8 (q1);
  p190.x = random_unt8 (q2);
  p190.y = random_unt8 (q2);
  p190.z = random_unt8 (q2);
  p190.w = random_unt8 (q2);
  s = slaw_v4unt8 (p189);
  TestAgainstPredicates (eSlawType_v4unt8, s);
  if (memcmp (&p190, slaw_v4unt8_emit (s), sizeof (v4unt8)) != 0)
    error_exit ("compare failed for v4unt8\n");
  if (memcmp (&p190, slaw_v4unt8_emit_nocheck (s), sizeof (v4unt8)) != 0)
    error_exit ("compare failed for v4unt8\n");
  slaw_free (s);
  for (i = 0; i < 1930; i++)
    {
      p191[i].x = random_unt8 (q3);
      p191[i].y = random_unt8 (q3);
      p191[i].z = random_unt8 (q3);
      p191[i].w = random_unt8 (q3);
    }
  s1 = slaw_v4unt8_array_raw (1930, &p192);
  s2 = slaw_v4unt8_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt8_array_filled (random_unt8 (q1), p189);
  s4 = slaw_v4unt8_array (p191, 1930);
  TestAgainstPredicates (eSlawType_v4unt8_array, s1);
  TestAgainstPredicates (eSlawType_v4unt8_array, s2);
  TestAgainstPredicates (eSlawType_v4unt8_array, s3);
  TestAgainstPredicates (eSlawType_v4unt8_array, s4);
  n = sizeof (v4unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p190, i + slaw_v4unt8_array_emit (s3), sizeof (v4unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p192, p191, sizeof (p191));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt8_array_emit_nth (s3, i) != i + slaw_v4unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt8_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt8_array_empty (0);
  s6 = slaw_v4unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt8_array_concat_carray (s3, p191, 1930);
  s8 = slaw_v4unt8_array_concat_carray_f (s3, p191, 1930);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int16 p193;
  v4int16 p194;
  v4int16 p195[607];
  v4int16 *p196;
  p193.x = random_int16 (q1);
  p193.y = random_int16 (q1);
  p193.z = random_int16 (q1);
  p193.w = random_int16 (q1);
  p194.x = random_int16 (q2);
  p194.y = random_int16 (q2);
  p194.z = random_int16 (q2);
  p194.w = random_int16 (q2);
  s = slaw_v4int16 (p193);
  TestAgainstPredicates (eSlawType_v4int16, s);
  if (memcmp (&p194, slaw_v4int16_emit (s), sizeof (v4int16)) != 0)
    error_exit ("compare failed for v4int16\n");
  if (memcmp (&p194, slaw_v4int16_emit_nocheck (s), sizeof (v4int16)) != 0)
    error_exit ("compare failed for v4int16\n");
  slaw_free (s);
  for (i = 0; i < 607; i++)
    {
      p195[i].x = random_int16 (q3);
      p195[i].y = random_int16 (q3);
      p195[i].z = random_int16 (q3);
      p195[i].w = random_int16 (q3);
    }
  s1 = slaw_v4int16_array_raw (607, &p196);
  s2 = slaw_v4int16_array_empty (random_unt8 (q1));
  s3 = slaw_v4int16_array_filled (random_unt8 (q1), p193);
  s4 = slaw_v4int16_array (p195, 607);
  TestAgainstPredicates (eSlawType_v4int16_array, s1);
  TestAgainstPredicates (eSlawType_v4int16_array, s2);
  TestAgainstPredicates (eSlawType_v4int16_array, s3);
  TestAgainstPredicates (eSlawType_v4int16_array, s4);
  n = sizeof (v4int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p194, i + slaw_v4int16_array_emit (s3), sizeof (v4int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p196, p195, sizeof (p195));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int16_array_emit_nth (s3, i)
          != i + slaw_v4int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int16_arrays_concat (s3, s4, NULL);
  s = slaw_v4int16_array_empty (0);
  s6 = slaw_v4int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int16_array_concat_carray (s3, p195, 607);
  s8 = slaw_v4int16_array_concat_carray_f (s3, p195, 607);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt16 p197;
  v4unt16 p198;
  v4unt16 p199[305];
  v4unt16 *p200;
  p197.x = random_unt16 (q1);
  p197.y = random_unt16 (q1);
  p197.z = random_unt16 (q1);
  p197.w = random_unt16 (q1);
  p198.x = random_unt16 (q2);
  p198.y = random_unt16 (q2);
  p198.z = random_unt16 (q2);
  p198.w = random_unt16 (q2);
  s = slaw_v4unt16 (p197);
  TestAgainstPredicates (eSlawType_v4unt16, s);
  if (memcmp (&p198, slaw_v4unt16_emit (s), sizeof (v4unt16)) != 0)
    error_exit ("compare failed for v4unt16\n");
  if (memcmp (&p198, slaw_v4unt16_emit_nocheck (s), sizeof (v4unt16)) != 0)
    error_exit ("compare failed for v4unt16\n");
  slaw_free (s);
  for (i = 0; i < 305; i++)
    {
      p199[i].x = random_unt16 (q3);
      p199[i].y = random_unt16 (q3);
      p199[i].z = random_unt16 (q3);
      p199[i].w = random_unt16 (q3);
    }
  s1 = slaw_v4unt16_array_raw (305, &p200);
  s2 = slaw_v4unt16_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt16_array_filled (random_unt8 (q1), p197);
  s4 = slaw_v4unt16_array (p199, 305);
  TestAgainstPredicates (eSlawType_v4unt16_array, s1);
  TestAgainstPredicates (eSlawType_v4unt16_array, s2);
  TestAgainstPredicates (eSlawType_v4unt16_array, s3);
  TestAgainstPredicates (eSlawType_v4unt16_array, s4);
  n = sizeof (v4unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p198, i + slaw_v4unt16_array_emit (s3), sizeof (v4unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p200, p199, sizeof (p199));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt16_array_emit_nth (s3, i)
          != i + slaw_v4unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt16_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt16_array_empty (0);
  s6 = slaw_v4unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt16_array_concat_carray (s3, p199, 305);
  s8 = slaw_v4unt16_array_concat_carray_f (s3, p199, 305);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int32c p201;
  v2int32c p202;
  v2int32c p203[1312];
  v2int32c *p204;
  p201.x.re = random_int32 (q1);
  p201.x.im = random_int32 (q1);
  p201.y.re = random_int32 (q1);
  p201.y.im = random_int32 (q1);
  p202.x.re = random_int32 (q2);
  p202.x.im = random_int32 (q2);
  p202.y.re = random_int32 (q2);
  p202.y.im = random_int32 (q2);
  s = slaw_v2int32c (p201);
  TestAgainstPredicates (eSlawType_v2int32c, s);
  if (memcmp (&p202, slaw_v2int32c_emit (s), sizeof (v2int32c)) != 0)
    error_exit ("compare failed for v2int32c\n");
  if (memcmp (&p202, slaw_v2int32c_emit_nocheck (s), sizeof (v2int32c)) != 0)
    error_exit ("compare failed for v2int32c\n");
  slaw_free (s);
  for (i = 0; i < 1312; i++)
    {
      p203[i].x.re = random_int32 (q3);
      p203[i].x.im = random_int32 (q3);
      p203[i].y.re = random_int32 (q3);
      p203[i].y.im = random_int32 (q3);
    }
  s1 = slaw_v2int32c_array_raw (1312, &p204);
  s2 = slaw_v2int32c_array_empty (random_unt8 (q1));
  s3 = slaw_v2int32c_array_filled (random_unt8 (q1), p201);
  s4 = slaw_v2int32c_array (p203, 1312);
  TestAgainstPredicates (eSlawType_v2int32c_array, s1);
  TestAgainstPredicates (eSlawType_v2int32c_array, s2);
  TestAgainstPredicates (eSlawType_v2int32c_array, s3);
  TestAgainstPredicates (eSlawType_v2int32c_array, s4);
  n = sizeof (v2int32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p202, i + slaw_v2int32c_array_emit (s3), sizeof (v2int32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p204, p203, sizeof (p203));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int32c_array_emit_nth (s3, i)
          != i + slaw_v2int32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int32c_arrays_concat (s3, s4, NULL);
  s = slaw_v2int32c_array_empty (0);
  s6 = slaw_v2int32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int32c_array_concat_carray (s3, p203, 1312);
  s8 = slaw_v2int32c_array_concat_carray_f (s3, p203, 1312);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt32c p205;
  v2unt32c p206;
  v2unt32c p207[682];
  v2unt32c *p208;
  p205.x.re = random_unt32 (q1);
  p205.x.im = random_unt32 (q1);
  p205.y.re = random_unt32 (q1);
  p205.y.im = random_unt32 (q1);
  p206.x.re = random_unt32 (q2);
  p206.x.im = random_unt32 (q2);
  p206.y.re = random_unt32 (q2);
  p206.y.im = random_unt32 (q2);
  s = slaw_v2unt32c (p205);
  TestAgainstPredicates (eSlawType_v2unt32c, s);
  if (memcmp (&p206, slaw_v2unt32c_emit (s), sizeof (v2unt32c)) != 0)
    error_exit ("compare failed for v2unt32c\n");
  if (memcmp (&p206, slaw_v2unt32c_emit_nocheck (s), sizeof (v2unt32c)) != 0)
    error_exit ("compare failed for v2unt32c\n");
  slaw_free (s);
  for (i = 0; i < 682; i++)
    {
      p207[i].x.re = random_unt32 (q3);
      p207[i].x.im = random_unt32 (q3);
      p207[i].y.re = random_unt32 (q3);
      p207[i].y.im = random_unt32 (q3);
    }
  s1 = slaw_v2unt32c_array_raw (682, &p208);
  s2 = slaw_v2unt32c_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt32c_array_filled (random_unt8 (q1), p205);
  s4 = slaw_v2unt32c_array (p207, 682);
  TestAgainstPredicates (eSlawType_v2unt32c_array, s1);
  TestAgainstPredicates (eSlawType_v2unt32c_array, s2);
  TestAgainstPredicates (eSlawType_v2unt32c_array, s3);
  TestAgainstPredicates (eSlawType_v2unt32c_array, s4);
  n = sizeof (v2unt32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p206, i + slaw_v2unt32c_array_emit (s3), sizeof (v2unt32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p208, p207, sizeof (p207));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt32c_array_emit_nth (s3, i)
          != i + slaw_v2unt32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt32c_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt32c_array_empty (0);
  s6 = slaw_v2unt32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt32c_array_concat_carray (s3, p207, 682);
  s8 = slaw_v2unt32c_array_concat_carray_f (s3, p207, 682);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int64c p209;
  v2int64c p210;
  v2int64c p211[1189];
  v2int64c *p212;
  p209.x.re = random_int64 (q1);
  p209.x.im = random_int64 (q1);
  p209.y.re = random_int64 (q1);
  p209.y.im = random_int64 (q1);
  p210.x.re = random_int64 (q2);
  p210.x.im = random_int64 (q2);
  p210.y.re = random_int64 (q2);
  p210.y.im = random_int64 (q2);
  s = slaw_v2int64c (p209);
  TestAgainstPredicates (eSlawType_v2int64c, s);
  if (memcmp (&p210, slaw_v2int64c_emit (s), sizeof (v2int64c)) != 0)
    error_exit ("compare failed for v2int64c\n");
  if (memcmp (&p210, slaw_v2int64c_emit_nocheck (s), sizeof (v2int64c)) != 0)
    error_exit ("compare failed for v2int64c\n");
  slaw_free (s);
  for (i = 0; i < 1189; i++)
    {
      p211[i].x.re = random_int64 (q3);
      p211[i].x.im = random_int64 (q3);
      p211[i].y.re = random_int64 (q3);
      p211[i].y.im = random_int64 (q3);
    }
  s1 = slaw_v2int64c_array_raw (1189, &p212);
  s2 = slaw_v2int64c_array_empty (random_unt8 (q1));
  s3 = slaw_v2int64c_array_filled (random_unt8 (q1), p209);
  s4 = slaw_v2int64c_array (p211, 1189);
  TestAgainstPredicates (eSlawType_v2int64c_array, s1);
  TestAgainstPredicates (eSlawType_v2int64c_array, s2);
  TestAgainstPredicates (eSlawType_v2int64c_array, s3);
  TestAgainstPredicates (eSlawType_v2int64c_array, s4);
  n = sizeof (v2int64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p210, i + slaw_v2int64c_array_emit (s3), sizeof (v2int64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p212, p211, sizeof (p211));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int64c_array_emit_nth (s3, i)
          != i + slaw_v2int64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int64c_arrays_concat (s3, s4, NULL);
  s = slaw_v2int64c_array_empty (0);
  s6 = slaw_v2int64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int64c_array_concat_carray (s3, p211, 1189);
  s8 = slaw_v2int64c_array_concat_carray_f (s3, p211, 1189);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt64c p213;
  v2unt64c p214;
  v2unt64c p215[494];
  v2unt64c *p216;
  p213.x.re = random_unt64 (q1);
  p213.x.im = random_unt64 (q1);
  p213.y.re = random_unt64 (q1);
  p213.y.im = random_unt64 (q1);
  p214.x.re = random_unt64 (q2);
  p214.x.im = random_unt64 (q2);
  p214.y.re = random_unt64 (q2);
  p214.y.im = random_unt64 (q2);
  s = slaw_v2unt64c (p213);
  TestAgainstPredicates (eSlawType_v2unt64c, s);
  if (memcmp (&p214, slaw_v2unt64c_emit (s), sizeof (v2unt64c)) != 0)
    error_exit ("compare failed for v2unt64c\n");
  if (memcmp (&p214, slaw_v2unt64c_emit_nocheck (s), sizeof (v2unt64c)) != 0)
    error_exit ("compare failed for v2unt64c\n");
  slaw_free (s);
  for (i = 0; i < 494; i++)
    {
      p215[i].x.re = random_unt64 (q3);
      p215[i].x.im = random_unt64 (q3);
      p215[i].y.re = random_unt64 (q3);
      p215[i].y.im = random_unt64 (q3);
    }
  s1 = slaw_v2unt64c_array_raw (494, &p216);
  s2 = slaw_v2unt64c_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt64c_array_filled (random_unt8 (q1), p213);
  s4 = slaw_v2unt64c_array (p215, 494);
  TestAgainstPredicates (eSlawType_v2unt64c_array, s1);
  TestAgainstPredicates (eSlawType_v2unt64c_array, s2);
  TestAgainstPredicates (eSlawType_v2unt64c_array, s3);
  TestAgainstPredicates (eSlawType_v2unt64c_array, s4);
  n = sizeof (v2unt64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p214, i + slaw_v2unt64c_array_emit (s3), sizeof (v2unt64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p216, p215, sizeof (p215));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt64c_array_emit_nth (s3, i)
          != i + slaw_v2unt64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt64c_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt64c_array_empty (0);
  s6 = slaw_v2unt64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt64c_array_concat_carray (s3, p215, 494);
  s8 = slaw_v2unt64c_array_concat_carray_f (s3, p215, 494);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2float32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2float32c p217;
  v2float32c p218;
  v2float32c p219[242];
  v2float32c *p220;
  p217.x.re = random_float32 (q1);
  p217.x.im = random_float32 (q1);
  p217.y.re = random_float32 (q1);
  p217.y.im = random_float32 (q1);
  p218.x.re = random_float32 (q2);
  p218.x.im = random_float32 (q2);
  p218.y.re = random_float32 (q2);
  p218.y.im = random_float32 (q2);
  s = slaw_v2float32c (p217);
  TestAgainstPredicates (eSlawType_v2float32c, s);
  if (memcmp (&p218, slaw_v2float32c_emit (s), sizeof (v2float32c)) != 0)
    error_exit ("compare failed for v2float32c\n");
  if (memcmp (&p218, slaw_v2float32c_emit_nocheck (s), sizeof (v2float32c))
      != 0)
    error_exit ("compare failed for v2float32c\n");
  slaw_free (s);
  for (i = 0; i < 242; i++)
    {
      p219[i].x.re = random_float32 (q3);
      p219[i].x.im = random_float32 (q3);
      p219[i].y.re = random_float32 (q3);
      p219[i].y.im = random_float32 (q3);
    }
  s1 = slaw_v2float32c_array_raw (242, &p220);
  s2 = slaw_v2float32c_array_empty (random_unt8 (q1));
  s3 = slaw_v2float32c_array_filled (random_unt8 (q1), p217);
  s4 = slaw_v2float32c_array (p219, 242);
  TestAgainstPredicates (eSlawType_v2float32c_array, s1);
  TestAgainstPredicates (eSlawType_v2float32c_array, s2);
  TestAgainstPredicates (eSlawType_v2float32c_array, s3);
  TestAgainstPredicates (eSlawType_v2float32c_array, s4);
  n = sizeof (v2float32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2float32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p218, i + slaw_v2float32c_array_emit (s3),
                  sizeof (v2float32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p220, p219, sizeof (p219));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2float32c_array_emit_nth (s3, i)
          != i + slaw_v2float32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2float32c_arrays_concat (s3, s4, NULL);
  s = slaw_v2float32c_array_empty (0);
  s6 = slaw_v2float32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2float32c_array_concat_carray (s3, p219, 242);
  s8 = slaw_v2float32c_array_concat_carray_f (s3, p219, 242);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2float64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2float64c p221;
  v2float64c p222;
  v2float64c p223[1214];
  v2float64c *p224;
  p221.x.re = random_float64 (q1);
  p221.x.im = random_float64 (q1);
  p221.y.re = random_float64 (q1);
  p221.y.im = random_float64 (q1);
  p222.x.re = random_float64 (q2);
  p222.x.im = random_float64 (q2);
  p222.y.re = random_float64 (q2);
  p222.y.im = random_float64 (q2);
  s = slaw_v2float64c (p221);
  TestAgainstPredicates (eSlawType_v2float64c, s);
  if (memcmp (&p222, slaw_v2float64c_emit (s), sizeof (v2float64c)) != 0)
    error_exit ("compare failed for v2float64c\n");
  if (memcmp (&p222, slaw_v2float64c_emit_nocheck (s), sizeof (v2float64c))
      != 0)
    error_exit ("compare failed for v2float64c\n");
  slaw_free (s);
  for (i = 0; i < 1214; i++)
    {
      p223[i].x.re = random_float64 (q3);
      p223[i].x.im = random_float64 (q3);
      p223[i].y.re = random_float64 (q3);
      p223[i].y.im = random_float64 (q3);
    }
  s1 = slaw_v2float64c_array_raw (1214, &p224);
  s2 = slaw_v2float64c_array_empty (random_unt8 (q1));
  s3 = slaw_v2float64c_array_filled (random_unt8 (q1), p221);
  s4 = slaw_v2float64c_array (p223, 1214);
  TestAgainstPredicates (eSlawType_v2float64c_array, s1);
  TestAgainstPredicates (eSlawType_v2float64c_array, s2);
  TestAgainstPredicates (eSlawType_v2float64c_array, s3);
  TestAgainstPredicates (eSlawType_v2float64c_array, s4);
  n = sizeof (v2float64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2float64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p222, i + slaw_v2float64c_array_emit (s3),
                  sizeof (v2float64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p224, p223, sizeof (p223));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2float64c_array_emit_nth (s3, i)
          != i + slaw_v2float64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2float64c_arrays_concat (s3, s4, NULL);
  s = slaw_v2float64c_array_empty (0);
  s6 = slaw_v2float64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2float64c_array_concat_carray (s3, p223, 1214);
  s8 = slaw_v2float64c_array_concat_carray_f (s3, p223, 1214);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int8c p225;
  v2int8c p226;
  v2int8c p227[442];
  v2int8c *p228;
  p225.x.re = random_int8 (q1);
  p225.x.im = random_int8 (q1);
  p225.y.re = random_int8 (q1);
  p225.y.im = random_int8 (q1);
  p226.x.re = random_int8 (q2);
  p226.x.im = random_int8 (q2);
  p226.y.re = random_int8 (q2);
  p226.y.im = random_int8 (q2);
  s = slaw_v2int8c (p225);
  TestAgainstPredicates (eSlawType_v2int8c, s);
  if (memcmp (&p226, slaw_v2int8c_emit (s), sizeof (v2int8c)) != 0)
    error_exit ("compare failed for v2int8c\n");
  if (memcmp (&p226, slaw_v2int8c_emit_nocheck (s), sizeof (v2int8c)) != 0)
    error_exit ("compare failed for v2int8c\n");
  slaw_free (s);
  for (i = 0; i < 442; i++)
    {
      p227[i].x.re = random_int8 (q3);
      p227[i].x.im = random_int8 (q3);
      p227[i].y.re = random_int8 (q3);
      p227[i].y.im = random_int8 (q3);
    }
  s1 = slaw_v2int8c_array_raw (442, &p228);
  s2 = slaw_v2int8c_array_empty (random_unt8 (q1));
  s3 = slaw_v2int8c_array_filled (random_unt8 (q1), p225);
  s4 = slaw_v2int8c_array (p227, 442);
  TestAgainstPredicates (eSlawType_v2int8c_array, s1);
  TestAgainstPredicates (eSlawType_v2int8c_array, s2);
  TestAgainstPredicates (eSlawType_v2int8c_array, s3);
  TestAgainstPredicates (eSlawType_v2int8c_array, s4);
  n = sizeof (v2int8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p226, i + slaw_v2int8c_array_emit (s3), sizeof (v2int8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p228, p227, sizeof (p227));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int8c_array_emit_nth (s3, i)
          != i + slaw_v2int8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int8c_arrays_concat (s3, s4, NULL);
  s = slaw_v2int8c_array_empty (0);
  s6 = slaw_v2int8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int8c_array_concat_carray (s3, p227, 442);
  s8 = slaw_v2int8c_array_concat_carray_f (s3, p227, 442);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt8c p229;
  v2unt8c p230;
  v2unt8c p231[608];
  v2unt8c *p232;
  p229.x.re = random_unt8 (q1);
  p229.x.im = random_unt8 (q1);
  p229.y.re = random_unt8 (q1);
  p229.y.im = random_unt8 (q1);
  p230.x.re = random_unt8 (q2);
  p230.x.im = random_unt8 (q2);
  p230.y.re = random_unt8 (q2);
  p230.y.im = random_unt8 (q2);
  s = slaw_v2unt8c (p229);
  TestAgainstPredicates (eSlawType_v2unt8c, s);
  if (memcmp (&p230, slaw_v2unt8c_emit (s), sizeof (v2unt8c)) != 0)
    error_exit ("compare failed for v2unt8c\n");
  if (memcmp (&p230, slaw_v2unt8c_emit_nocheck (s), sizeof (v2unt8c)) != 0)
    error_exit ("compare failed for v2unt8c\n");
  slaw_free (s);
  for (i = 0; i < 608; i++)
    {
      p231[i].x.re = random_unt8 (q3);
      p231[i].x.im = random_unt8 (q3);
      p231[i].y.re = random_unt8 (q3);
      p231[i].y.im = random_unt8 (q3);
    }
  s1 = slaw_v2unt8c_array_raw (608, &p232);
  s2 = slaw_v2unt8c_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt8c_array_filled (random_unt8 (q1), p229);
  s4 = slaw_v2unt8c_array (p231, 608);
  TestAgainstPredicates (eSlawType_v2unt8c_array, s1);
  TestAgainstPredicates (eSlawType_v2unt8c_array, s2);
  TestAgainstPredicates (eSlawType_v2unt8c_array, s3);
  TestAgainstPredicates (eSlawType_v2unt8c_array, s4);
  n = sizeof (v2unt8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p230, i + slaw_v2unt8c_array_emit (s3), sizeof (v2unt8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p232, p231, sizeof (p231));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt8c_array_emit_nth (s3, i)
          != i + slaw_v2unt8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt8c_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt8c_array_empty (0);
  s6 = slaw_v2unt8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt8c_array_concat_carray (s3, p231, 608);
  s8 = slaw_v2unt8c_array_concat_carray_f (s3, p231, 608);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2int16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2int16c p233;
  v2int16c p234;
  v2int16c p235[395];
  v2int16c *p236;
  p233.x.re = random_int16 (q1);
  p233.x.im = random_int16 (q1);
  p233.y.re = random_int16 (q1);
  p233.y.im = random_int16 (q1);
  p234.x.re = random_int16 (q2);
  p234.x.im = random_int16 (q2);
  p234.y.re = random_int16 (q2);
  p234.y.im = random_int16 (q2);
  s = slaw_v2int16c (p233);
  TestAgainstPredicates (eSlawType_v2int16c, s);
  if (memcmp (&p234, slaw_v2int16c_emit (s), sizeof (v2int16c)) != 0)
    error_exit ("compare failed for v2int16c\n");
  if (memcmp (&p234, slaw_v2int16c_emit_nocheck (s), sizeof (v2int16c)) != 0)
    error_exit ("compare failed for v2int16c\n");
  slaw_free (s);
  for (i = 0; i < 395; i++)
    {
      p235[i].x.re = random_int16 (q3);
      p235[i].x.im = random_int16 (q3);
      p235[i].y.re = random_int16 (q3);
      p235[i].y.im = random_int16 (q3);
    }
  s1 = slaw_v2int16c_array_raw (395, &p236);
  s2 = slaw_v2int16c_array_empty (random_unt8 (q1));
  s3 = slaw_v2int16c_array_filled (random_unt8 (q1), p233);
  s4 = slaw_v2int16c_array (p235, 395);
  TestAgainstPredicates (eSlawType_v2int16c_array, s1);
  TestAgainstPredicates (eSlawType_v2int16c_array, s2);
  TestAgainstPredicates (eSlawType_v2int16c_array, s3);
  TestAgainstPredicates (eSlawType_v2int16c_array, s4);
  n = sizeof (v2int16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2int16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p234, i + slaw_v2int16c_array_emit (s3), sizeof (v2int16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p236, p235, sizeof (p235));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2int16c_array_emit_nth (s3, i)
          != i + slaw_v2int16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2int16c_arrays_concat (s3, s4, NULL);
  s = slaw_v2int16c_array_empty (0);
  s6 = slaw_v2int16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2int16c_array_concat_carray (s3, p235, 395);
  s8 = slaw_v2int16c_array_concat_carray_f (s3, p235, 395);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v2unt16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v2unt16c p237;
  v2unt16c p238;
  v2unt16c p239[1370];
  v2unt16c *p240;
  p237.x.re = random_unt16 (q1);
  p237.x.im = random_unt16 (q1);
  p237.y.re = random_unt16 (q1);
  p237.y.im = random_unt16 (q1);
  p238.x.re = random_unt16 (q2);
  p238.x.im = random_unt16 (q2);
  p238.y.re = random_unt16 (q2);
  p238.y.im = random_unt16 (q2);
  s = slaw_v2unt16c (p237);
  TestAgainstPredicates (eSlawType_v2unt16c, s);
  if (memcmp (&p238, slaw_v2unt16c_emit (s), sizeof (v2unt16c)) != 0)
    error_exit ("compare failed for v2unt16c\n");
  if (memcmp (&p238, slaw_v2unt16c_emit_nocheck (s), sizeof (v2unt16c)) != 0)
    error_exit ("compare failed for v2unt16c\n");
  slaw_free (s);
  for (i = 0; i < 1370; i++)
    {
      p239[i].x.re = random_unt16 (q3);
      p239[i].x.im = random_unt16 (q3);
      p239[i].y.re = random_unt16 (q3);
      p239[i].y.im = random_unt16 (q3);
    }
  s1 = slaw_v2unt16c_array_raw (1370, &p240);
  s2 = slaw_v2unt16c_array_empty (random_unt8 (q1));
  s3 = slaw_v2unt16c_array_filled (random_unt8 (q1), p237);
  s4 = slaw_v2unt16c_array (p239, 1370);
  TestAgainstPredicates (eSlawType_v2unt16c_array, s1);
  TestAgainstPredicates (eSlawType_v2unt16c_array, s2);
  TestAgainstPredicates (eSlawType_v2unt16c_array, s3);
  TestAgainstPredicates (eSlawType_v2unt16c_array, s4);
  n = sizeof (v2unt16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v2unt16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p238, i + slaw_v2unt16c_array_emit (s3), sizeof (v2unt16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p240, p239, sizeof (p239));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v2unt16c_array_emit_nth (s3, i)
          != i + slaw_v2unt16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v2unt16c_arrays_concat (s3, s4, NULL);
  s = slaw_v2unt16c_array_empty (0);
  s6 = slaw_v2unt16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v2unt16c_array_concat_carray (s3, p239, 1370);
  s8 = slaw_v2unt16c_array_concat_carray_f (s3, p239, 1370);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int32c p241;
  v3int32c p242;
  v3int32c p243[1810];
  v3int32c *p244;
  p241.x.re = random_int32 (q1);
  p241.x.im = random_int32 (q1);
  p241.y.re = random_int32 (q1);
  p241.y.im = random_int32 (q1);
  p241.z.re = random_int32 (q1);
  p241.z.im = random_int32 (q1);
  p242.x.re = random_int32 (q2);
  p242.x.im = random_int32 (q2);
  p242.y.re = random_int32 (q2);
  p242.y.im = random_int32 (q2);
  p242.z.re = random_int32 (q2);
  p242.z.im = random_int32 (q2);
  s = slaw_v3int32c (p241);
  TestAgainstPredicates (eSlawType_v3int32c, s);
  if (memcmp (&p242, slaw_v3int32c_emit (s), sizeof (v3int32c)) != 0)
    error_exit ("compare failed for v3int32c\n");
  if (memcmp (&p242, slaw_v3int32c_emit_nocheck (s), sizeof (v3int32c)) != 0)
    error_exit ("compare failed for v3int32c\n");
  slaw_free (s);
  for (i = 0; i < 1810; i++)
    {
      p243[i].x.re = random_int32 (q3);
      p243[i].x.im = random_int32 (q3);
      p243[i].y.re = random_int32 (q3);
      p243[i].y.im = random_int32 (q3);
      p243[i].z.re = random_int32 (q3);
      p243[i].z.im = random_int32 (q3);
    }
  s1 = slaw_v3int32c_array_raw (1810, &p244);
  s2 = slaw_v3int32c_array_empty (random_unt8 (q1));
  s3 = slaw_v3int32c_array_filled (random_unt8 (q1), p241);
  s4 = slaw_v3int32c_array (p243, 1810);
  TestAgainstPredicates (eSlawType_v3int32c_array, s1);
  TestAgainstPredicates (eSlawType_v3int32c_array, s2);
  TestAgainstPredicates (eSlawType_v3int32c_array, s3);
  TestAgainstPredicates (eSlawType_v3int32c_array, s4);
  n = sizeof (v3int32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p242, i + slaw_v3int32c_array_emit (s3), sizeof (v3int32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p244, p243, sizeof (p243));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int32c_array_emit_nth (s3, i)
          != i + slaw_v3int32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int32c_arrays_concat (s3, s4, NULL);
  s = slaw_v3int32c_array_empty (0);
  s6 = slaw_v3int32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int32c_array_concat_carray (s3, p243, 1810);
  s8 = slaw_v3int32c_array_concat_carray_f (s3, p243, 1810);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt32c p245;
  v3unt32c p246;
  v3unt32c p247[1087];
  v3unt32c *p248;
  p245.x.re = random_unt32 (q1);
  p245.x.im = random_unt32 (q1);
  p245.y.re = random_unt32 (q1);
  p245.y.im = random_unt32 (q1);
  p245.z.re = random_unt32 (q1);
  p245.z.im = random_unt32 (q1);
  p246.x.re = random_unt32 (q2);
  p246.x.im = random_unt32 (q2);
  p246.y.re = random_unt32 (q2);
  p246.y.im = random_unt32 (q2);
  p246.z.re = random_unt32 (q2);
  p246.z.im = random_unt32 (q2);
  s = slaw_v3unt32c (p245);
  TestAgainstPredicates (eSlawType_v3unt32c, s);
  if (memcmp (&p246, slaw_v3unt32c_emit (s), sizeof (v3unt32c)) != 0)
    error_exit ("compare failed for v3unt32c\n");
  if (memcmp (&p246, slaw_v3unt32c_emit_nocheck (s), sizeof (v3unt32c)) != 0)
    error_exit ("compare failed for v3unt32c\n");
  slaw_free (s);
  for (i = 0; i < 1087; i++)
    {
      p247[i].x.re = random_unt32 (q3);
      p247[i].x.im = random_unt32 (q3);
      p247[i].y.re = random_unt32 (q3);
      p247[i].y.im = random_unt32 (q3);
      p247[i].z.re = random_unt32 (q3);
      p247[i].z.im = random_unt32 (q3);
    }
  s1 = slaw_v3unt32c_array_raw (1087, &p248);
  s2 = slaw_v3unt32c_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt32c_array_filled (random_unt8 (q1), p245);
  s4 = slaw_v3unt32c_array (p247, 1087);
  TestAgainstPredicates (eSlawType_v3unt32c_array, s1);
  TestAgainstPredicates (eSlawType_v3unt32c_array, s2);
  TestAgainstPredicates (eSlawType_v3unt32c_array, s3);
  TestAgainstPredicates (eSlawType_v3unt32c_array, s4);
  n = sizeof (v3unt32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p246, i + slaw_v3unt32c_array_emit (s3), sizeof (v3unt32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p248, p247, sizeof (p247));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt32c_array_emit_nth (s3, i)
          != i + slaw_v3unt32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt32c_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt32c_array_empty (0);
  s6 = slaw_v3unt32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt32c_array_concat_carray (s3, p247, 1087);
  s8 = slaw_v3unt32c_array_concat_carray_f (s3, p247, 1087);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int64c p249;
  v3int64c p250;
  v3int64c p251[421];
  v3int64c *p252;
  p249.x.re = random_int64 (q1);
  p249.x.im = random_int64 (q1);
  p249.y.re = random_int64 (q1);
  p249.y.im = random_int64 (q1);
  p249.z.re = random_int64 (q1);
  p249.z.im = random_int64 (q1);
  p250.x.re = random_int64 (q2);
  p250.x.im = random_int64 (q2);
  p250.y.re = random_int64 (q2);
  p250.y.im = random_int64 (q2);
  p250.z.re = random_int64 (q2);
  p250.z.im = random_int64 (q2);
  s = slaw_v3int64c (p249);
  TestAgainstPredicates (eSlawType_v3int64c, s);
  if (memcmp (&p250, slaw_v3int64c_emit (s), sizeof (v3int64c)) != 0)
    error_exit ("compare failed for v3int64c\n");
  if (memcmp (&p250, slaw_v3int64c_emit_nocheck (s), sizeof (v3int64c)) != 0)
    error_exit ("compare failed for v3int64c\n");
  slaw_free (s);
  for (i = 0; i < 421; i++)
    {
      p251[i].x.re = random_int64 (q3);
      p251[i].x.im = random_int64 (q3);
      p251[i].y.re = random_int64 (q3);
      p251[i].y.im = random_int64 (q3);
      p251[i].z.re = random_int64 (q3);
      p251[i].z.im = random_int64 (q3);
    }
  s1 = slaw_v3int64c_array_raw (421, &p252);
  s2 = slaw_v3int64c_array_empty (random_unt8 (q1));
  s3 = slaw_v3int64c_array_filled (random_unt8 (q1), p249);
  s4 = slaw_v3int64c_array (p251, 421);
  TestAgainstPredicates (eSlawType_v3int64c_array, s1);
  TestAgainstPredicates (eSlawType_v3int64c_array, s2);
  TestAgainstPredicates (eSlawType_v3int64c_array, s3);
  TestAgainstPredicates (eSlawType_v3int64c_array, s4);
  n = sizeof (v3int64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p250, i + slaw_v3int64c_array_emit (s3), sizeof (v3int64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p252, p251, sizeof (p251));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int64c_array_emit_nth (s3, i)
          != i + slaw_v3int64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int64c_arrays_concat (s3, s4, NULL);
  s = slaw_v3int64c_array_empty (0);
  s6 = slaw_v3int64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int64c_array_concat_carray (s3, p251, 421);
  s8 = slaw_v3int64c_array_concat_carray_f (s3, p251, 421);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt64c p253;
  v3unt64c p254;
  v3unt64c p255[928];
  v3unt64c *p256;
  p253.x.re = random_unt64 (q1);
  p253.x.im = random_unt64 (q1);
  p253.y.re = random_unt64 (q1);
  p253.y.im = random_unt64 (q1);
  p253.z.re = random_unt64 (q1);
  p253.z.im = random_unt64 (q1);
  p254.x.re = random_unt64 (q2);
  p254.x.im = random_unt64 (q2);
  p254.y.re = random_unt64 (q2);
  p254.y.im = random_unt64 (q2);
  p254.z.re = random_unt64 (q2);
  p254.z.im = random_unt64 (q2);
  s = slaw_v3unt64c (p253);
  TestAgainstPredicates (eSlawType_v3unt64c, s);
  if (memcmp (&p254, slaw_v3unt64c_emit (s), sizeof (v3unt64c)) != 0)
    error_exit ("compare failed for v3unt64c\n");
  if (memcmp (&p254, slaw_v3unt64c_emit_nocheck (s), sizeof (v3unt64c)) != 0)
    error_exit ("compare failed for v3unt64c\n");
  slaw_free (s);
  for (i = 0; i < 928; i++)
    {
      p255[i].x.re = random_unt64 (q3);
      p255[i].x.im = random_unt64 (q3);
      p255[i].y.re = random_unt64 (q3);
      p255[i].y.im = random_unt64 (q3);
      p255[i].z.re = random_unt64 (q3);
      p255[i].z.im = random_unt64 (q3);
    }
  s1 = slaw_v3unt64c_array_raw (928, &p256);
  s2 = slaw_v3unt64c_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt64c_array_filled (random_unt8 (q1), p253);
  s4 = slaw_v3unt64c_array (p255, 928);
  TestAgainstPredicates (eSlawType_v3unt64c_array, s1);
  TestAgainstPredicates (eSlawType_v3unt64c_array, s2);
  TestAgainstPredicates (eSlawType_v3unt64c_array, s3);
  TestAgainstPredicates (eSlawType_v3unt64c_array, s4);
  n = sizeof (v3unt64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p254, i + slaw_v3unt64c_array_emit (s3), sizeof (v3unt64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p256, p255, sizeof (p255));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt64c_array_emit_nth (s3, i)
          != i + slaw_v3unt64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt64c_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt64c_array_empty (0);
  s6 = slaw_v3unt64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt64c_array_concat_carray (s3, p255, 928);
  s8 = slaw_v3unt64c_array_concat_carray_f (s3, p255, 928);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3float32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3float32c p257;
  v3float32c p258;
  v3float32c p259[784];
  v3float32c *p260;
  p257.x.re = random_float32 (q1);
  p257.x.im = random_float32 (q1);
  p257.y.re = random_float32 (q1);
  p257.y.im = random_float32 (q1);
  p257.z.re = random_float32 (q1);
  p257.z.im = random_float32 (q1);
  p258.x.re = random_float32 (q2);
  p258.x.im = random_float32 (q2);
  p258.y.re = random_float32 (q2);
  p258.y.im = random_float32 (q2);
  p258.z.re = random_float32 (q2);
  p258.z.im = random_float32 (q2);
  s = slaw_v3float32c (p257);
  TestAgainstPredicates (eSlawType_v3float32c, s);
  if (memcmp (&p258, slaw_v3float32c_emit (s), sizeof (v3float32c)) != 0)
    error_exit ("compare failed for v3float32c\n");
  if (memcmp (&p258, slaw_v3float32c_emit_nocheck (s), sizeof (v3float32c))
      != 0)
    error_exit ("compare failed for v3float32c\n");
  slaw_free (s);
  for (i = 0; i < 784; i++)
    {
      p259[i].x.re = random_float32 (q3);
      p259[i].x.im = random_float32 (q3);
      p259[i].y.re = random_float32 (q3);
      p259[i].y.im = random_float32 (q3);
      p259[i].z.re = random_float32 (q3);
      p259[i].z.im = random_float32 (q3);
    }
  s1 = slaw_v3float32c_array_raw (784, &p260);
  s2 = slaw_v3float32c_array_empty (random_unt8 (q1));
  s3 = slaw_v3float32c_array_filled (random_unt8 (q1), p257);
  s4 = slaw_v3float32c_array (p259, 784);
  TestAgainstPredicates (eSlawType_v3float32c_array, s1);
  TestAgainstPredicates (eSlawType_v3float32c_array, s2);
  TestAgainstPredicates (eSlawType_v3float32c_array, s3);
  TestAgainstPredicates (eSlawType_v3float32c_array, s4);
  n = sizeof (v3float32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3float32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p258, i + slaw_v3float32c_array_emit (s3),
                  sizeof (v3float32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p260, p259, sizeof (p259));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3float32c_array_emit_nth (s3, i)
          != i + slaw_v3float32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3float32c_arrays_concat (s3, s4, NULL);
  s = slaw_v3float32c_array_empty (0);
  s6 = slaw_v3float32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3float32c_array_concat_carray (s3, p259, 784);
  s8 = slaw_v3float32c_array_concat_carray_f (s3, p259, 784);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3float64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3float64c p261;
  v3float64c p262;
  v3float64c p263[800];
  v3float64c *p264;
  p261.x.re = random_float64 (q1);
  p261.x.im = random_float64 (q1);
  p261.y.re = random_float64 (q1);
  p261.y.im = random_float64 (q1);
  p261.z.re = random_float64 (q1);
  p261.z.im = random_float64 (q1);
  p262.x.re = random_float64 (q2);
  p262.x.im = random_float64 (q2);
  p262.y.re = random_float64 (q2);
  p262.y.im = random_float64 (q2);
  p262.z.re = random_float64 (q2);
  p262.z.im = random_float64 (q2);
  s = slaw_v3float64c (p261);
  TestAgainstPredicates (eSlawType_v3float64c, s);
  if (memcmp (&p262, slaw_v3float64c_emit (s), sizeof (v3float64c)) != 0)
    error_exit ("compare failed for v3float64c\n");
  if (memcmp (&p262, slaw_v3float64c_emit_nocheck (s), sizeof (v3float64c))
      != 0)
    error_exit ("compare failed for v3float64c\n");
  slaw_free (s);
  for (i = 0; i < 800; i++)
    {
      p263[i].x.re = random_float64 (q3);
      p263[i].x.im = random_float64 (q3);
      p263[i].y.re = random_float64 (q3);
      p263[i].y.im = random_float64 (q3);
      p263[i].z.re = random_float64 (q3);
      p263[i].z.im = random_float64 (q3);
    }
  s1 = slaw_v3float64c_array_raw (800, &p264);
  s2 = slaw_v3float64c_array_empty (random_unt8 (q1));
  s3 = slaw_v3float64c_array_filled (random_unt8 (q1), p261);
  s4 = slaw_v3float64c_array (p263, 800);
  TestAgainstPredicates (eSlawType_v3float64c_array, s1);
  TestAgainstPredicates (eSlawType_v3float64c_array, s2);
  TestAgainstPredicates (eSlawType_v3float64c_array, s3);
  TestAgainstPredicates (eSlawType_v3float64c_array, s4);
  n = sizeof (v3float64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3float64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p262, i + slaw_v3float64c_array_emit (s3),
                  sizeof (v3float64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p264, p263, sizeof (p263));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3float64c_array_emit_nth (s3, i)
          != i + slaw_v3float64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3float64c_arrays_concat (s3, s4, NULL);
  s = slaw_v3float64c_array_empty (0);
  s6 = slaw_v3float64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3float64c_array_concat_carray (s3, p263, 800);
  s8 = slaw_v3float64c_array_concat_carray_f (s3, p263, 800);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int8c p265;
  v3int8c p266;
  v3int8c p267[1895];
  v3int8c *p268;
  p265.x.re = random_int8 (q1);
  p265.x.im = random_int8 (q1);
  p265.y.re = random_int8 (q1);
  p265.y.im = random_int8 (q1);
  p265.z.re = random_int8 (q1);
  p265.z.im = random_int8 (q1);
  p266.x.re = random_int8 (q2);
  p266.x.im = random_int8 (q2);
  p266.y.re = random_int8 (q2);
  p266.y.im = random_int8 (q2);
  p266.z.re = random_int8 (q2);
  p266.z.im = random_int8 (q2);
  s = slaw_v3int8c (p265);
  TestAgainstPredicates (eSlawType_v3int8c, s);
  if (memcmp (&p266, slaw_v3int8c_emit (s), sizeof (v3int8c)) != 0)
    error_exit ("compare failed for v3int8c\n");
  if (memcmp (&p266, slaw_v3int8c_emit_nocheck (s), sizeof (v3int8c)) != 0)
    error_exit ("compare failed for v3int8c\n");
  slaw_free (s);
  for (i = 0; i < 1895; i++)
    {
      p267[i].x.re = random_int8 (q3);
      p267[i].x.im = random_int8 (q3);
      p267[i].y.re = random_int8 (q3);
      p267[i].y.im = random_int8 (q3);
      p267[i].z.re = random_int8 (q3);
      p267[i].z.im = random_int8 (q3);
    }
  s1 = slaw_v3int8c_array_raw (1895, &p268);
  s2 = slaw_v3int8c_array_empty (random_unt8 (q1));
  s3 = slaw_v3int8c_array_filled (random_unt8 (q1), p265);
  s4 = slaw_v3int8c_array (p267, 1895);
  TestAgainstPredicates (eSlawType_v3int8c_array, s1);
  TestAgainstPredicates (eSlawType_v3int8c_array, s2);
  TestAgainstPredicates (eSlawType_v3int8c_array, s3);
  TestAgainstPredicates (eSlawType_v3int8c_array, s4);
  n = sizeof (v3int8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p266, i + slaw_v3int8c_array_emit (s3), sizeof (v3int8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p268, p267, sizeof (p267));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int8c_array_emit_nth (s3, i)
          != i + slaw_v3int8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int8c_arrays_concat (s3, s4, NULL);
  s = slaw_v3int8c_array_empty (0);
  s6 = slaw_v3int8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int8c_array_concat_carray (s3, p267, 1895);
  s8 = slaw_v3int8c_array_concat_carray_f (s3, p267, 1895);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt8c p269;
  v3unt8c p270;
  v3unt8c p271[917];
  v3unt8c *p272;
  p269.x.re = random_unt8 (q1);
  p269.x.im = random_unt8 (q1);
  p269.y.re = random_unt8 (q1);
  p269.y.im = random_unt8 (q1);
  p269.z.re = random_unt8 (q1);
  p269.z.im = random_unt8 (q1);
  p270.x.re = random_unt8 (q2);
  p270.x.im = random_unt8 (q2);
  p270.y.re = random_unt8 (q2);
  p270.y.im = random_unt8 (q2);
  p270.z.re = random_unt8 (q2);
  p270.z.im = random_unt8 (q2);
  s = slaw_v3unt8c (p269);
  TestAgainstPredicates (eSlawType_v3unt8c, s);
  if (memcmp (&p270, slaw_v3unt8c_emit (s), sizeof (v3unt8c)) != 0)
    error_exit ("compare failed for v3unt8c\n");
  if (memcmp (&p270, slaw_v3unt8c_emit_nocheck (s), sizeof (v3unt8c)) != 0)
    error_exit ("compare failed for v3unt8c\n");
  slaw_free (s);
  for (i = 0; i < 917; i++)
    {
      p271[i].x.re = random_unt8 (q3);
      p271[i].x.im = random_unt8 (q3);
      p271[i].y.re = random_unt8 (q3);
      p271[i].y.im = random_unt8 (q3);
      p271[i].z.re = random_unt8 (q3);
      p271[i].z.im = random_unt8 (q3);
    }
  s1 = slaw_v3unt8c_array_raw (917, &p272);
  s2 = slaw_v3unt8c_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt8c_array_filled (random_unt8 (q1), p269);
  s4 = slaw_v3unt8c_array (p271, 917);
  TestAgainstPredicates (eSlawType_v3unt8c_array, s1);
  TestAgainstPredicates (eSlawType_v3unt8c_array, s2);
  TestAgainstPredicates (eSlawType_v3unt8c_array, s3);
  TestAgainstPredicates (eSlawType_v3unt8c_array, s4);
  n = sizeof (v3unt8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p270, i + slaw_v3unt8c_array_emit (s3), sizeof (v3unt8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p272, p271, sizeof (p271));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt8c_array_emit_nth (s3, i)
          != i + slaw_v3unt8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt8c_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt8c_array_empty (0);
  s6 = slaw_v3unt8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt8c_array_concat_carray (s3, p271, 917);
  s8 = slaw_v3unt8c_array_concat_carray_f (s3, p271, 917);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3int16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3int16c p273;
  v3int16c p274;
  v3int16c p275[1546];
  v3int16c *p276;
  p273.x.re = random_int16 (q1);
  p273.x.im = random_int16 (q1);
  p273.y.re = random_int16 (q1);
  p273.y.im = random_int16 (q1);
  p273.z.re = random_int16 (q1);
  p273.z.im = random_int16 (q1);
  p274.x.re = random_int16 (q2);
  p274.x.im = random_int16 (q2);
  p274.y.re = random_int16 (q2);
  p274.y.im = random_int16 (q2);
  p274.z.re = random_int16 (q2);
  p274.z.im = random_int16 (q2);
  s = slaw_v3int16c (p273);
  TestAgainstPredicates (eSlawType_v3int16c, s);
  if (memcmp (&p274, slaw_v3int16c_emit (s), sizeof (v3int16c)) != 0)
    error_exit ("compare failed for v3int16c\n");
  if (memcmp (&p274, slaw_v3int16c_emit_nocheck (s), sizeof (v3int16c)) != 0)
    error_exit ("compare failed for v3int16c\n");
  slaw_free (s);
  for (i = 0; i < 1546; i++)
    {
      p275[i].x.re = random_int16 (q3);
      p275[i].x.im = random_int16 (q3);
      p275[i].y.re = random_int16 (q3);
      p275[i].y.im = random_int16 (q3);
      p275[i].z.re = random_int16 (q3);
      p275[i].z.im = random_int16 (q3);
    }
  s1 = slaw_v3int16c_array_raw (1546, &p276);
  s2 = slaw_v3int16c_array_empty (random_unt8 (q1));
  s3 = slaw_v3int16c_array_filled (random_unt8 (q1), p273);
  s4 = slaw_v3int16c_array (p275, 1546);
  TestAgainstPredicates (eSlawType_v3int16c_array, s1);
  TestAgainstPredicates (eSlawType_v3int16c_array, s2);
  TestAgainstPredicates (eSlawType_v3int16c_array, s3);
  TestAgainstPredicates (eSlawType_v3int16c_array, s4);
  n = sizeof (v3int16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3int16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p274, i + slaw_v3int16c_array_emit (s3), sizeof (v3int16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p276, p275, sizeof (p275));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3int16c_array_emit_nth (s3, i)
          != i + slaw_v3int16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3int16c_arrays_concat (s3, s4, NULL);
  s = slaw_v3int16c_array_empty (0);
  s6 = slaw_v3int16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3int16c_array_concat_carray (s3, p275, 1546);
  s8 = slaw_v3int16c_array_concat_carray_f (s3, p275, 1546);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v3unt16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v3unt16c p277;
  v3unt16c p278;
  v3unt16c p279[1810];
  v3unt16c *p280;
  p277.x.re = random_unt16 (q1);
  p277.x.im = random_unt16 (q1);
  p277.y.re = random_unt16 (q1);
  p277.y.im = random_unt16 (q1);
  p277.z.re = random_unt16 (q1);
  p277.z.im = random_unt16 (q1);
  p278.x.re = random_unt16 (q2);
  p278.x.im = random_unt16 (q2);
  p278.y.re = random_unt16 (q2);
  p278.y.im = random_unt16 (q2);
  p278.z.re = random_unt16 (q2);
  p278.z.im = random_unt16 (q2);
  s = slaw_v3unt16c (p277);
  TestAgainstPredicates (eSlawType_v3unt16c, s);
  if (memcmp (&p278, slaw_v3unt16c_emit (s), sizeof (v3unt16c)) != 0)
    error_exit ("compare failed for v3unt16c\n");
  if (memcmp (&p278, slaw_v3unt16c_emit_nocheck (s), sizeof (v3unt16c)) != 0)
    error_exit ("compare failed for v3unt16c\n");
  slaw_free (s);
  for (i = 0; i < 1810; i++)
    {
      p279[i].x.re = random_unt16 (q3);
      p279[i].x.im = random_unt16 (q3);
      p279[i].y.re = random_unt16 (q3);
      p279[i].y.im = random_unt16 (q3);
      p279[i].z.re = random_unt16 (q3);
      p279[i].z.im = random_unt16 (q3);
    }
  s1 = slaw_v3unt16c_array_raw (1810, &p280);
  s2 = slaw_v3unt16c_array_empty (random_unt8 (q1));
  s3 = slaw_v3unt16c_array_filled (random_unt8 (q1), p277);
  s4 = slaw_v3unt16c_array (p279, 1810);
  TestAgainstPredicates (eSlawType_v3unt16c_array, s1);
  TestAgainstPredicates (eSlawType_v3unt16c_array, s2);
  TestAgainstPredicates (eSlawType_v3unt16c_array, s3);
  TestAgainstPredicates (eSlawType_v3unt16c_array, s4);
  n = sizeof (v3unt16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v3unt16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p278, i + slaw_v3unt16c_array_emit (s3), sizeof (v3unt16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p280, p279, sizeof (p279));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v3unt16c_array_emit_nth (s3, i)
          != i + slaw_v3unt16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v3unt16c_arrays_concat (s3, s4, NULL);
  s = slaw_v3unt16c_array_empty (0);
  s6 = slaw_v3unt16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v3unt16c_array_concat_carray (s3, p279, 1810);
  s8 = slaw_v3unt16c_array_concat_carray_f (s3, p279, 1810);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int32c p281;
  v4int32c p282;
  v4int32c p283[634];
  v4int32c *p284;
  p281.x.re = random_int32 (q1);
  p281.x.im = random_int32 (q1);
  p281.y.re = random_int32 (q1);
  p281.y.im = random_int32 (q1);
  p281.z.re = random_int32 (q1);
  p281.z.im = random_int32 (q1);
  p281.w.re = random_int32 (q1);
  p281.w.im = random_int32 (q1);
  p282.x.re = random_int32 (q2);
  p282.x.im = random_int32 (q2);
  p282.y.re = random_int32 (q2);
  p282.y.im = random_int32 (q2);
  p282.z.re = random_int32 (q2);
  p282.z.im = random_int32 (q2);
  p282.w.re = random_int32 (q2);
  p282.w.im = random_int32 (q2);
  s = slaw_v4int32c (p281);
  TestAgainstPredicates (eSlawType_v4int32c, s);
  if (memcmp (&p282, slaw_v4int32c_emit (s), sizeof (v4int32c)) != 0)
    error_exit ("compare failed for v4int32c\n");
  if (memcmp (&p282, slaw_v4int32c_emit_nocheck (s), sizeof (v4int32c)) != 0)
    error_exit ("compare failed for v4int32c\n");
  slaw_free (s);
  for (i = 0; i < 634; i++)
    {
      p283[i].x.re = random_int32 (q3);
      p283[i].x.im = random_int32 (q3);
      p283[i].y.re = random_int32 (q3);
      p283[i].y.im = random_int32 (q3);
      p283[i].z.re = random_int32 (q3);
      p283[i].z.im = random_int32 (q3);
      p283[i].w.re = random_int32 (q3);
      p283[i].w.im = random_int32 (q3);
    }
  s1 = slaw_v4int32c_array_raw (634, &p284);
  s2 = slaw_v4int32c_array_empty (random_unt8 (q1));
  s3 = slaw_v4int32c_array_filled (random_unt8 (q1), p281);
  s4 = slaw_v4int32c_array (p283, 634);
  TestAgainstPredicates (eSlawType_v4int32c_array, s1);
  TestAgainstPredicates (eSlawType_v4int32c_array, s2);
  TestAgainstPredicates (eSlawType_v4int32c_array, s3);
  TestAgainstPredicates (eSlawType_v4int32c_array, s4);
  n = sizeof (v4int32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p282, i + slaw_v4int32c_array_emit (s3), sizeof (v4int32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p284, p283, sizeof (p283));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int32c_array_emit_nth (s3, i)
          != i + slaw_v4int32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int32c_arrays_concat (s3, s4, NULL);
  s = slaw_v4int32c_array_empty (0);
  s6 = slaw_v4int32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int32c_array_concat_carray (s3, p283, 634);
  s8 = slaw_v4int32c_array_concat_carray_f (s3, p283, 634);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt32c p285;
  v4unt32c p286;
  v4unt32c p287[1362];
  v4unt32c *p288;
  p285.x.re = random_unt32 (q1);
  p285.x.im = random_unt32 (q1);
  p285.y.re = random_unt32 (q1);
  p285.y.im = random_unt32 (q1);
  p285.z.re = random_unt32 (q1);
  p285.z.im = random_unt32 (q1);
  p285.w.re = random_unt32 (q1);
  p285.w.im = random_unt32 (q1);
  p286.x.re = random_unt32 (q2);
  p286.x.im = random_unt32 (q2);
  p286.y.re = random_unt32 (q2);
  p286.y.im = random_unt32 (q2);
  p286.z.re = random_unt32 (q2);
  p286.z.im = random_unt32 (q2);
  p286.w.re = random_unt32 (q2);
  p286.w.im = random_unt32 (q2);
  s = slaw_v4unt32c (p285);
  TestAgainstPredicates (eSlawType_v4unt32c, s);
  if (memcmp (&p286, slaw_v4unt32c_emit (s), sizeof (v4unt32c)) != 0)
    error_exit ("compare failed for v4unt32c\n");
  if (memcmp (&p286, slaw_v4unt32c_emit_nocheck (s), sizeof (v4unt32c)) != 0)
    error_exit ("compare failed for v4unt32c\n");
  slaw_free (s);
  for (i = 0; i < 1362; i++)
    {
      p287[i].x.re = random_unt32 (q3);
      p287[i].x.im = random_unt32 (q3);
      p287[i].y.re = random_unt32 (q3);
      p287[i].y.im = random_unt32 (q3);
      p287[i].z.re = random_unt32 (q3);
      p287[i].z.im = random_unt32 (q3);
      p287[i].w.re = random_unt32 (q3);
      p287[i].w.im = random_unt32 (q3);
    }
  s1 = slaw_v4unt32c_array_raw (1362, &p288);
  s2 = slaw_v4unt32c_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt32c_array_filled (random_unt8 (q1), p285);
  s4 = slaw_v4unt32c_array (p287, 1362);
  TestAgainstPredicates (eSlawType_v4unt32c_array, s1);
  TestAgainstPredicates (eSlawType_v4unt32c_array, s2);
  TestAgainstPredicates (eSlawType_v4unt32c_array, s3);
  TestAgainstPredicates (eSlawType_v4unt32c_array, s4);
  n = sizeof (v4unt32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p286, i + slaw_v4unt32c_array_emit (s3), sizeof (v4unt32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p288, p287, sizeof (p287));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt32c_array_emit_nth (s3, i)
          != i + slaw_v4unt32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt32c_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt32c_array_empty (0);
  s6 = slaw_v4unt32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt32c_array_concat_carray (s3, p287, 1362);
  s8 = slaw_v4unt32c_array_concat_carray_f (s3, p287, 1362);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int64c p289;
  v4int64c p290;
  v4int64c p291[1767];
  v4int64c *p292;
  p289.x.re = random_int64 (q1);
  p289.x.im = random_int64 (q1);
  p289.y.re = random_int64 (q1);
  p289.y.im = random_int64 (q1);
  p289.z.re = random_int64 (q1);
  p289.z.im = random_int64 (q1);
  p289.w.re = random_int64 (q1);
  p289.w.im = random_int64 (q1);
  p290.x.re = random_int64 (q2);
  p290.x.im = random_int64 (q2);
  p290.y.re = random_int64 (q2);
  p290.y.im = random_int64 (q2);
  p290.z.re = random_int64 (q2);
  p290.z.im = random_int64 (q2);
  p290.w.re = random_int64 (q2);
  p290.w.im = random_int64 (q2);
  s = slaw_v4int64c (p289);
  TestAgainstPredicates (eSlawType_v4int64c, s);
  if (memcmp (&p290, slaw_v4int64c_emit (s), sizeof (v4int64c)) != 0)
    error_exit ("compare failed for v4int64c\n");
  if (memcmp (&p290, slaw_v4int64c_emit_nocheck (s), sizeof (v4int64c)) != 0)
    error_exit ("compare failed for v4int64c\n");
  slaw_free (s);
  for (i = 0; i < 1767; i++)
    {
      p291[i].x.re = random_int64 (q3);
      p291[i].x.im = random_int64 (q3);
      p291[i].y.re = random_int64 (q3);
      p291[i].y.im = random_int64 (q3);
      p291[i].z.re = random_int64 (q3);
      p291[i].z.im = random_int64 (q3);
      p291[i].w.re = random_int64 (q3);
      p291[i].w.im = random_int64 (q3);
    }
  s1 = slaw_v4int64c_array_raw (1767, &p292);
  s2 = slaw_v4int64c_array_empty (random_unt8 (q1));
  s3 = slaw_v4int64c_array_filled (random_unt8 (q1), p289);
  s4 = slaw_v4int64c_array (p291, 1767);
  TestAgainstPredicates (eSlawType_v4int64c_array, s1);
  TestAgainstPredicates (eSlawType_v4int64c_array, s2);
  TestAgainstPredicates (eSlawType_v4int64c_array, s3);
  TestAgainstPredicates (eSlawType_v4int64c_array, s4);
  n = sizeof (v4int64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p290, i + slaw_v4int64c_array_emit (s3), sizeof (v4int64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p292, p291, sizeof (p291));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int64c_array_emit_nth (s3, i)
          != i + slaw_v4int64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int64c_arrays_concat (s3, s4, NULL);
  s = slaw_v4int64c_array_empty (0);
  s6 = slaw_v4int64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int64c_array_concat_carray (s3, p291, 1767);
  s8 = slaw_v4int64c_array_concat_carray_f (s3, p291, 1767);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt64c p293;
  v4unt64c p294;
  v4unt64c p295[1303];
  v4unt64c *p296;
  p293.x.re = random_unt64 (q1);
  p293.x.im = random_unt64 (q1);
  p293.y.re = random_unt64 (q1);
  p293.y.im = random_unt64 (q1);
  p293.z.re = random_unt64 (q1);
  p293.z.im = random_unt64 (q1);
  p293.w.re = random_unt64 (q1);
  p293.w.im = random_unt64 (q1);
  p294.x.re = random_unt64 (q2);
  p294.x.im = random_unt64 (q2);
  p294.y.re = random_unt64 (q2);
  p294.y.im = random_unt64 (q2);
  p294.z.re = random_unt64 (q2);
  p294.z.im = random_unt64 (q2);
  p294.w.re = random_unt64 (q2);
  p294.w.im = random_unt64 (q2);
  s = slaw_v4unt64c (p293);
  TestAgainstPredicates (eSlawType_v4unt64c, s);
  if (memcmp (&p294, slaw_v4unt64c_emit (s), sizeof (v4unt64c)) != 0)
    error_exit ("compare failed for v4unt64c\n");
  if (memcmp (&p294, slaw_v4unt64c_emit_nocheck (s), sizeof (v4unt64c)) != 0)
    error_exit ("compare failed for v4unt64c\n");
  slaw_free (s);
  for (i = 0; i < 1303; i++)
    {
      p295[i].x.re = random_unt64 (q3);
      p295[i].x.im = random_unt64 (q3);
      p295[i].y.re = random_unt64 (q3);
      p295[i].y.im = random_unt64 (q3);
      p295[i].z.re = random_unt64 (q3);
      p295[i].z.im = random_unt64 (q3);
      p295[i].w.re = random_unt64 (q3);
      p295[i].w.im = random_unt64 (q3);
    }
  s1 = slaw_v4unt64c_array_raw (1303, &p296);
  s2 = slaw_v4unt64c_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt64c_array_filled (random_unt8 (q1), p293);
  s4 = slaw_v4unt64c_array (p295, 1303);
  TestAgainstPredicates (eSlawType_v4unt64c_array, s1);
  TestAgainstPredicates (eSlawType_v4unt64c_array, s2);
  TestAgainstPredicates (eSlawType_v4unt64c_array, s3);
  TestAgainstPredicates (eSlawType_v4unt64c_array, s4);
  n = sizeof (v4unt64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p294, i + slaw_v4unt64c_array_emit (s3), sizeof (v4unt64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p296, p295, sizeof (p295));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt64c_array_emit_nth (s3, i)
          != i + slaw_v4unt64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt64c_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt64c_array_empty (0);
  s6 = slaw_v4unt64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt64c_array_concat_carray (s3, p295, 1303);
  s8 = slaw_v4unt64c_array_concat_carray_f (s3, p295, 1303);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4float32c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4float32c p297;
  v4float32c p298;
  v4float32c p299[711];
  v4float32c *p300;
  p297.x.re = random_float32 (q1);
  p297.x.im = random_float32 (q1);
  p297.y.re = random_float32 (q1);
  p297.y.im = random_float32 (q1);
  p297.z.re = random_float32 (q1);
  p297.z.im = random_float32 (q1);
  p297.w.re = random_float32 (q1);
  p297.w.im = random_float32 (q1);
  p298.x.re = random_float32 (q2);
  p298.x.im = random_float32 (q2);
  p298.y.re = random_float32 (q2);
  p298.y.im = random_float32 (q2);
  p298.z.re = random_float32 (q2);
  p298.z.im = random_float32 (q2);
  p298.w.re = random_float32 (q2);
  p298.w.im = random_float32 (q2);
  s = slaw_v4float32c (p297);
  TestAgainstPredicates (eSlawType_v4float32c, s);
  if (memcmp (&p298, slaw_v4float32c_emit (s), sizeof (v4float32c)) != 0)
    error_exit ("compare failed for v4float32c\n");
  if (memcmp (&p298, slaw_v4float32c_emit_nocheck (s), sizeof (v4float32c))
      != 0)
    error_exit ("compare failed for v4float32c\n");
  slaw_free (s);
  for (i = 0; i < 711; i++)
    {
      p299[i].x.re = random_float32 (q3);
      p299[i].x.im = random_float32 (q3);
      p299[i].y.re = random_float32 (q3);
      p299[i].y.im = random_float32 (q3);
      p299[i].z.re = random_float32 (q3);
      p299[i].z.im = random_float32 (q3);
      p299[i].w.re = random_float32 (q3);
      p299[i].w.im = random_float32 (q3);
    }
  s1 = slaw_v4float32c_array_raw (711, &p300);
  s2 = slaw_v4float32c_array_empty (random_unt8 (q1));
  s3 = slaw_v4float32c_array_filled (random_unt8 (q1), p297);
  s4 = slaw_v4float32c_array (p299, 711);
  TestAgainstPredicates (eSlawType_v4float32c_array, s1);
  TestAgainstPredicates (eSlawType_v4float32c_array, s2);
  TestAgainstPredicates (eSlawType_v4float32c_array, s3);
  TestAgainstPredicates (eSlawType_v4float32c_array, s4);
  n = sizeof (v4float32c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4float32c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p298, i + slaw_v4float32c_array_emit (s3),
                  sizeof (v4float32c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p300, p299, sizeof (p299));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4float32c_array_emit_nth (s3, i)
          != i + slaw_v4float32c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4float32c_arrays_concat (s3, s4, NULL);
  s = slaw_v4float32c_array_empty (0);
  s6 = slaw_v4float32c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4float32c_array_concat_carray (s3, p299, 711);
  s8 = slaw_v4float32c_array_concat_carray_f (s3, p299, 711);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4float64c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4float64c p301;
  v4float64c p302;
  v4float64c p303[150];
  v4float64c *p304;
  p301.x.re = random_float64 (q1);
  p301.x.im = random_float64 (q1);
  p301.y.re = random_float64 (q1);
  p301.y.im = random_float64 (q1);
  p301.z.re = random_float64 (q1);
  p301.z.im = random_float64 (q1);
  p301.w.re = random_float64 (q1);
  p301.w.im = random_float64 (q1);
  p302.x.re = random_float64 (q2);
  p302.x.im = random_float64 (q2);
  p302.y.re = random_float64 (q2);
  p302.y.im = random_float64 (q2);
  p302.z.re = random_float64 (q2);
  p302.z.im = random_float64 (q2);
  p302.w.re = random_float64 (q2);
  p302.w.im = random_float64 (q2);
  s = slaw_v4float64c (p301);
  TestAgainstPredicates (eSlawType_v4float64c, s);
  if (memcmp (&p302, slaw_v4float64c_emit (s), sizeof (v4float64c)) != 0)
    error_exit ("compare failed for v4float64c\n");
  if (memcmp (&p302, slaw_v4float64c_emit_nocheck (s), sizeof (v4float64c))
      != 0)
    error_exit ("compare failed for v4float64c\n");
  slaw_free (s);
  for (i = 0; i < 150; i++)
    {
      p303[i].x.re = random_float64 (q3);
      p303[i].x.im = random_float64 (q3);
      p303[i].y.re = random_float64 (q3);
      p303[i].y.im = random_float64 (q3);
      p303[i].z.re = random_float64 (q3);
      p303[i].z.im = random_float64 (q3);
      p303[i].w.re = random_float64 (q3);
      p303[i].w.im = random_float64 (q3);
    }
  s1 = slaw_v4float64c_array_raw (150, &p304);
  s2 = slaw_v4float64c_array_empty (random_unt8 (q1));
  s3 = slaw_v4float64c_array_filled (random_unt8 (q1), p301);
  s4 = slaw_v4float64c_array (p303, 150);
  TestAgainstPredicates (eSlawType_v4float64c_array, s1);
  TestAgainstPredicates (eSlawType_v4float64c_array, s2);
  TestAgainstPredicates (eSlawType_v4float64c_array, s3);
  TestAgainstPredicates (eSlawType_v4float64c_array, s4);
  n = sizeof (v4float64c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4float64c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p302, i + slaw_v4float64c_array_emit (s3),
                  sizeof (v4float64c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p304, p303, sizeof (p303));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4float64c_array_emit_nth (s3, i)
          != i + slaw_v4float64c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4float64c_arrays_concat (s3, s4, NULL);
  s = slaw_v4float64c_array_empty (0);
  s6 = slaw_v4float64c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4float64c_array_concat_carray (s3, p303, 150);
  s8 = slaw_v4float64c_array_concat_carray_f (s3, p303, 150);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int8c p305;
  v4int8c p306;
  v4int8c p307[220];
  v4int8c *p308;
  p305.x.re = random_int8 (q1);
  p305.x.im = random_int8 (q1);
  p305.y.re = random_int8 (q1);
  p305.y.im = random_int8 (q1);
  p305.z.re = random_int8 (q1);
  p305.z.im = random_int8 (q1);
  p305.w.re = random_int8 (q1);
  p305.w.im = random_int8 (q1);
  p306.x.re = random_int8 (q2);
  p306.x.im = random_int8 (q2);
  p306.y.re = random_int8 (q2);
  p306.y.im = random_int8 (q2);
  p306.z.re = random_int8 (q2);
  p306.z.im = random_int8 (q2);
  p306.w.re = random_int8 (q2);
  p306.w.im = random_int8 (q2);
  s = slaw_v4int8c (p305);
  TestAgainstPredicates (eSlawType_v4int8c, s);
  if (memcmp (&p306, slaw_v4int8c_emit (s), sizeof (v4int8c)) != 0)
    error_exit ("compare failed for v4int8c\n");
  if (memcmp (&p306, slaw_v4int8c_emit_nocheck (s), sizeof (v4int8c)) != 0)
    error_exit ("compare failed for v4int8c\n");
  slaw_free (s);
  for (i = 0; i < 220; i++)
    {
      p307[i].x.re = random_int8 (q3);
      p307[i].x.im = random_int8 (q3);
      p307[i].y.re = random_int8 (q3);
      p307[i].y.im = random_int8 (q3);
      p307[i].z.re = random_int8 (q3);
      p307[i].z.im = random_int8 (q3);
      p307[i].w.re = random_int8 (q3);
      p307[i].w.im = random_int8 (q3);
    }
  s1 = slaw_v4int8c_array_raw (220, &p308);
  s2 = slaw_v4int8c_array_empty (random_unt8 (q1));
  s3 = slaw_v4int8c_array_filled (random_unt8 (q1), p305);
  s4 = slaw_v4int8c_array (p307, 220);
  TestAgainstPredicates (eSlawType_v4int8c_array, s1);
  TestAgainstPredicates (eSlawType_v4int8c_array, s2);
  TestAgainstPredicates (eSlawType_v4int8c_array, s3);
  TestAgainstPredicates (eSlawType_v4int8c_array, s4);
  n = sizeof (v4int8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p306, i + slaw_v4int8c_array_emit (s3), sizeof (v4int8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p308, p307, sizeof (p307));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int8c_array_emit_nth (s3, i)
          != i + slaw_v4int8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int8c_arrays_concat (s3, s4, NULL);
  s = slaw_v4int8c_array_empty (0);
  s6 = slaw_v4int8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int8c_array_concat_carray (s3, p307, 220);
  s8 = slaw_v4int8c_array_concat_carray_f (s3, p307, 220);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt8c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt8c p309;
  v4unt8c p310;
  v4unt8c p311[1030];
  v4unt8c *p312;
  p309.x.re = random_unt8 (q1);
  p309.x.im = random_unt8 (q1);
  p309.y.re = random_unt8 (q1);
  p309.y.im = random_unt8 (q1);
  p309.z.re = random_unt8 (q1);
  p309.z.im = random_unt8 (q1);
  p309.w.re = random_unt8 (q1);
  p309.w.im = random_unt8 (q1);
  p310.x.re = random_unt8 (q2);
  p310.x.im = random_unt8 (q2);
  p310.y.re = random_unt8 (q2);
  p310.y.im = random_unt8 (q2);
  p310.z.re = random_unt8 (q2);
  p310.z.im = random_unt8 (q2);
  p310.w.re = random_unt8 (q2);
  p310.w.im = random_unt8 (q2);
  s = slaw_v4unt8c (p309);
  TestAgainstPredicates (eSlawType_v4unt8c, s);
  if (memcmp (&p310, slaw_v4unt8c_emit (s), sizeof (v4unt8c)) != 0)
    error_exit ("compare failed for v4unt8c\n");
  if (memcmp (&p310, slaw_v4unt8c_emit_nocheck (s), sizeof (v4unt8c)) != 0)
    error_exit ("compare failed for v4unt8c\n");
  slaw_free (s);
  for (i = 0; i < 1030; i++)
    {
      p311[i].x.re = random_unt8 (q3);
      p311[i].x.im = random_unt8 (q3);
      p311[i].y.re = random_unt8 (q3);
      p311[i].y.im = random_unt8 (q3);
      p311[i].z.re = random_unt8 (q3);
      p311[i].z.im = random_unt8 (q3);
      p311[i].w.re = random_unt8 (q3);
      p311[i].w.im = random_unt8 (q3);
    }
  s1 = slaw_v4unt8c_array_raw (1030, &p312);
  s2 = slaw_v4unt8c_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt8c_array_filled (random_unt8 (q1), p309);
  s4 = slaw_v4unt8c_array (p311, 1030);
  TestAgainstPredicates (eSlawType_v4unt8c_array, s1);
  TestAgainstPredicates (eSlawType_v4unt8c_array, s2);
  TestAgainstPredicates (eSlawType_v4unt8c_array, s3);
  TestAgainstPredicates (eSlawType_v4unt8c_array, s4);
  n = sizeof (v4unt8c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt8c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p310, i + slaw_v4unt8c_array_emit (s3), sizeof (v4unt8c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p312, p311, sizeof (p311));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt8c_array_emit_nth (s3, i)
          != i + slaw_v4unt8c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt8c_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt8c_array_empty (0);
  s6 = slaw_v4unt8c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt8c_array_concat_carray (s3, p311, 1030);
  s8 = slaw_v4unt8c_array_concat_carray_f (s3, p311, 1030);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4int16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4int16c p313;
  v4int16c p314;
  v4int16c p315[551];
  v4int16c *p316;
  p313.x.re = random_int16 (q1);
  p313.x.im = random_int16 (q1);
  p313.y.re = random_int16 (q1);
  p313.y.im = random_int16 (q1);
  p313.z.re = random_int16 (q1);
  p313.z.im = random_int16 (q1);
  p313.w.re = random_int16 (q1);
  p313.w.im = random_int16 (q1);
  p314.x.re = random_int16 (q2);
  p314.x.im = random_int16 (q2);
  p314.y.re = random_int16 (q2);
  p314.y.im = random_int16 (q2);
  p314.z.re = random_int16 (q2);
  p314.z.im = random_int16 (q2);
  p314.w.re = random_int16 (q2);
  p314.w.im = random_int16 (q2);
  s = slaw_v4int16c (p313);
  TestAgainstPredicates (eSlawType_v4int16c, s);
  if (memcmp (&p314, slaw_v4int16c_emit (s), sizeof (v4int16c)) != 0)
    error_exit ("compare failed for v4int16c\n");
  if (memcmp (&p314, slaw_v4int16c_emit_nocheck (s), sizeof (v4int16c)) != 0)
    error_exit ("compare failed for v4int16c\n");
  slaw_free (s);
  for (i = 0; i < 551; i++)
    {
      p315[i].x.re = random_int16 (q3);
      p315[i].x.im = random_int16 (q3);
      p315[i].y.re = random_int16 (q3);
      p315[i].y.im = random_int16 (q3);
      p315[i].z.re = random_int16 (q3);
      p315[i].z.im = random_int16 (q3);
      p315[i].w.re = random_int16 (q3);
      p315[i].w.im = random_int16 (q3);
    }
  s1 = slaw_v4int16c_array_raw (551, &p316);
  s2 = slaw_v4int16c_array_empty (random_unt8 (q1));
  s3 = slaw_v4int16c_array_filled (random_unt8 (q1), p313);
  s4 = slaw_v4int16c_array (p315, 551);
  TestAgainstPredicates (eSlawType_v4int16c_array, s1);
  TestAgainstPredicates (eSlawType_v4int16c_array, s2);
  TestAgainstPredicates (eSlawType_v4int16c_array, s3);
  TestAgainstPredicates (eSlawType_v4int16c_array, s4);
  n = sizeof (v4int16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4int16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p314, i + slaw_v4int16c_array_emit (s3), sizeof (v4int16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p316, p315, sizeof (p315));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4int16c_array_emit_nth (s3, i)
          != i + slaw_v4int16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4int16c_arrays_concat (s3, s4, NULL);
  s = slaw_v4int16c_array_empty (0);
  s6 = slaw_v4int16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4int16c_array_concat_carray (s3, p315, 551);
  s8 = slaw_v4int16c_array_concat_carray_f (s3, p315, 551);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_v4unt16c (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  v4unt16c p317;
  v4unt16c p318;
  v4unt16c p319[1133];
  v4unt16c *p320;
  p317.x.re = random_unt16 (q1);
  p317.x.im = random_unt16 (q1);
  p317.y.re = random_unt16 (q1);
  p317.y.im = random_unt16 (q1);
  p317.z.re = random_unt16 (q1);
  p317.z.im = random_unt16 (q1);
  p317.w.re = random_unt16 (q1);
  p317.w.im = random_unt16 (q1);
  p318.x.re = random_unt16 (q2);
  p318.x.im = random_unt16 (q2);
  p318.y.re = random_unt16 (q2);
  p318.y.im = random_unt16 (q2);
  p318.z.re = random_unt16 (q2);
  p318.z.im = random_unt16 (q2);
  p318.w.re = random_unt16 (q2);
  p318.w.im = random_unt16 (q2);
  s = slaw_v4unt16c (p317);
  TestAgainstPredicates (eSlawType_v4unt16c, s);
  if (memcmp (&p318, slaw_v4unt16c_emit (s), sizeof (v4unt16c)) != 0)
    error_exit ("compare failed for v4unt16c\n");
  if (memcmp (&p318, slaw_v4unt16c_emit_nocheck (s), sizeof (v4unt16c)) != 0)
    error_exit ("compare failed for v4unt16c\n");
  slaw_free (s);
  for (i = 0; i < 1133; i++)
    {
      p319[i].x.re = random_unt16 (q3);
      p319[i].x.im = random_unt16 (q3);
      p319[i].y.re = random_unt16 (q3);
      p319[i].y.im = random_unt16 (q3);
      p319[i].z.re = random_unt16 (q3);
      p319[i].z.im = random_unt16 (q3);
      p319[i].w.re = random_unt16 (q3);
      p319[i].w.im = random_unt16 (q3);
    }
  s1 = slaw_v4unt16c_array_raw (1133, &p320);
  s2 = slaw_v4unt16c_array_empty (random_unt8 (q1));
  s3 = slaw_v4unt16c_array_filled (random_unt8 (q1), p317);
  s4 = slaw_v4unt16c_array (p319, 1133);
  TestAgainstPredicates (eSlawType_v4unt16c_array, s1);
  TestAgainstPredicates (eSlawType_v4unt16c_array, s2);
  TestAgainstPredicates (eSlawType_v4unt16c_array, s3);
  TestAgainstPredicates (eSlawType_v4unt16c_array, s4);
  n = sizeof (v4unt16c) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_v4unt16c_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p318, i + slaw_v4unt16c_array_emit (s3), sizeof (v4unt16c))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p320, p319, sizeof (p319));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_v4unt16c_array_emit_nth (s3, i)
          != i + slaw_v4unt16c_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_v4unt16c_arrays_concat (s3, s4, NULL);
  s = slaw_v4unt16c_array_empty (0);
  s6 = slaw_v4unt16c_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_v4unt16c_array_concat_carray (s3, p319, 1133);
  s8 = slaw_v4unt16c_array_concat_carray_f (s3, p319, 1133);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2int32 p321;
  m2int32 p322;
  m2int32 p323[13];
  m2int32 *p324;
  p321.coef[0] = random_int32 (q1);
  p321.coef[1] = random_int32 (q1);
  p321.coef[2] = random_int32 (q1);
  p321.coef[3] = random_int32 (q1);
  p322.coef[0] = random_int32 (q2);
  p322.coef[1] = random_int32 (q2);
  p322.coef[2] = random_int32 (q2);
  p322.coef[3] = random_int32 (q2);
  s = slaw_m2int32 (p321);
  TestAgainstPredicates (eSlawType_m2int32, s);
  if (memcmp (&p322, slaw_m2int32_emit (s), sizeof (m2int32)) != 0)
    error_exit ("compare failed for m2int32\n");
  if (memcmp (&p322, slaw_m2int32_emit_nocheck (s), sizeof (m2int32)) != 0)
    error_exit ("compare failed for m2int32\n");
  slaw_free (s);
  for (i = 0; i < 13; i++)
    {
      p323[i].coef[0] = random_int32 (q3);
      p323[i].coef[1] = random_int32 (q3);
      p323[i].coef[2] = random_int32 (q3);
      p323[i].coef[3] = random_int32 (q3);
    }
  s1 = slaw_m2int32_array_raw (13, &p324);
  s2 = slaw_m2int32_array_empty (random_unt8 (q1));
  s3 = slaw_m2int32_array_filled (random_unt8 (q1), p321);
  s4 = slaw_m2int32_array (p323, 13);
  TestAgainstPredicates (eSlawType_m2int32_array, s1);
  TestAgainstPredicates (eSlawType_m2int32_array, s2);
  TestAgainstPredicates (eSlawType_m2int32_array, s3);
  TestAgainstPredicates (eSlawType_m2int32_array, s4);
  n = sizeof (m2int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p322, i + slaw_m2int32_array_emit (s3), sizeof (m2int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p324, p323, sizeof (p323));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2int32_array_emit_nth (s3, i)
          != i + slaw_m2int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2int32_arrays_concat (s3, s4, NULL);
  s = slaw_m2int32_array_empty (0);
  s6 = slaw_m2int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2int32_array_concat_carray (s3, p323, 13);
  s8 = slaw_m2int32_array_concat_carray_f (s3, p323, 13);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2unt32 p325;
  m2unt32 p326;
  m2unt32 p327[790];
  m2unt32 *p328;
  p325.coef[0] = random_unt32 (q1);
  p325.coef[1] = random_unt32 (q1);
  p325.coef[2] = random_unt32 (q1);
  p325.coef[3] = random_unt32 (q1);
  p326.coef[0] = random_unt32 (q2);
  p326.coef[1] = random_unt32 (q2);
  p326.coef[2] = random_unt32 (q2);
  p326.coef[3] = random_unt32 (q2);
  s = slaw_m2unt32 (p325);
  TestAgainstPredicates (eSlawType_m2unt32, s);
  if (memcmp (&p326, slaw_m2unt32_emit (s), sizeof (m2unt32)) != 0)
    error_exit ("compare failed for m2unt32\n");
  if (memcmp (&p326, slaw_m2unt32_emit_nocheck (s), sizeof (m2unt32)) != 0)
    error_exit ("compare failed for m2unt32\n");
  slaw_free (s);
  for (i = 0; i < 790; i++)
    {
      p327[i].coef[0] = random_unt32 (q3);
      p327[i].coef[1] = random_unt32 (q3);
      p327[i].coef[2] = random_unt32 (q3);
      p327[i].coef[3] = random_unt32 (q3);
    }
  s1 = slaw_m2unt32_array_raw (790, &p328);
  s2 = slaw_m2unt32_array_empty (random_unt8 (q1));
  s3 = slaw_m2unt32_array_filled (random_unt8 (q1), p325);
  s4 = slaw_m2unt32_array (p327, 790);
  TestAgainstPredicates (eSlawType_m2unt32_array, s1);
  TestAgainstPredicates (eSlawType_m2unt32_array, s2);
  TestAgainstPredicates (eSlawType_m2unt32_array, s3);
  TestAgainstPredicates (eSlawType_m2unt32_array, s4);
  n = sizeof (m2unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p326, i + slaw_m2unt32_array_emit (s3), sizeof (m2unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p328, p327, sizeof (p327));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2unt32_array_emit_nth (s3, i)
          != i + slaw_m2unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2unt32_arrays_concat (s3, s4, NULL);
  s = slaw_m2unt32_array_empty (0);
  s6 = slaw_m2unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2unt32_array_concat_carray (s3, p327, 790);
  s8 = slaw_m2unt32_array_concat_carray_f (s3, p327, 790);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2int64 p329;
  m2int64 p330;
  m2int64 p331[1958];
  m2int64 *p332;
  p329.coef[0] = random_int64 (q1);
  p329.coef[1] = random_int64 (q1);
  p329.coef[2] = random_int64 (q1);
  p329.coef[3] = random_int64 (q1);
  p330.coef[0] = random_int64 (q2);
  p330.coef[1] = random_int64 (q2);
  p330.coef[2] = random_int64 (q2);
  p330.coef[3] = random_int64 (q2);
  s = slaw_m2int64 (p329);
  TestAgainstPredicates (eSlawType_m2int64, s);
  if (memcmp (&p330, slaw_m2int64_emit (s), sizeof (m2int64)) != 0)
    error_exit ("compare failed for m2int64\n");
  if (memcmp (&p330, slaw_m2int64_emit_nocheck (s), sizeof (m2int64)) != 0)
    error_exit ("compare failed for m2int64\n");
  slaw_free (s);
  for (i = 0; i < 1958; i++)
    {
      p331[i].coef[0] = random_int64 (q3);
      p331[i].coef[1] = random_int64 (q3);
      p331[i].coef[2] = random_int64 (q3);
      p331[i].coef[3] = random_int64 (q3);
    }
  s1 = slaw_m2int64_array_raw (1958, &p332);
  s2 = slaw_m2int64_array_empty (random_unt8 (q1));
  s3 = slaw_m2int64_array_filled (random_unt8 (q1), p329);
  s4 = slaw_m2int64_array (p331, 1958);
  TestAgainstPredicates (eSlawType_m2int64_array, s1);
  TestAgainstPredicates (eSlawType_m2int64_array, s2);
  TestAgainstPredicates (eSlawType_m2int64_array, s3);
  TestAgainstPredicates (eSlawType_m2int64_array, s4);
  n = sizeof (m2int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p330, i + slaw_m2int64_array_emit (s3), sizeof (m2int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p332, p331, sizeof (p331));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2int64_array_emit_nth (s3, i)
          != i + slaw_m2int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2int64_arrays_concat (s3, s4, NULL);
  s = slaw_m2int64_array_empty (0);
  s6 = slaw_m2int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2int64_array_concat_carray (s3, p331, 1958);
  s8 = slaw_m2int64_array_concat_carray_f (s3, p331, 1958);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2unt64 p333;
  m2unt64 p334;
  m2unt64 p335[1848];
  m2unt64 *p336;
  p333.coef[0] = random_unt64 (q1);
  p333.coef[1] = random_unt64 (q1);
  p333.coef[2] = random_unt64 (q1);
  p333.coef[3] = random_unt64 (q1);
  p334.coef[0] = random_unt64 (q2);
  p334.coef[1] = random_unt64 (q2);
  p334.coef[2] = random_unt64 (q2);
  p334.coef[3] = random_unt64 (q2);
  s = slaw_m2unt64 (p333);
  TestAgainstPredicates (eSlawType_m2unt64, s);
  if (memcmp (&p334, slaw_m2unt64_emit (s), sizeof (m2unt64)) != 0)
    error_exit ("compare failed for m2unt64\n");
  if (memcmp (&p334, slaw_m2unt64_emit_nocheck (s), sizeof (m2unt64)) != 0)
    error_exit ("compare failed for m2unt64\n");
  slaw_free (s);
  for (i = 0; i < 1848; i++)
    {
      p335[i].coef[0] = random_unt64 (q3);
      p335[i].coef[1] = random_unt64 (q3);
      p335[i].coef[2] = random_unt64 (q3);
      p335[i].coef[3] = random_unt64 (q3);
    }
  s1 = slaw_m2unt64_array_raw (1848, &p336);
  s2 = slaw_m2unt64_array_empty (random_unt8 (q1));
  s3 = slaw_m2unt64_array_filled (random_unt8 (q1), p333);
  s4 = slaw_m2unt64_array (p335, 1848);
  TestAgainstPredicates (eSlawType_m2unt64_array, s1);
  TestAgainstPredicates (eSlawType_m2unt64_array, s2);
  TestAgainstPredicates (eSlawType_m2unt64_array, s3);
  TestAgainstPredicates (eSlawType_m2unt64_array, s4);
  n = sizeof (m2unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p334, i + slaw_m2unt64_array_emit (s3), sizeof (m2unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p336, p335, sizeof (p335));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2unt64_array_emit_nth (s3, i)
          != i + slaw_m2unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2unt64_arrays_concat (s3, s4, NULL);
  s = slaw_m2unt64_array_empty (0);
  s6 = slaw_m2unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2unt64_array_concat_carray (s3, p335, 1848);
  s8 = slaw_m2unt64_array_concat_carray_f (s3, p335, 1848);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2float32 p337;
  m2float32 p338;
  m2float32 p339[231];
  m2float32 *p340;
  p337.coef[0] = random_float32 (q1);
  p337.coef[1] = random_float32 (q1);
  p337.coef[2] = random_float32 (q1);
  p337.coef[3] = random_float32 (q1);
  p338.coef[0] = random_float32 (q2);
  p338.coef[1] = random_float32 (q2);
  p338.coef[2] = random_float32 (q2);
  p338.coef[3] = random_float32 (q2);
  s = slaw_m2float32 (p337);
  TestAgainstPredicates (eSlawType_m2float32, s);
  if (memcmp (&p338, slaw_m2float32_emit (s), sizeof (m2float32)) != 0)
    error_exit ("compare failed for m2float32\n");
  if (memcmp (&p338, slaw_m2float32_emit_nocheck (s), sizeof (m2float32)) != 0)
    error_exit ("compare failed for m2float32\n");
  slaw_free (s);
  for (i = 0; i < 231; i++)
    {
      p339[i].coef[0] = random_float32 (q3);
      p339[i].coef[1] = random_float32 (q3);
      p339[i].coef[2] = random_float32 (q3);
      p339[i].coef[3] = random_float32 (q3);
    }
  s1 = slaw_m2float32_array_raw (231, &p340);
  s2 = slaw_m2float32_array_empty (random_unt8 (q1));
  s3 = slaw_m2float32_array_filled (random_unt8 (q1), p337);
  s4 = slaw_m2float32_array (p339, 231);
  TestAgainstPredicates (eSlawType_m2float32_array, s1);
  TestAgainstPredicates (eSlawType_m2float32_array, s2);
  TestAgainstPredicates (eSlawType_m2float32_array, s3);
  TestAgainstPredicates (eSlawType_m2float32_array, s4);
  n = sizeof (m2float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p338, i + slaw_m2float32_array_emit (s3), sizeof (m2float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p340, p339, sizeof (p339));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2float32_array_emit_nth (s3, i)
          != i + slaw_m2float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2float32_arrays_concat (s3, s4, NULL);
  s = slaw_m2float32_array_empty (0);
  s6 = slaw_m2float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2float32_array_concat_carray (s3, p339, 231);
  s8 = slaw_m2float32_array_concat_carray_f (s3, p339, 231);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2float64 p341;
  m2float64 p342;
  m2float64 p343[1034];
  m2float64 *p344;
  p341.coef[0] = random_float64 (q1);
  p341.coef[1] = random_float64 (q1);
  p341.coef[2] = random_float64 (q1);
  p341.coef[3] = random_float64 (q1);
  p342.coef[0] = random_float64 (q2);
  p342.coef[1] = random_float64 (q2);
  p342.coef[2] = random_float64 (q2);
  p342.coef[3] = random_float64 (q2);
  s = slaw_m2float64 (p341);
  TestAgainstPredicates (eSlawType_m2float64, s);
  if (memcmp (&p342, slaw_m2float64_emit (s), sizeof (m2float64)) != 0)
    error_exit ("compare failed for m2float64\n");
  if (memcmp (&p342, slaw_m2float64_emit_nocheck (s), sizeof (m2float64)) != 0)
    error_exit ("compare failed for m2float64\n");
  slaw_free (s);
  for (i = 0; i < 1034; i++)
    {
      p343[i].coef[0] = random_float64 (q3);
      p343[i].coef[1] = random_float64 (q3);
      p343[i].coef[2] = random_float64 (q3);
      p343[i].coef[3] = random_float64 (q3);
    }
  s1 = slaw_m2float64_array_raw (1034, &p344);
  s2 = slaw_m2float64_array_empty (random_unt8 (q1));
  s3 = slaw_m2float64_array_filled (random_unt8 (q1), p341);
  s4 = slaw_m2float64_array (p343, 1034);
  TestAgainstPredicates (eSlawType_m2float64_array, s1);
  TestAgainstPredicates (eSlawType_m2float64_array, s2);
  TestAgainstPredicates (eSlawType_m2float64_array, s3);
  TestAgainstPredicates (eSlawType_m2float64_array, s4);
  n = sizeof (m2float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p342, i + slaw_m2float64_array_emit (s3), sizeof (m2float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p344, p343, sizeof (p343));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2float64_array_emit_nth (s3, i)
          != i + slaw_m2float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2float64_arrays_concat (s3, s4, NULL);
  s = slaw_m2float64_array_empty (0);
  s6 = slaw_m2float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2float64_array_concat_carray (s3, p343, 1034);
  s8 = slaw_m2float64_array_concat_carray_f (s3, p343, 1034);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2int8 p345;
  m2int8 p346;
  m2int8 p347[1140];
  m2int8 *p348;
  p345.coef[0] = random_int8 (q1);
  p345.coef[1] = random_int8 (q1);
  p345.coef[2] = random_int8 (q1);
  p345.coef[3] = random_int8 (q1);
  p346.coef[0] = random_int8 (q2);
  p346.coef[1] = random_int8 (q2);
  p346.coef[2] = random_int8 (q2);
  p346.coef[3] = random_int8 (q2);
  s = slaw_m2int8 (p345);
  TestAgainstPredicates (eSlawType_m2int8, s);
  if (memcmp (&p346, slaw_m2int8_emit (s), sizeof (m2int8)) != 0)
    error_exit ("compare failed for m2int8\n");
  if (memcmp (&p346, slaw_m2int8_emit_nocheck (s), sizeof (m2int8)) != 0)
    error_exit ("compare failed for m2int8\n");
  slaw_free (s);
  for (i = 0; i < 1140; i++)
    {
      p347[i].coef[0] = random_int8 (q3);
      p347[i].coef[1] = random_int8 (q3);
      p347[i].coef[2] = random_int8 (q3);
      p347[i].coef[3] = random_int8 (q3);
    }
  s1 = slaw_m2int8_array_raw (1140, &p348);
  s2 = slaw_m2int8_array_empty (random_unt8 (q1));
  s3 = slaw_m2int8_array_filled (random_unt8 (q1), p345);
  s4 = slaw_m2int8_array (p347, 1140);
  TestAgainstPredicates (eSlawType_m2int8_array, s1);
  TestAgainstPredicates (eSlawType_m2int8_array, s2);
  TestAgainstPredicates (eSlawType_m2int8_array, s3);
  TestAgainstPredicates (eSlawType_m2int8_array, s4);
  n = sizeof (m2int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p346, i + slaw_m2int8_array_emit (s3), sizeof (m2int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p348, p347, sizeof (p347));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2int8_array_emit_nth (s3, i) != i + slaw_m2int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2int8_arrays_concat (s3, s4, NULL);
  s = slaw_m2int8_array_empty (0);
  s6 = slaw_m2int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2int8_array_concat_carray (s3, p347, 1140);
  s8 = slaw_m2int8_array_concat_carray_f (s3, p347, 1140);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2unt8 p349;
  m2unt8 p350;
  m2unt8 p351[1768];
  m2unt8 *p352;
  p349.coef[0] = random_unt8 (q1);
  p349.coef[1] = random_unt8 (q1);
  p349.coef[2] = random_unt8 (q1);
  p349.coef[3] = random_unt8 (q1);
  p350.coef[0] = random_unt8 (q2);
  p350.coef[1] = random_unt8 (q2);
  p350.coef[2] = random_unt8 (q2);
  p350.coef[3] = random_unt8 (q2);
  s = slaw_m2unt8 (p349);
  TestAgainstPredicates (eSlawType_m2unt8, s);
  if (memcmp (&p350, slaw_m2unt8_emit (s), sizeof (m2unt8)) != 0)
    error_exit ("compare failed for m2unt8\n");
  if (memcmp (&p350, slaw_m2unt8_emit_nocheck (s), sizeof (m2unt8)) != 0)
    error_exit ("compare failed for m2unt8\n");
  slaw_free (s);
  for (i = 0; i < 1768; i++)
    {
      p351[i].coef[0] = random_unt8 (q3);
      p351[i].coef[1] = random_unt8 (q3);
      p351[i].coef[2] = random_unt8 (q3);
      p351[i].coef[3] = random_unt8 (q3);
    }
  s1 = slaw_m2unt8_array_raw (1768, &p352);
  s2 = slaw_m2unt8_array_empty (random_unt8 (q1));
  s3 = slaw_m2unt8_array_filled (random_unt8 (q1), p349);
  s4 = slaw_m2unt8_array (p351, 1768);
  TestAgainstPredicates (eSlawType_m2unt8_array, s1);
  TestAgainstPredicates (eSlawType_m2unt8_array, s2);
  TestAgainstPredicates (eSlawType_m2unt8_array, s3);
  TestAgainstPredicates (eSlawType_m2unt8_array, s4);
  n = sizeof (m2unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p350, i + slaw_m2unt8_array_emit (s3), sizeof (m2unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p352, p351, sizeof (p351));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2unt8_array_emit_nth (s3, i) != i + slaw_m2unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2unt8_arrays_concat (s3, s4, NULL);
  s = slaw_m2unt8_array_empty (0);
  s6 = slaw_m2unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2unt8_array_concat_carray (s3, p351, 1768);
  s8 = slaw_m2unt8_array_concat_carray_f (s3, p351, 1768);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2int16 p353;
  m2int16 p354;
  m2int16 p355[590];
  m2int16 *p356;
  p353.coef[0] = random_int16 (q1);
  p353.coef[1] = random_int16 (q1);
  p353.coef[2] = random_int16 (q1);
  p353.coef[3] = random_int16 (q1);
  p354.coef[0] = random_int16 (q2);
  p354.coef[1] = random_int16 (q2);
  p354.coef[2] = random_int16 (q2);
  p354.coef[3] = random_int16 (q2);
  s = slaw_m2int16 (p353);
  TestAgainstPredicates (eSlawType_m2int16, s);
  if (memcmp (&p354, slaw_m2int16_emit (s), sizeof (m2int16)) != 0)
    error_exit ("compare failed for m2int16\n");
  if (memcmp (&p354, slaw_m2int16_emit_nocheck (s), sizeof (m2int16)) != 0)
    error_exit ("compare failed for m2int16\n");
  slaw_free (s);
  for (i = 0; i < 590; i++)
    {
      p355[i].coef[0] = random_int16 (q3);
      p355[i].coef[1] = random_int16 (q3);
      p355[i].coef[2] = random_int16 (q3);
      p355[i].coef[3] = random_int16 (q3);
    }
  s1 = slaw_m2int16_array_raw (590, &p356);
  s2 = slaw_m2int16_array_empty (random_unt8 (q1));
  s3 = slaw_m2int16_array_filled (random_unt8 (q1), p353);
  s4 = slaw_m2int16_array (p355, 590);
  TestAgainstPredicates (eSlawType_m2int16_array, s1);
  TestAgainstPredicates (eSlawType_m2int16_array, s2);
  TestAgainstPredicates (eSlawType_m2int16_array, s3);
  TestAgainstPredicates (eSlawType_m2int16_array, s4);
  n = sizeof (m2int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p354, i + slaw_m2int16_array_emit (s3), sizeof (m2int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p356, p355, sizeof (p355));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2int16_array_emit_nth (s3, i)
          != i + slaw_m2int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2int16_arrays_concat (s3, s4, NULL);
  s = slaw_m2int16_array_empty (0);
  s6 = slaw_m2int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2int16_array_concat_carray (s3, p355, 590);
  s8 = slaw_m2int16_array_concat_carray_f (s3, p355, 590);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m2unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m2unt16 p357;
  m2unt16 p358;
  m2unt16 p359[1322];
  m2unt16 *p360;
  p357.coef[0] = random_unt16 (q1);
  p357.coef[1] = random_unt16 (q1);
  p357.coef[2] = random_unt16 (q1);
  p357.coef[3] = random_unt16 (q1);
  p358.coef[0] = random_unt16 (q2);
  p358.coef[1] = random_unt16 (q2);
  p358.coef[2] = random_unt16 (q2);
  p358.coef[3] = random_unt16 (q2);
  s = slaw_m2unt16 (p357);
  TestAgainstPredicates (eSlawType_m2unt16, s);
  if (memcmp (&p358, slaw_m2unt16_emit (s), sizeof (m2unt16)) != 0)
    error_exit ("compare failed for m2unt16\n");
  if (memcmp (&p358, slaw_m2unt16_emit_nocheck (s), sizeof (m2unt16)) != 0)
    error_exit ("compare failed for m2unt16\n");
  slaw_free (s);
  for (i = 0; i < 1322; i++)
    {
      p359[i].coef[0] = random_unt16 (q3);
      p359[i].coef[1] = random_unt16 (q3);
      p359[i].coef[2] = random_unt16 (q3);
      p359[i].coef[3] = random_unt16 (q3);
    }
  s1 = slaw_m2unt16_array_raw (1322, &p360);
  s2 = slaw_m2unt16_array_empty (random_unt8 (q1));
  s3 = slaw_m2unt16_array_filled (random_unt8 (q1), p357);
  s4 = slaw_m2unt16_array (p359, 1322);
  TestAgainstPredicates (eSlawType_m2unt16_array, s1);
  TestAgainstPredicates (eSlawType_m2unt16_array, s2);
  TestAgainstPredicates (eSlawType_m2unt16_array, s3);
  TestAgainstPredicates (eSlawType_m2unt16_array, s4);
  n = sizeof (m2unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m2unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p358, i + slaw_m2unt16_array_emit (s3), sizeof (m2unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p360, p359, sizeof (p359));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m2unt16_array_emit_nth (s3, i)
          != i + slaw_m2unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m2unt16_arrays_concat (s3, s4, NULL);
  s = slaw_m2unt16_array_empty (0);
  s6 = slaw_m2unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m2unt16_array_concat_carray (s3, p359, 1322);
  s8 = slaw_m2unt16_array_concat_carray_f (s3, p359, 1322);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3int32 p361;
  m3int32 p362;
  m3int32 p363[531];
  m3int32 *p364;
  p361.coef[0] = random_int32 (q1);
  p361.coef[1] = random_int32 (q1);
  p361.coef[2] = random_int32 (q1);
  p361.coef[3] = random_int32 (q1);
  p361.coef[4] = random_int32 (q1);
  p361.coef[5] = random_int32 (q1);
  p361.coef[6] = random_int32 (q1);
  p361.coef[7] = random_int32 (q1);
  p362.coef[0] = random_int32 (q2);
  p362.coef[1] = random_int32 (q2);
  p362.coef[2] = random_int32 (q2);
  p362.coef[3] = random_int32 (q2);
  p362.coef[4] = random_int32 (q2);
  p362.coef[5] = random_int32 (q2);
  p362.coef[6] = random_int32 (q2);
  p362.coef[7] = random_int32 (q2);
  s = slaw_m3int32 (p361);
  TestAgainstPredicates (eSlawType_m3int32, s);
  if (memcmp (&p362, slaw_m3int32_emit (s), sizeof (m3int32)) != 0)
    error_exit ("compare failed for m3int32\n");
  if (memcmp (&p362, slaw_m3int32_emit_nocheck (s), sizeof (m3int32)) != 0)
    error_exit ("compare failed for m3int32\n");
  slaw_free (s);
  for (i = 0; i < 531; i++)
    {
      p363[i].coef[0] = random_int32 (q3);
      p363[i].coef[1] = random_int32 (q3);
      p363[i].coef[2] = random_int32 (q3);
      p363[i].coef[3] = random_int32 (q3);
      p363[i].coef[4] = random_int32 (q3);
      p363[i].coef[5] = random_int32 (q3);
      p363[i].coef[6] = random_int32 (q3);
      p363[i].coef[7] = random_int32 (q3);
    }
  s1 = slaw_m3int32_array_raw (531, &p364);
  s2 = slaw_m3int32_array_empty (random_unt8 (q1));
  s3 = slaw_m3int32_array_filled (random_unt8 (q1), p361);
  s4 = slaw_m3int32_array (p363, 531);
  TestAgainstPredicates (eSlawType_m3int32_array, s1);
  TestAgainstPredicates (eSlawType_m3int32_array, s2);
  TestAgainstPredicates (eSlawType_m3int32_array, s3);
  TestAgainstPredicates (eSlawType_m3int32_array, s4);
  n = sizeof (m3int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p362, i + slaw_m3int32_array_emit (s3), sizeof (m3int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p364, p363, sizeof (p363));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3int32_array_emit_nth (s3, i)
          != i + slaw_m3int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3int32_arrays_concat (s3, s4, NULL);
  s = slaw_m3int32_array_empty (0);
  s6 = slaw_m3int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3int32_array_concat_carray (s3, p363, 531);
  s8 = slaw_m3int32_array_concat_carray_f (s3, p363, 531);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3unt32 p365;
  m3unt32 p366;
  m3unt32 p367[815];
  m3unt32 *p368;
  p365.coef[0] = random_unt32 (q1);
  p365.coef[1] = random_unt32 (q1);
  p365.coef[2] = random_unt32 (q1);
  p365.coef[3] = random_unt32 (q1);
  p365.coef[4] = random_unt32 (q1);
  p365.coef[5] = random_unt32 (q1);
  p365.coef[6] = random_unt32 (q1);
  p365.coef[7] = random_unt32 (q1);
  p366.coef[0] = random_unt32 (q2);
  p366.coef[1] = random_unt32 (q2);
  p366.coef[2] = random_unt32 (q2);
  p366.coef[3] = random_unt32 (q2);
  p366.coef[4] = random_unt32 (q2);
  p366.coef[5] = random_unt32 (q2);
  p366.coef[6] = random_unt32 (q2);
  p366.coef[7] = random_unt32 (q2);
  s = slaw_m3unt32 (p365);
  TestAgainstPredicates (eSlawType_m3unt32, s);
  if (memcmp (&p366, slaw_m3unt32_emit (s), sizeof (m3unt32)) != 0)
    error_exit ("compare failed for m3unt32\n");
  if (memcmp (&p366, slaw_m3unt32_emit_nocheck (s), sizeof (m3unt32)) != 0)
    error_exit ("compare failed for m3unt32\n");
  slaw_free (s);
  for (i = 0; i < 815; i++)
    {
      p367[i].coef[0] = random_unt32 (q3);
      p367[i].coef[1] = random_unt32 (q3);
      p367[i].coef[2] = random_unt32 (q3);
      p367[i].coef[3] = random_unt32 (q3);
      p367[i].coef[4] = random_unt32 (q3);
      p367[i].coef[5] = random_unt32 (q3);
      p367[i].coef[6] = random_unt32 (q3);
      p367[i].coef[7] = random_unt32 (q3);
    }
  s1 = slaw_m3unt32_array_raw (815, &p368);
  s2 = slaw_m3unt32_array_empty (random_unt8 (q1));
  s3 = slaw_m3unt32_array_filled (random_unt8 (q1), p365);
  s4 = slaw_m3unt32_array (p367, 815);
  TestAgainstPredicates (eSlawType_m3unt32_array, s1);
  TestAgainstPredicates (eSlawType_m3unt32_array, s2);
  TestAgainstPredicates (eSlawType_m3unt32_array, s3);
  TestAgainstPredicates (eSlawType_m3unt32_array, s4);
  n = sizeof (m3unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p366, i + slaw_m3unt32_array_emit (s3), sizeof (m3unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p368, p367, sizeof (p367));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3unt32_array_emit_nth (s3, i)
          != i + slaw_m3unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3unt32_arrays_concat (s3, s4, NULL);
  s = slaw_m3unt32_array_empty (0);
  s6 = slaw_m3unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3unt32_array_concat_carray (s3, p367, 815);
  s8 = slaw_m3unt32_array_concat_carray_f (s3, p367, 815);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3int64 p369;
  m3int64 p370;
  m3int64 p371[394];
  m3int64 *p372;
  p369.coef[0] = random_int64 (q1);
  p369.coef[1] = random_int64 (q1);
  p369.coef[2] = random_int64 (q1);
  p369.coef[3] = random_int64 (q1);
  p369.coef[4] = random_int64 (q1);
  p369.coef[5] = random_int64 (q1);
  p369.coef[6] = random_int64 (q1);
  p369.coef[7] = random_int64 (q1);
  p370.coef[0] = random_int64 (q2);
  p370.coef[1] = random_int64 (q2);
  p370.coef[2] = random_int64 (q2);
  p370.coef[3] = random_int64 (q2);
  p370.coef[4] = random_int64 (q2);
  p370.coef[5] = random_int64 (q2);
  p370.coef[6] = random_int64 (q2);
  p370.coef[7] = random_int64 (q2);
  s = slaw_m3int64 (p369);
  TestAgainstPredicates (eSlawType_m3int64, s);
  if (memcmp (&p370, slaw_m3int64_emit (s), sizeof (m3int64)) != 0)
    error_exit ("compare failed for m3int64\n");
  if (memcmp (&p370, slaw_m3int64_emit_nocheck (s), sizeof (m3int64)) != 0)
    error_exit ("compare failed for m3int64\n");
  slaw_free (s);
  for (i = 0; i < 394; i++)
    {
      p371[i].coef[0] = random_int64 (q3);
      p371[i].coef[1] = random_int64 (q3);
      p371[i].coef[2] = random_int64 (q3);
      p371[i].coef[3] = random_int64 (q3);
      p371[i].coef[4] = random_int64 (q3);
      p371[i].coef[5] = random_int64 (q3);
      p371[i].coef[6] = random_int64 (q3);
      p371[i].coef[7] = random_int64 (q3);
    }
  s1 = slaw_m3int64_array_raw (394, &p372);
  s2 = slaw_m3int64_array_empty (random_unt8 (q1));
  s3 = slaw_m3int64_array_filled (random_unt8 (q1), p369);
  s4 = slaw_m3int64_array (p371, 394);
  TestAgainstPredicates (eSlawType_m3int64_array, s1);
  TestAgainstPredicates (eSlawType_m3int64_array, s2);
  TestAgainstPredicates (eSlawType_m3int64_array, s3);
  TestAgainstPredicates (eSlawType_m3int64_array, s4);
  n = sizeof (m3int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p370, i + slaw_m3int64_array_emit (s3), sizeof (m3int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p372, p371, sizeof (p371));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3int64_array_emit_nth (s3, i)
          != i + slaw_m3int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3int64_arrays_concat (s3, s4, NULL);
  s = slaw_m3int64_array_empty (0);
  s6 = slaw_m3int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3int64_array_concat_carray (s3, p371, 394);
  s8 = slaw_m3int64_array_concat_carray_f (s3, p371, 394);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3unt64 p373;
  m3unt64 p374;
  m3unt64 p375[783];
  m3unt64 *p376;
  p373.coef[0] = random_unt64 (q1);
  p373.coef[1] = random_unt64 (q1);
  p373.coef[2] = random_unt64 (q1);
  p373.coef[3] = random_unt64 (q1);
  p373.coef[4] = random_unt64 (q1);
  p373.coef[5] = random_unt64 (q1);
  p373.coef[6] = random_unt64 (q1);
  p373.coef[7] = random_unt64 (q1);
  p374.coef[0] = random_unt64 (q2);
  p374.coef[1] = random_unt64 (q2);
  p374.coef[2] = random_unt64 (q2);
  p374.coef[3] = random_unt64 (q2);
  p374.coef[4] = random_unt64 (q2);
  p374.coef[5] = random_unt64 (q2);
  p374.coef[6] = random_unt64 (q2);
  p374.coef[7] = random_unt64 (q2);
  s = slaw_m3unt64 (p373);
  TestAgainstPredicates (eSlawType_m3unt64, s);
  if (memcmp (&p374, slaw_m3unt64_emit (s), sizeof (m3unt64)) != 0)
    error_exit ("compare failed for m3unt64\n");
  if (memcmp (&p374, slaw_m3unt64_emit_nocheck (s), sizeof (m3unt64)) != 0)
    error_exit ("compare failed for m3unt64\n");
  slaw_free (s);
  for (i = 0; i < 783; i++)
    {
      p375[i].coef[0] = random_unt64 (q3);
      p375[i].coef[1] = random_unt64 (q3);
      p375[i].coef[2] = random_unt64 (q3);
      p375[i].coef[3] = random_unt64 (q3);
      p375[i].coef[4] = random_unt64 (q3);
      p375[i].coef[5] = random_unt64 (q3);
      p375[i].coef[6] = random_unt64 (q3);
      p375[i].coef[7] = random_unt64 (q3);
    }
  s1 = slaw_m3unt64_array_raw (783, &p376);
  s2 = slaw_m3unt64_array_empty (random_unt8 (q1));
  s3 = slaw_m3unt64_array_filled (random_unt8 (q1), p373);
  s4 = slaw_m3unt64_array (p375, 783);
  TestAgainstPredicates (eSlawType_m3unt64_array, s1);
  TestAgainstPredicates (eSlawType_m3unt64_array, s2);
  TestAgainstPredicates (eSlawType_m3unt64_array, s3);
  TestAgainstPredicates (eSlawType_m3unt64_array, s4);
  n = sizeof (m3unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p374, i + slaw_m3unt64_array_emit (s3), sizeof (m3unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p376, p375, sizeof (p375));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3unt64_array_emit_nth (s3, i)
          != i + slaw_m3unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3unt64_arrays_concat (s3, s4, NULL);
  s = slaw_m3unt64_array_empty (0);
  s6 = slaw_m3unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3unt64_array_concat_carray (s3, p375, 783);
  s8 = slaw_m3unt64_array_concat_carray_f (s3, p375, 783);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3float32 p377;
  m3float32 p378;
  m3float32 p379[1583];
  m3float32 *p380;
  p377.coef[0] = random_float32 (q1);
  p377.coef[1] = random_float32 (q1);
  p377.coef[2] = random_float32 (q1);
  p377.coef[3] = random_float32 (q1);
  p377.coef[4] = random_float32 (q1);
  p377.coef[5] = random_float32 (q1);
  p377.coef[6] = random_float32 (q1);
  p377.coef[7] = random_float32 (q1);
  p378.coef[0] = random_float32 (q2);
  p378.coef[1] = random_float32 (q2);
  p378.coef[2] = random_float32 (q2);
  p378.coef[3] = random_float32 (q2);
  p378.coef[4] = random_float32 (q2);
  p378.coef[5] = random_float32 (q2);
  p378.coef[6] = random_float32 (q2);
  p378.coef[7] = random_float32 (q2);
  s = slaw_m3float32 (p377);
  TestAgainstPredicates (eSlawType_m3float32, s);
  if (memcmp (&p378, slaw_m3float32_emit (s), sizeof (m3float32)) != 0)
    error_exit ("compare failed for m3float32\n");
  if (memcmp (&p378, slaw_m3float32_emit_nocheck (s), sizeof (m3float32)) != 0)
    error_exit ("compare failed for m3float32\n");
  slaw_free (s);
  for (i = 0; i < 1583; i++)
    {
      p379[i].coef[0] = random_float32 (q3);
      p379[i].coef[1] = random_float32 (q3);
      p379[i].coef[2] = random_float32 (q3);
      p379[i].coef[3] = random_float32 (q3);
      p379[i].coef[4] = random_float32 (q3);
      p379[i].coef[5] = random_float32 (q3);
      p379[i].coef[6] = random_float32 (q3);
      p379[i].coef[7] = random_float32 (q3);
    }
  s1 = slaw_m3float32_array_raw (1583, &p380);
  s2 = slaw_m3float32_array_empty (random_unt8 (q1));
  s3 = slaw_m3float32_array_filled (random_unt8 (q1), p377);
  s4 = slaw_m3float32_array (p379, 1583);
  TestAgainstPredicates (eSlawType_m3float32_array, s1);
  TestAgainstPredicates (eSlawType_m3float32_array, s2);
  TestAgainstPredicates (eSlawType_m3float32_array, s3);
  TestAgainstPredicates (eSlawType_m3float32_array, s4);
  n = sizeof (m3float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p378, i + slaw_m3float32_array_emit (s3), sizeof (m3float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p380, p379, sizeof (p379));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3float32_array_emit_nth (s3, i)
          != i + slaw_m3float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3float32_arrays_concat (s3, s4, NULL);
  s = slaw_m3float32_array_empty (0);
  s6 = slaw_m3float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3float32_array_concat_carray (s3, p379, 1583);
  s8 = slaw_m3float32_array_concat_carray_f (s3, p379, 1583);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3float64 p381;
  m3float64 p382;
  m3float64 p383[401];
  m3float64 *p384;
  p381.coef[0] = random_float64 (q1);
  p381.coef[1] = random_float64 (q1);
  p381.coef[2] = random_float64 (q1);
  p381.coef[3] = random_float64 (q1);
  p381.coef[4] = random_float64 (q1);
  p381.coef[5] = random_float64 (q1);
  p381.coef[6] = random_float64 (q1);
  p381.coef[7] = random_float64 (q1);
  p382.coef[0] = random_float64 (q2);
  p382.coef[1] = random_float64 (q2);
  p382.coef[2] = random_float64 (q2);
  p382.coef[3] = random_float64 (q2);
  p382.coef[4] = random_float64 (q2);
  p382.coef[5] = random_float64 (q2);
  p382.coef[6] = random_float64 (q2);
  p382.coef[7] = random_float64 (q2);
  s = slaw_m3float64 (p381);
  TestAgainstPredicates (eSlawType_m3float64, s);
  if (memcmp (&p382, slaw_m3float64_emit (s), sizeof (m3float64)) != 0)
    error_exit ("compare failed for m3float64\n");
  if (memcmp (&p382, slaw_m3float64_emit_nocheck (s), sizeof (m3float64)) != 0)
    error_exit ("compare failed for m3float64\n");
  slaw_free (s);
  for (i = 0; i < 401; i++)
    {
      p383[i].coef[0] = random_float64 (q3);
      p383[i].coef[1] = random_float64 (q3);
      p383[i].coef[2] = random_float64 (q3);
      p383[i].coef[3] = random_float64 (q3);
      p383[i].coef[4] = random_float64 (q3);
      p383[i].coef[5] = random_float64 (q3);
      p383[i].coef[6] = random_float64 (q3);
      p383[i].coef[7] = random_float64 (q3);
    }
  s1 = slaw_m3float64_array_raw (401, &p384);
  s2 = slaw_m3float64_array_empty (random_unt8 (q1));
  s3 = slaw_m3float64_array_filled (random_unt8 (q1), p381);
  s4 = slaw_m3float64_array (p383, 401);
  TestAgainstPredicates (eSlawType_m3float64_array, s1);
  TestAgainstPredicates (eSlawType_m3float64_array, s2);
  TestAgainstPredicates (eSlawType_m3float64_array, s3);
  TestAgainstPredicates (eSlawType_m3float64_array, s4);
  n = sizeof (m3float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p382, i + slaw_m3float64_array_emit (s3), sizeof (m3float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p384, p383, sizeof (p383));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3float64_array_emit_nth (s3, i)
          != i + slaw_m3float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3float64_arrays_concat (s3, s4, NULL);
  s = slaw_m3float64_array_empty (0);
  s6 = slaw_m3float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3float64_array_concat_carray (s3, p383, 401);
  s8 = slaw_m3float64_array_concat_carray_f (s3, p383, 401);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3int8 p385;
  m3int8 p386;
  m3int8 p387[1562];
  m3int8 *p388;
  p385.coef[0] = random_int8 (q1);
  p385.coef[1] = random_int8 (q1);
  p385.coef[2] = random_int8 (q1);
  p385.coef[3] = random_int8 (q1);
  p385.coef[4] = random_int8 (q1);
  p385.coef[5] = random_int8 (q1);
  p385.coef[6] = random_int8 (q1);
  p385.coef[7] = random_int8 (q1);
  p386.coef[0] = random_int8 (q2);
  p386.coef[1] = random_int8 (q2);
  p386.coef[2] = random_int8 (q2);
  p386.coef[3] = random_int8 (q2);
  p386.coef[4] = random_int8 (q2);
  p386.coef[5] = random_int8 (q2);
  p386.coef[6] = random_int8 (q2);
  p386.coef[7] = random_int8 (q2);
  s = slaw_m3int8 (p385);
  TestAgainstPredicates (eSlawType_m3int8, s);
  if (memcmp (&p386, slaw_m3int8_emit (s), sizeof (m3int8)) != 0)
    error_exit ("compare failed for m3int8\n");
  if (memcmp (&p386, slaw_m3int8_emit_nocheck (s), sizeof (m3int8)) != 0)
    error_exit ("compare failed for m3int8\n");
  slaw_free (s);
  for (i = 0; i < 1562; i++)
    {
      p387[i].coef[0] = random_int8 (q3);
      p387[i].coef[1] = random_int8 (q3);
      p387[i].coef[2] = random_int8 (q3);
      p387[i].coef[3] = random_int8 (q3);
      p387[i].coef[4] = random_int8 (q3);
      p387[i].coef[5] = random_int8 (q3);
      p387[i].coef[6] = random_int8 (q3);
      p387[i].coef[7] = random_int8 (q3);
    }
  s1 = slaw_m3int8_array_raw (1562, &p388);
  s2 = slaw_m3int8_array_empty (random_unt8 (q1));
  s3 = slaw_m3int8_array_filled (random_unt8 (q1), p385);
  s4 = slaw_m3int8_array (p387, 1562);
  TestAgainstPredicates (eSlawType_m3int8_array, s1);
  TestAgainstPredicates (eSlawType_m3int8_array, s2);
  TestAgainstPredicates (eSlawType_m3int8_array, s3);
  TestAgainstPredicates (eSlawType_m3int8_array, s4);
  n = sizeof (m3int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p386, i + slaw_m3int8_array_emit (s3), sizeof (m3int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p388, p387, sizeof (p387));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3int8_array_emit_nth (s3, i) != i + slaw_m3int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3int8_arrays_concat (s3, s4, NULL);
  s = slaw_m3int8_array_empty (0);
  s6 = slaw_m3int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3int8_array_concat_carray (s3, p387, 1562);
  s8 = slaw_m3int8_array_concat_carray_f (s3, p387, 1562);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3unt8 p389;
  m3unt8 p390;
  m3unt8 p391[1122];
  m3unt8 *p392;
  p389.coef[0] = random_unt8 (q1);
  p389.coef[1] = random_unt8 (q1);
  p389.coef[2] = random_unt8 (q1);
  p389.coef[3] = random_unt8 (q1);
  p389.coef[4] = random_unt8 (q1);
  p389.coef[5] = random_unt8 (q1);
  p389.coef[6] = random_unt8 (q1);
  p389.coef[7] = random_unt8 (q1);
  p390.coef[0] = random_unt8 (q2);
  p390.coef[1] = random_unt8 (q2);
  p390.coef[2] = random_unt8 (q2);
  p390.coef[3] = random_unt8 (q2);
  p390.coef[4] = random_unt8 (q2);
  p390.coef[5] = random_unt8 (q2);
  p390.coef[6] = random_unt8 (q2);
  p390.coef[7] = random_unt8 (q2);
  s = slaw_m3unt8 (p389);
  TestAgainstPredicates (eSlawType_m3unt8, s);
  if (memcmp (&p390, slaw_m3unt8_emit (s), sizeof (m3unt8)) != 0)
    error_exit ("compare failed for m3unt8\n");
  if (memcmp (&p390, slaw_m3unt8_emit_nocheck (s), sizeof (m3unt8)) != 0)
    error_exit ("compare failed for m3unt8\n");
  slaw_free (s);
  for (i = 0; i < 1122; i++)
    {
      p391[i].coef[0] = random_unt8 (q3);
      p391[i].coef[1] = random_unt8 (q3);
      p391[i].coef[2] = random_unt8 (q3);
      p391[i].coef[3] = random_unt8 (q3);
      p391[i].coef[4] = random_unt8 (q3);
      p391[i].coef[5] = random_unt8 (q3);
      p391[i].coef[6] = random_unt8 (q3);
      p391[i].coef[7] = random_unt8 (q3);
    }
  s1 = slaw_m3unt8_array_raw (1122, &p392);
  s2 = slaw_m3unt8_array_empty (random_unt8 (q1));
  s3 = slaw_m3unt8_array_filled (random_unt8 (q1), p389);
  s4 = slaw_m3unt8_array (p391, 1122);
  TestAgainstPredicates (eSlawType_m3unt8_array, s1);
  TestAgainstPredicates (eSlawType_m3unt8_array, s2);
  TestAgainstPredicates (eSlawType_m3unt8_array, s3);
  TestAgainstPredicates (eSlawType_m3unt8_array, s4);
  n = sizeof (m3unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p390, i + slaw_m3unt8_array_emit (s3), sizeof (m3unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p392, p391, sizeof (p391));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3unt8_array_emit_nth (s3, i) != i + slaw_m3unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3unt8_arrays_concat (s3, s4, NULL);
  s = slaw_m3unt8_array_empty (0);
  s6 = slaw_m3unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3unt8_array_concat_carray (s3, p391, 1122);
  s8 = slaw_m3unt8_array_concat_carray_f (s3, p391, 1122);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3int16 p393;
  m3int16 p394;
  m3int16 p395[1782];
  m3int16 *p396;
  p393.coef[0] = random_int16 (q1);
  p393.coef[1] = random_int16 (q1);
  p393.coef[2] = random_int16 (q1);
  p393.coef[3] = random_int16 (q1);
  p393.coef[4] = random_int16 (q1);
  p393.coef[5] = random_int16 (q1);
  p393.coef[6] = random_int16 (q1);
  p393.coef[7] = random_int16 (q1);
  p394.coef[0] = random_int16 (q2);
  p394.coef[1] = random_int16 (q2);
  p394.coef[2] = random_int16 (q2);
  p394.coef[3] = random_int16 (q2);
  p394.coef[4] = random_int16 (q2);
  p394.coef[5] = random_int16 (q2);
  p394.coef[6] = random_int16 (q2);
  p394.coef[7] = random_int16 (q2);
  s = slaw_m3int16 (p393);
  TestAgainstPredicates (eSlawType_m3int16, s);
  if (memcmp (&p394, slaw_m3int16_emit (s), sizeof (m3int16)) != 0)
    error_exit ("compare failed for m3int16\n");
  if (memcmp (&p394, slaw_m3int16_emit_nocheck (s), sizeof (m3int16)) != 0)
    error_exit ("compare failed for m3int16\n");
  slaw_free (s);
  for (i = 0; i < 1782; i++)
    {
      p395[i].coef[0] = random_int16 (q3);
      p395[i].coef[1] = random_int16 (q3);
      p395[i].coef[2] = random_int16 (q3);
      p395[i].coef[3] = random_int16 (q3);
      p395[i].coef[4] = random_int16 (q3);
      p395[i].coef[5] = random_int16 (q3);
      p395[i].coef[6] = random_int16 (q3);
      p395[i].coef[7] = random_int16 (q3);
    }
  s1 = slaw_m3int16_array_raw (1782, &p396);
  s2 = slaw_m3int16_array_empty (random_unt8 (q1));
  s3 = slaw_m3int16_array_filled (random_unt8 (q1), p393);
  s4 = slaw_m3int16_array (p395, 1782);
  TestAgainstPredicates (eSlawType_m3int16_array, s1);
  TestAgainstPredicates (eSlawType_m3int16_array, s2);
  TestAgainstPredicates (eSlawType_m3int16_array, s3);
  TestAgainstPredicates (eSlawType_m3int16_array, s4);
  n = sizeof (m3int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p394, i + slaw_m3int16_array_emit (s3), sizeof (m3int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p396, p395, sizeof (p395));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3int16_array_emit_nth (s3, i)
          != i + slaw_m3int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3int16_arrays_concat (s3, s4, NULL);
  s = slaw_m3int16_array_empty (0);
  s6 = slaw_m3int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3int16_array_concat_carray (s3, p395, 1782);
  s8 = slaw_m3int16_array_concat_carray_f (s3, p395, 1782);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m3unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m3unt16 p397;
  m3unt16 p398;
  m3unt16 p399[727];
  m3unt16 *p400;
  p397.coef[0] = random_unt16 (q1);
  p397.coef[1] = random_unt16 (q1);
  p397.coef[2] = random_unt16 (q1);
  p397.coef[3] = random_unt16 (q1);
  p397.coef[4] = random_unt16 (q1);
  p397.coef[5] = random_unt16 (q1);
  p397.coef[6] = random_unt16 (q1);
  p397.coef[7] = random_unt16 (q1);
  p398.coef[0] = random_unt16 (q2);
  p398.coef[1] = random_unt16 (q2);
  p398.coef[2] = random_unt16 (q2);
  p398.coef[3] = random_unt16 (q2);
  p398.coef[4] = random_unt16 (q2);
  p398.coef[5] = random_unt16 (q2);
  p398.coef[6] = random_unt16 (q2);
  p398.coef[7] = random_unt16 (q2);
  s = slaw_m3unt16 (p397);
  TestAgainstPredicates (eSlawType_m3unt16, s);
  if (memcmp (&p398, slaw_m3unt16_emit (s), sizeof (m3unt16)) != 0)
    error_exit ("compare failed for m3unt16\n");
  if (memcmp (&p398, slaw_m3unt16_emit_nocheck (s), sizeof (m3unt16)) != 0)
    error_exit ("compare failed for m3unt16\n");
  slaw_free (s);
  for (i = 0; i < 727; i++)
    {
      p399[i].coef[0] = random_unt16 (q3);
      p399[i].coef[1] = random_unt16 (q3);
      p399[i].coef[2] = random_unt16 (q3);
      p399[i].coef[3] = random_unt16 (q3);
      p399[i].coef[4] = random_unt16 (q3);
      p399[i].coef[5] = random_unt16 (q3);
      p399[i].coef[6] = random_unt16 (q3);
      p399[i].coef[7] = random_unt16 (q3);
    }
  s1 = slaw_m3unt16_array_raw (727, &p400);
  s2 = slaw_m3unt16_array_empty (random_unt8 (q1));
  s3 = slaw_m3unt16_array_filled (random_unt8 (q1), p397);
  s4 = slaw_m3unt16_array (p399, 727);
  TestAgainstPredicates (eSlawType_m3unt16_array, s1);
  TestAgainstPredicates (eSlawType_m3unt16_array, s2);
  TestAgainstPredicates (eSlawType_m3unt16_array, s3);
  TestAgainstPredicates (eSlawType_m3unt16_array, s4);
  n = sizeof (m3unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m3unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p398, i + slaw_m3unt16_array_emit (s3), sizeof (m3unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p400, p399, sizeof (p399));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m3unt16_array_emit_nth (s3, i)
          != i + slaw_m3unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m3unt16_arrays_concat (s3, s4, NULL);
  s = slaw_m3unt16_array_empty (0);
  s6 = slaw_m3unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m3unt16_array_concat_carray (s3, p399, 727);
  s8 = slaw_m3unt16_array_concat_carray_f (s3, p399, 727);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4int32 p401;
  m4int32 p402;
  m4int32 p403[595];
  m4int32 *p404;
  p401.coef[0] = random_int32 (q1);
  p401.coef[1] = random_int32 (q1);
  p401.coef[2] = random_int32 (q1);
  p401.coef[3] = random_int32 (q1);
  p401.coef[4] = random_int32 (q1);
  p401.coef[5] = random_int32 (q1);
  p401.coef[6] = random_int32 (q1);
  p401.coef[7] = random_int32 (q1);
  p401.coef[8] = random_int32 (q1);
  p401.coef[9] = random_int32 (q1);
  p401.coef[10] = random_int32 (q1);
  p401.coef[11] = random_int32 (q1);
  p401.coef[12] = random_int32 (q1);
  p401.coef[13] = random_int32 (q1);
  p401.coef[14] = random_int32 (q1);
  p401.coef[15] = random_int32 (q1);
  p402.coef[0] = random_int32 (q2);
  p402.coef[1] = random_int32 (q2);
  p402.coef[2] = random_int32 (q2);
  p402.coef[3] = random_int32 (q2);
  p402.coef[4] = random_int32 (q2);
  p402.coef[5] = random_int32 (q2);
  p402.coef[6] = random_int32 (q2);
  p402.coef[7] = random_int32 (q2);
  p402.coef[8] = random_int32 (q2);
  p402.coef[9] = random_int32 (q2);
  p402.coef[10] = random_int32 (q2);
  p402.coef[11] = random_int32 (q2);
  p402.coef[12] = random_int32 (q2);
  p402.coef[13] = random_int32 (q2);
  p402.coef[14] = random_int32 (q2);
  p402.coef[15] = random_int32 (q2);
  s = slaw_m4int32 (p401);
  TestAgainstPredicates (eSlawType_m4int32, s);
  if (memcmp (&p402, slaw_m4int32_emit (s), sizeof (m4int32)) != 0)
    error_exit ("compare failed for m4int32\n");
  if (memcmp (&p402, slaw_m4int32_emit_nocheck (s), sizeof (m4int32)) != 0)
    error_exit ("compare failed for m4int32\n");
  slaw_free (s);
  for (i = 0; i < 595; i++)
    {
      p403[i].coef[0] = random_int32 (q3);
      p403[i].coef[1] = random_int32 (q3);
      p403[i].coef[2] = random_int32 (q3);
      p403[i].coef[3] = random_int32 (q3);
      p403[i].coef[4] = random_int32 (q3);
      p403[i].coef[5] = random_int32 (q3);
      p403[i].coef[6] = random_int32 (q3);
      p403[i].coef[7] = random_int32 (q3);
      p403[i].coef[8] = random_int32 (q3);
      p403[i].coef[9] = random_int32 (q3);
      p403[i].coef[10] = random_int32 (q3);
      p403[i].coef[11] = random_int32 (q3);
      p403[i].coef[12] = random_int32 (q3);
      p403[i].coef[13] = random_int32 (q3);
      p403[i].coef[14] = random_int32 (q3);
      p403[i].coef[15] = random_int32 (q3);
    }
  s1 = slaw_m4int32_array_raw (595, &p404);
  s2 = slaw_m4int32_array_empty (random_unt8 (q1));
  s3 = slaw_m4int32_array_filled (random_unt8 (q1), p401);
  s4 = slaw_m4int32_array (p403, 595);
  TestAgainstPredicates (eSlawType_m4int32_array, s1);
  TestAgainstPredicates (eSlawType_m4int32_array, s2);
  TestAgainstPredicates (eSlawType_m4int32_array, s3);
  TestAgainstPredicates (eSlawType_m4int32_array, s4);
  n = sizeof (m4int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p402, i + slaw_m4int32_array_emit (s3), sizeof (m4int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p404, p403, sizeof (p403));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4int32_array_emit_nth (s3, i)
          != i + slaw_m4int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4int32_arrays_concat (s3, s4, NULL);
  s = slaw_m4int32_array_empty (0);
  s6 = slaw_m4int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4int32_array_concat_carray (s3, p403, 595);
  s8 = slaw_m4int32_array_concat_carray_f (s3, p403, 595);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4unt32 p405;
  m4unt32 p406;
  m4unt32 p407[361];
  m4unt32 *p408;
  p405.coef[0] = random_unt32 (q1);
  p405.coef[1] = random_unt32 (q1);
  p405.coef[2] = random_unt32 (q1);
  p405.coef[3] = random_unt32 (q1);
  p405.coef[4] = random_unt32 (q1);
  p405.coef[5] = random_unt32 (q1);
  p405.coef[6] = random_unt32 (q1);
  p405.coef[7] = random_unt32 (q1);
  p405.coef[8] = random_unt32 (q1);
  p405.coef[9] = random_unt32 (q1);
  p405.coef[10] = random_unt32 (q1);
  p405.coef[11] = random_unt32 (q1);
  p405.coef[12] = random_unt32 (q1);
  p405.coef[13] = random_unt32 (q1);
  p405.coef[14] = random_unt32 (q1);
  p405.coef[15] = random_unt32 (q1);
  p406.coef[0] = random_unt32 (q2);
  p406.coef[1] = random_unt32 (q2);
  p406.coef[2] = random_unt32 (q2);
  p406.coef[3] = random_unt32 (q2);
  p406.coef[4] = random_unt32 (q2);
  p406.coef[5] = random_unt32 (q2);
  p406.coef[6] = random_unt32 (q2);
  p406.coef[7] = random_unt32 (q2);
  p406.coef[8] = random_unt32 (q2);
  p406.coef[9] = random_unt32 (q2);
  p406.coef[10] = random_unt32 (q2);
  p406.coef[11] = random_unt32 (q2);
  p406.coef[12] = random_unt32 (q2);
  p406.coef[13] = random_unt32 (q2);
  p406.coef[14] = random_unt32 (q2);
  p406.coef[15] = random_unt32 (q2);
  s = slaw_m4unt32 (p405);
  TestAgainstPredicates (eSlawType_m4unt32, s);
  if (memcmp (&p406, slaw_m4unt32_emit (s), sizeof (m4unt32)) != 0)
    error_exit ("compare failed for m4unt32\n");
  if (memcmp (&p406, slaw_m4unt32_emit_nocheck (s), sizeof (m4unt32)) != 0)
    error_exit ("compare failed for m4unt32\n");
  slaw_free (s);
  for (i = 0; i < 361; i++)
    {
      p407[i].coef[0] = random_unt32 (q3);
      p407[i].coef[1] = random_unt32 (q3);
      p407[i].coef[2] = random_unt32 (q3);
      p407[i].coef[3] = random_unt32 (q3);
      p407[i].coef[4] = random_unt32 (q3);
      p407[i].coef[5] = random_unt32 (q3);
      p407[i].coef[6] = random_unt32 (q3);
      p407[i].coef[7] = random_unt32 (q3);
      p407[i].coef[8] = random_unt32 (q3);
      p407[i].coef[9] = random_unt32 (q3);
      p407[i].coef[10] = random_unt32 (q3);
      p407[i].coef[11] = random_unt32 (q3);
      p407[i].coef[12] = random_unt32 (q3);
      p407[i].coef[13] = random_unt32 (q3);
      p407[i].coef[14] = random_unt32 (q3);
      p407[i].coef[15] = random_unt32 (q3);
    }
  s1 = slaw_m4unt32_array_raw (361, &p408);
  s2 = slaw_m4unt32_array_empty (random_unt8 (q1));
  s3 = slaw_m4unt32_array_filled (random_unt8 (q1), p405);
  s4 = slaw_m4unt32_array (p407, 361);
  TestAgainstPredicates (eSlawType_m4unt32_array, s1);
  TestAgainstPredicates (eSlawType_m4unt32_array, s2);
  TestAgainstPredicates (eSlawType_m4unt32_array, s3);
  TestAgainstPredicates (eSlawType_m4unt32_array, s4);
  n = sizeof (m4unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p406, i + slaw_m4unt32_array_emit (s3), sizeof (m4unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p408, p407, sizeof (p407));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4unt32_array_emit_nth (s3, i)
          != i + slaw_m4unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4unt32_arrays_concat (s3, s4, NULL);
  s = slaw_m4unt32_array_empty (0);
  s6 = slaw_m4unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4unt32_array_concat_carray (s3, p407, 361);
  s8 = slaw_m4unt32_array_concat_carray_f (s3, p407, 361);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4int64 p409;
  m4int64 p410;
  m4int64 p411[415];
  m4int64 *p412;
  p409.coef[0] = random_int64 (q1);
  p409.coef[1] = random_int64 (q1);
  p409.coef[2] = random_int64 (q1);
  p409.coef[3] = random_int64 (q1);
  p409.coef[4] = random_int64 (q1);
  p409.coef[5] = random_int64 (q1);
  p409.coef[6] = random_int64 (q1);
  p409.coef[7] = random_int64 (q1);
  p409.coef[8] = random_int64 (q1);
  p409.coef[9] = random_int64 (q1);
  p409.coef[10] = random_int64 (q1);
  p409.coef[11] = random_int64 (q1);
  p409.coef[12] = random_int64 (q1);
  p409.coef[13] = random_int64 (q1);
  p409.coef[14] = random_int64 (q1);
  p409.coef[15] = random_int64 (q1);
  p410.coef[0] = random_int64 (q2);
  p410.coef[1] = random_int64 (q2);
  p410.coef[2] = random_int64 (q2);
  p410.coef[3] = random_int64 (q2);
  p410.coef[4] = random_int64 (q2);
  p410.coef[5] = random_int64 (q2);
  p410.coef[6] = random_int64 (q2);
  p410.coef[7] = random_int64 (q2);
  p410.coef[8] = random_int64 (q2);
  p410.coef[9] = random_int64 (q2);
  p410.coef[10] = random_int64 (q2);
  p410.coef[11] = random_int64 (q2);
  p410.coef[12] = random_int64 (q2);
  p410.coef[13] = random_int64 (q2);
  p410.coef[14] = random_int64 (q2);
  p410.coef[15] = random_int64 (q2);
  s = slaw_m4int64 (p409);
  TestAgainstPredicates (eSlawType_m4int64, s);
  if (memcmp (&p410, slaw_m4int64_emit (s), sizeof (m4int64)) != 0)
    error_exit ("compare failed for m4int64\n");
  if (memcmp (&p410, slaw_m4int64_emit_nocheck (s), sizeof (m4int64)) != 0)
    error_exit ("compare failed for m4int64\n");
  slaw_free (s);
  for (i = 0; i < 415; i++)
    {
      p411[i].coef[0] = random_int64 (q3);
      p411[i].coef[1] = random_int64 (q3);
      p411[i].coef[2] = random_int64 (q3);
      p411[i].coef[3] = random_int64 (q3);
      p411[i].coef[4] = random_int64 (q3);
      p411[i].coef[5] = random_int64 (q3);
      p411[i].coef[6] = random_int64 (q3);
      p411[i].coef[7] = random_int64 (q3);
      p411[i].coef[8] = random_int64 (q3);
      p411[i].coef[9] = random_int64 (q3);
      p411[i].coef[10] = random_int64 (q3);
      p411[i].coef[11] = random_int64 (q3);
      p411[i].coef[12] = random_int64 (q3);
      p411[i].coef[13] = random_int64 (q3);
      p411[i].coef[14] = random_int64 (q3);
      p411[i].coef[15] = random_int64 (q3);
    }
  s1 = slaw_m4int64_array_raw (415, &p412);
  s2 = slaw_m4int64_array_empty (random_unt8 (q1));
  s3 = slaw_m4int64_array_filled (random_unt8 (q1), p409);
  s4 = slaw_m4int64_array (p411, 415);
  TestAgainstPredicates (eSlawType_m4int64_array, s1);
  TestAgainstPredicates (eSlawType_m4int64_array, s2);
  TestAgainstPredicates (eSlawType_m4int64_array, s3);
  TestAgainstPredicates (eSlawType_m4int64_array, s4);
  n = sizeof (m4int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p410, i + slaw_m4int64_array_emit (s3), sizeof (m4int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p412, p411, sizeof (p411));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4int64_array_emit_nth (s3, i)
          != i + slaw_m4int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4int64_arrays_concat (s3, s4, NULL);
  s = slaw_m4int64_array_empty (0);
  s6 = slaw_m4int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4int64_array_concat_carray (s3, p411, 415);
  s8 = slaw_m4int64_array_concat_carray_f (s3, p411, 415);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4unt64 p413;
  m4unt64 p414;
  m4unt64 p415[1812];
  m4unt64 *p416;
  p413.coef[0] = random_unt64 (q1);
  p413.coef[1] = random_unt64 (q1);
  p413.coef[2] = random_unt64 (q1);
  p413.coef[3] = random_unt64 (q1);
  p413.coef[4] = random_unt64 (q1);
  p413.coef[5] = random_unt64 (q1);
  p413.coef[6] = random_unt64 (q1);
  p413.coef[7] = random_unt64 (q1);
  p413.coef[8] = random_unt64 (q1);
  p413.coef[9] = random_unt64 (q1);
  p413.coef[10] = random_unt64 (q1);
  p413.coef[11] = random_unt64 (q1);
  p413.coef[12] = random_unt64 (q1);
  p413.coef[13] = random_unt64 (q1);
  p413.coef[14] = random_unt64 (q1);
  p413.coef[15] = random_unt64 (q1);
  p414.coef[0] = random_unt64 (q2);
  p414.coef[1] = random_unt64 (q2);
  p414.coef[2] = random_unt64 (q2);
  p414.coef[3] = random_unt64 (q2);
  p414.coef[4] = random_unt64 (q2);
  p414.coef[5] = random_unt64 (q2);
  p414.coef[6] = random_unt64 (q2);
  p414.coef[7] = random_unt64 (q2);
  p414.coef[8] = random_unt64 (q2);
  p414.coef[9] = random_unt64 (q2);
  p414.coef[10] = random_unt64 (q2);
  p414.coef[11] = random_unt64 (q2);
  p414.coef[12] = random_unt64 (q2);
  p414.coef[13] = random_unt64 (q2);
  p414.coef[14] = random_unt64 (q2);
  p414.coef[15] = random_unt64 (q2);
  s = slaw_m4unt64 (p413);
  TestAgainstPredicates (eSlawType_m4unt64, s);
  if (memcmp (&p414, slaw_m4unt64_emit (s), sizeof (m4unt64)) != 0)
    error_exit ("compare failed for m4unt64\n");
  if (memcmp (&p414, slaw_m4unt64_emit_nocheck (s), sizeof (m4unt64)) != 0)
    error_exit ("compare failed for m4unt64\n");
  slaw_free (s);
  for (i = 0; i < 1812; i++)
    {
      p415[i].coef[0] = random_unt64 (q3);
      p415[i].coef[1] = random_unt64 (q3);
      p415[i].coef[2] = random_unt64 (q3);
      p415[i].coef[3] = random_unt64 (q3);
      p415[i].coef[4] = random_unt64 (q3);
      p415[i].coef[5] = random_unt64 (q3);
      p415[i].coef[6] = random_unt64 (q3);
      p415[i].coef[7] = random_unt64 (q3);
      p415[i].coef[8] = random_unt64 (q3);
      p415[i].coef[9] = random_unt64 (q3);
      p415[i].coef[10] = random_unt64 (q3);
      p415[i].coef[11] = random_unt64 (q3);
      p415[i].coef[12] = random_unt64 (q3);
      p415[i].coef[13] = random_unt64 (q3);
      p415[i].coef[14] = random_unt64 (q3);
      p415[i].coef[15] = random_unt64 (q3);
    }
  s1 = slaw_m4unt64_array_raw (1812, &p416);
  s2 = slaw_m4unt64_array_empty (random_unt8 (q1));
  s3 = slaw_m4unt64_array_filled (random_unt8 (q1), p413);
  s4 = slaw_m4unt64_array (p415, 1812);
  TestAgainstPredicates (eSlawType_m4unt64_array, s1);
  TestAgainstPredicates (eSlawType_m4unt64_array, s2);
  TestAgainstPredicates (eSlawType_m4unt64_array, s3);
  TestAgainstPredicates (eSlawType_m4unt64_array, s4);
  n = sizeof (m4unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p414, i + slaw_m4unt64_array_emit (s3), sizeof (m4unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p416, p415, sizeof (p415));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4unt64_array_emit_nth (s3, i)
          != i + slaw_m4unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4unt64_arrays_concat (s3, s4, NULL);
  s = slaw_m4unt64_array_empty (0);
  s6 = slaw_m4unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4unt64_array_concat_carray (s3, p415, 1812);
  s8 = slaw_m4unt64_array_concat_carray_f (s3, p415, 1812);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4float32 p417;
  m4float32 p418;
  m4float32 p419[1748];
  m4float32 *p420;
  p417.coef[0] = random_float32 (q1);
  p417.coef[1] = random_float32 (q1);
  p417.coef[2] = random_float32 (q1);
  p417.coef[3] = random_float32 (q1);
  p417.coef[4] = random_float32 (q1);
  p417.coef[5] = random_float32 (q1);
  p417.coef[6] = random_float32 (q1);
  p417.coef[7] = random_float32 (q1);
  p417.coef[8] = random_float32 (q1);
  p417.coef[9] = random_float32 (q1);
  p417.coef[10] = random_float32 (q1);
  p417.coef[11] = random_float32 (q1);
  p417.coef[12] = random_float32 (q1);
  p417.coef[13] = random_float32 (q1);
  p417.coef[14] = random_float32 (q1);
  p417.coef[15] = random_float32 (q1);
  p418.coef[0] = random_float32 (q2);
  p418.coef[1] = random_float32 (q2);
  p418.coef[2] = random_float32 (q2);
  p418.coef[3] = random_float32 (q2);
  p418.coef[4] = random_float32 (q2);
  p418.coef[5] = random_float32 (q2);
  p418.coef[6] = random_float32 (q2);
  p418.coef[7] = random_float32 (q2);
  p418.coef[8] = random_float32 (q2);
  p418.coef[9] = random_float32 (q2);
  p418.coef[10] = random_float32 (q2);
  p418.coef[11] = random_float32 (q2);
  p418.coef[12] = random_float32 (q2);
  p418.coef[13] = random_float32 (q2);
  p418.coef[14] = random_float32 (q2);
  p418.coef[15] = random_float32 (q2);
  s = slaw_m4float32 (p417);
  TestAgainstPredicates (eSlawType_m4float32, s);
  if (memcmp (&p418, slaw_m4float32_emit (s), sizeof (m4float32)) != 0)
    error_exit ("compare failed for m4float32\n");
  if (memcmp (&p418, slaw_m4float32_emit_nocheck (s), sizeof (m4float32)) != 0)
    error_exit ("compare failed for m4float32\n");
  slaw_free (s);
  for (i = 0; i < 1748; i++)
    {
      p419[i].coef[0] = random_float32 (q3);
      p419[i].coef[1] = random_float32 (q3);
      p419[i].coef[2] = random_float32 (q3);
      p419[i].coef[3] = random_float32 (q3);
      p419[i].coef[4] = random_float32 (q3);
      p419[i].coef[5] = random_float32 (q3);
      p419[i].coef[6] = random_float32 (q3);
      p419[i].coef[7] = random_float32 (q3);
      p419[i].coef[8] = random_float32 (q3);
      p419[i].coef[9] = random_float32 (q3);
      p419[i].coef[10] = random_float32 (q3);
      p419[i].coef[11] = random_float32 (q3);
      p419[i].coef[12] = random_float32 (q3);
      p419[i].coef[13] = random_float32 (q3);
      p419[i].coef[14] = random_float32 (q3);
      p419[i].coef[15] = random_float32 (q3);
    }
  s1 = slaw_m4float32_array_raw (1748, &p420);
  s2 = slaw_m4float32_array_empty (random_unt8 (q1));
  s3 = slaw_m4float32_array_filled (random_unt8 (q1), p417);
  s4 = slaw_m4float32_array (p419, 1748);
  TestAgainstPredicates (eSlawType_m4float32_array, s1);
  TestAgainstPredicates (eSlawType_m4float32_array, s2);
  TestAgainstPredicates (eSlawType_m4float32_array, s3);
  TestAgainstPredicates (eSlawType_m4float32_array, s4);
  n = sizeof (m4float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p418, i + slaw_m4float32_array_emit (s3), sizeof (m4float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p420, p419, sizeof (p419));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4float32_array_emit_nth (s3, i)
          != i + slaw_m4float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4float32_arrays_concat (s3, s4, NULL);
  s = slaw_m4float32_array_empty (0);
  s6 = slaw_m4float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4float32_array_concat_carray (s3, p419, 1748);
  s8 = slaw_m4float32_array_concat_carray_f (s3, p419, 1748);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4float64 p421;
  m4float64 p422;
  m4float64 p423[158];
  m4float64 *p424;
  p421.coef[0] = random_float64 (q1);
  p421.coef[1] = random_float64 (q1);
  p421.coef[2] = random_float64 (q1);
  p421.coef[3] = random_float64 (q1);
  p421.coef[4] = random_float64 (q1);
  p421.coef[5] = random_float64 (q1);
  p421.coef[6] = random_float64 (q1);
  p421.coef[7] = random_float64 (q1);
  p421.coef[8] = random_float64 (q1);
  p421.coef[9] = random_float64 (q1);
  p421.coef[10] = random_float64 (q1);
  p421.coef[11] = random_float64 (q1);
  p421.coef[12] = random_float64 (q1);
  p421.coef[13] = random_float64 (q1);
  p421.coef[14] = random_float64 (q1);
  p421.coef[15] = random_float64 (q1);
  p422.coef[0] = random_float64 (q2);
  p422.coef[1] = random_float64 (q2);
  p422.coef[2] = random_float64 (q2);
  p422.coef[3] = random_float64 (q2);
  p422.coef[4] = random_float64 (q2);
  p422.coef[5] = random_float64 (q2);
  p422.coef[6] = random_float64 (q2);
  p422.coef[7] = random_float64 (q2);
  p422.coef[8] = random_float64 (q2);
  p422.coef[9] = random_float64 (q2);
  p422.coef[10] = random_float64 (q2);
  p422.coef[11] = random_float64 (q2);
  p422.coef[12] = random_float64 (q2);
  p422.coef[13] = random_float64 (q2);
  p422.coef[14] = random_float64 (q2);
  p422.coef[15] = random_float64 (q2);
  s = slaw_m4float64 (p421);
  TestAgainstPredicates (eSlawType_m4float64, s);
  if (memcmp (&p422, slaw_m4float64_emit (s), sizeof (m4float64)) != 0)
    error_exit ("compare failed for m4float64\n");
  if (memcmp (&p422, slaw_m4float64_emit_nocheck (s), sizeof (m4float64)) != 0)
    error_exit ("compare failed for m4float64\n");
  slaw_free (s);
  for (i = 0; i < 158; i++)
    {
      p423[i].coef[0] = random_float64 (q3);
      p423[i].coef[1] = random_float64 (q3);
      p423[i].coef[2] = random_float64 (q3);
      p423[i].coef[3] = random_float64 (q3);
      p423[i].coef[4] = random_float64 (q3);
      p423[i].coef[5] = random_float64 (q3);
      p423[i].coef[6] = random_float64 (q3);
      p423[i].coef[7] = random_float64 (q3);
      p423[i].coef[8] = random_float64 (q3);
      p423[i].coef[9] = random_float64 (q3);
      p423[i].coef[10] = random_float64 (q3);
      p423[i].coef[11] = random_float64 (q3);
      p423[i].coef[12] = random_float64 (q3);
      p423[i].coef[13] = random_float64 (q3);
      p423[i].coef[14] = random_float64 (q3);
      p423[i].coef[15] = random_float64 (q3);
    }
  s1 = slaw_m4float64_array_raw (158, &p424);
  s2 = slaw_m4float64_array_empty (random_unt8 (q1));
  s3 = slaw_m4float64_array_filled (random_unt8 (q1), p421);
  s4 = slaw_m4float64_array (p423, 158);
  TestAgainstPredicates (eSlawType_m4float64_array, s1);
  TestAgainstPredicates (eSlawType_m4float64_array, s2);
  TestAgainstPredicates (eSlawType_m4float64_array, s3);
  TestAgainstPredicates (eSlawType_m4float64_array, s4);
  n = sizeof (m4float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p422, i + slaw_m4float64_array_emit (s3), sizeof (m4float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p424, p423, sizeof (p423));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4float64_array_emit_nth (s3, i)
          != i + slaw_m4float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4float64_arrays_concat (s3, s4, NULL);
  s = slaw_m4float64_array_empty (0);
  s6 = slaw_m4float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4float64_array_concat_carray (s3, p423, 158);
  s8 = slaw_m4float64_array_concat_carray_f (s3, p423, 158);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4int8 p425;
  m4int8 p426;
  m4int8 p427[417];
  m4int8 *p428;
  p425.coef[0] = random_int8 (q1);
  p425.coef[1] = random_int8 (q1);
  p425.coef[2] = random_int8 (q1);
  p425.coef[3] = random_int8 (q1);
  p425.coef[4] = random_int8 (q1);
  p425.coef[5] = random_int8 (q1);
  p425.coef[6] = random_int8 (q1);
  p425.coef[7] = random_int8 (q1);
  p425.coef[8] = random_int8 (q1);
  p425.coef[9] = random_int8 (q1);
  p425.coef[10] = random_int8 (q1);
  p425.coef[11] = random_int8 (q1);
  p425.coef[12] = random_int8 (q1);
  p425.coef[13] = random_int8 (q1);
  p425.coef[14] = random_int8 (q1);
  p425.coef[15] = random_int8 (q1);
  p426.coef[0] = random_int8 (q2);
  p426.coef[1] = random_int8 (q2);
  p426.coef[2] = random_int8 (q2);
  p426.coef[3] = random_int8 (q2);
  p426.coef[4] = random_int8 (q2);
  p426.coef[5] = random_int8 (q2);
  p426.coef[6] = random_int8 (q2);
  p426.coef[7] = random_int8 (q2);
  p426.coef[8] = random_int8 (q2);
  p426.coef[9] = random_int8 (q2);
  p426.coef[10] = random_int8 (q2);
  p426.coef[11] = random_int8 (q2);
  p426.coef[12] = random_int8 (q2);
  p426.coef[13] = random_int8 (q2);
  p426.coef[14] = random_int8 (q2);
  p426.coef[15] = random_int8 (q2);
  s = slaw_m4int8 (p425);
  TestAgainstPredicates (eSlawType_m4int8, s);
  if (memcmp (&p426, slaw_m4int8_emit (s), sizeof (m4int8)) != 0)
    error_exit ("compare failed for m4int8\n");
  if (memcmp (&p426, slaw_m4int8_emit_nocheck (s), sizeof (m4int8)) != 0)
    error_exit ("compare failed for m4int8\n");
  slaw_free (s);
  for (i = 0; i < 417; i++)
    {
      p427[i].coef[0] = random_int8 (q3);
      p427[i].coef[1] = random_int8 (q3);
      p427[i].coef[2] = random_int8 (q3);
      p427[i].coef[3] = random_int8 (q3);
      p427[i].coef[4] = random_int8 (q3);
      p427[i].coef[5] = random_int8 (q3);
      p427[i].coef[6] = random_int8 (q3);
      p427[i].coef[7] = random_int8 (q3);
      p427[i].coef[8] = random_int8 (q3);
      p427[i].coef[9] = random_int8 (q3);
      p427[i].coef[10] = random_int8 (q3);
      p427[i].coef[11] = random_int8 (q3);
      p427[i].coef[12] = random_int8 (q3);
      p427[i].coef[13] = random_int8 (q3);
      p427[i].coef[14] = random_int8 (q3);
      p427[i].coef[15] = random_int8 (q3);
    }
  s1 = slaw_m4int8_array_raw (417, &p428);
  s2 = slaw_m4int8_array_empty (random_unt8 (q1));
  s3 = slaw_m4int8_array_filled (random_unt8 (q1), p425);
  s4 = slaw_m4int8_array (p427, 417);
  TestAgainstPredicates (eSlawType_m4int8_array, s1);
  TestAgainstPredicates (eSlawType_m4int8_array, s2);
  TestAgainstPredicates (eSlawType_m4int8_array, s3);
  TestAgainstPredicates (eSlawType_m4int8_array, s4);
  n = sizeof (m4int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p426, i + slaw_m4int8_array_emit (s3), sizeof (m4int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p428, p427, sizeof (p427));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4int8_array_emit_nth (s3, i) != i + slaw_m4int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4int8_arrays_concat (s3, s4, NULL);
  s = slaw_m4int8_array_empty (0);
  s6 = slaw_m4int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4int8_array_concat_carray (s3, p427, 417);
  s8 = slaw_m4int8_array_concat_carray_f (s3, p427, 417);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4unt8 p429;
  m4unt8 p430;
  m4unt8 p431[119];
  m4unt8 *p432;
  p429.coef[0] = random_unt8 (q1);
  p429.coef[1] = random_unt8 (q1);
  p429.coef[2] = random_unt8 (q1);
  p429.coef[3] = random_unt8 (q1);
  p429.coef[4] = random_unt8 (q1);
  p429.coef[5] = random_unt8 (q1);
  p429.coef[6] = random_unt8 (q1);
  p429.coef[7] = random_unt8 (q1);
  p429.coef[8] = random_unt8 (q1);
  p429.coef[9] = random_unt8 (q1);
  p429.coef[10] = random_unt8 (q1);
  p429.coef[11] = random_unt8 (q1);
  p429.coef[12] = random_unt8 (q1);
  p429.coef[13] = random_unt8 (q1);
  p429.coef[14] = random_unt8 (q1);
  p429.coef[15] = random_unt8 (q1);
  p430.coef[0] = random_unt8 (q2);
  p430.coef[1] = random_unt8 (q2);
  p430.coef[2] = random_unt8 (q2);
  p430.coef[3] = random_unt8 (q2);
  p430.coef[4] = random_unt8 (q2);
  p430.coef[5] = random_unt8 (q2);
  p430.coef[6] = random_unt8 (q2);
  p430.coef[7] = random_unt8 (q2);
  p430.coef[8] = random_unt8 (q2);
  p430.coef[9] = random_unt8 (q2);
  p430.coef[10] = random_unt8 (q2);
  p430.coef[11] = random_unt8 (q2);
  p430.coef[12] = random_unt8 (q2);
  p430.coef[13] = random_unt8 (q2);
  p430.coef[14] = random_unt8 (q2);
  p430.coef[15] = random_unt8 (q2);
  s = slaw_m4unt8 (p429);
  TestAgainstPredicates (eSlawType_m4unt8, s);
  if (memcmp (&p430, slaw_m4unt8_emit (s), sizeof (m4unt8)) != 0)
    error_exit ("compare failed for m4unt8\n");
  if (memcmp (&p430, slaw_m4unt8_emit_nocheck (s), sizeof (m4unt8)) != 0)
    error_exit ("compare failed for m4unt8\n");
  slaw_free (s);
  for (i = 0; i < 119; i++)
    {
      p431[i].coef[0] = random_unt8 (q3);
      p431[i].coef[1] = random_unt8 (q3);
      p431[i].coef[2] = random_unt8 (q3);
      p431[i].coef[3] = random_unt8 (q3);
      p431[i].coef[4] = random_unt8 (q3);
      p431[i].coef[5] = random_unt8 (q3);
      p431[i].coef[6] = random_unt8 (q3);
      p431[i].coef[7] = random_unt8 (q3);
      p431[i].coef[8] = random_unt8 (q3);
      p431[i].coef[9] = random_unt8 (q3);
      p431[i].coef[10] = random_unt8 (q3);
      p431[i].coef[11] = random_unt8 (q3);
      p431[i].coef[12] = random_unt8 (q3);
      p431[i].coef[13] = random_unt8 (q3);
      p431[i].coef[14] = random_unt8 (q3);
      p431[i].coef[15] = random_unt8 (q3);
    }
  s1 = slaw_m4unt8_array_raw (119, &p432);
  s2 = slaw_m4unt8_array_empty (random_unt8 (q1));
  s3 = slaw_m4unt8_array_filled (random_unt8 (q1), p429);
  s4 = slaw_m4unt8_array (p431, 119);
  TestAgainstPredicates (eSlawType_m4unt8_array, s1);
  TestAgainstPredicates (eSlawType_m4unt8_array, s2);
  TestAgainstPredicates (eSlawType_m4unt8_array, s3);
  TestAgainstPredicates (eSlawType_m4unt8_array, s4);
  n = sizeof (m4unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p430, i + slaw_m4unt8_array_emit (s3), sizeof (m4unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p432, p431, sizeof (p431));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4unt8_array_emit_nth (s3, i) != i + slaw_m4unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4unt8_arrays_concat (s3, s4, NULL);
  s = slaw_m4unt8_array_empty (0);
  s6 = slaw_m4unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4unt8_array_concat_carray (s3, p431, 119);
  s8 = slaw_m4unt8_array_concat_carray_f (s3, p431, 119);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4int16 p433;
  m4int16 p434;
  m4int16 p435[114];
  m4int16 *p436;
  p433.coef[0] = random_int16 (q1);
  p433.coef[1] = random_int16 (q1);
  p433.coef[2] = random_int16 (q1);
  p433.coef[3] = random_int16 (q1);
  p433.coef[4] = random_int16 (q1);
  p433.coef[5] = random_int16 (q1);
  p433.coef[6] = random_int16 (q1);
  p433.coef[7] = random_int16 (q1);
  p433.coef[8] = random_int16 (q1);
  p433.coef[9] = random_int16 (q1);
  p433.coef[10] = random_int16 (q1);
  p433.coef[11] = random_int16 (q1);
  p433.coef[12] = random_int16 (q1);
  p433.coef[13] = random_int16 (q1);
  p433.coef[14] = random_int16 (q1);
  p433.coef[15] = random_int16 (q1);
  p434.coef[0] = random_int16 (q2);
  p434.coef[1] = random_int16 (q2);
  p434.coef[2] = random_int16 (q2);
  p434.coef[3] = random_int16 (q2);
  p434.coef[4] = random_int16 (q2);
  p434.coef[5] = random_int16 (q2);
  p434.coef[6] = random_int16 (q2);
  p434.coef[7] = random_int16 (q2);
  p434.coef[8] = random_int16 (q2);
  p434.coef[9] = random_int16 (q2);
  p434.coef[10] = random_int16 (q2);
  p434.coef[11] = random_int16 (q2);
  p434.coef[12] = random_int16 (q2);
  p434.coef[13] = random_int16 (q2);
  p434.coef[14] = random_int16 (q2);
  p434.coef[15] = random_int16 (q2);
  s = slaw_m4int16 (p433);
  TestAgainstPredicates (eSlawType_m4int16, s);
  if (memcmp (&p434, slaw_m4int16_emit (s), sizeof (m4int16)) != 0)
    error_exit ("compare failed for m4int16\n");
  if (memcmp (&p434, slaw_m4int16_emit_nocheck (s), sizeof (m4int16)) != 0)
    error_exit ("compare failed for m4int16\n");
  slaw_free (s);
  for (i = 0; i < 114; i++)
    {
      p435[i].coef[0] = random_int16 (q3);
      p435[i].coef[1] = random_int16 (q3);
      p435[i].coef[2] = random_int16 (q3);
      p435[i].coef[3] = random_int16 (q3);
      p435[i].coef[4] = random_int16 (q3);
      p435[i].coef[5] = random_int16 (q3);
      p435[i].coef[6] = random_int16 (q3);
      p435[i].coef[7] = random_int16 (q3);
      p435[i].coef[8] = random_int16 (q3);
      p435[i].coef[9] = random_int16 (q3);
      p435[i].coef[10] = random_int16 (q3);
      p435[i].coef[11] = random_int16 (q3);
      p435[i].coef[12] = random_int16 (q3);
      p435[i].coef[13] = random_int16 (q3);
      p435[i].coef[14] = random_int16 (q3);
      p435[i].coef[15] = random_int16 (q3);
    }
  s1 = slaw_m4int16_array_raw (114, &p436);
  s2 = slaw_m4int16_array_empty (random_unt8 (q1));
  s3 = slaw_m4int16_array_filled (random_unt8 (q1), p433);
  s4 = slaw_m4int16_array (p435, 114);
  TestAgainstPredicates (eSlawType_m4int16_array, s1);
  TestAgainstPredicates (eSlawType_m4int16_array, s2);
  TestAgainstPredicates (eSlawType_m4int16_array, s3);
  TestAgainstPredicates (eSlawType_m4int16_array, s4);
  n = sizeof (m4int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p434, i + slaw_m4int16_array_emit (s3), sizeof (m4int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p436, p435, sizeof (p435));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4int16_array_emit_nth (s3, i)
          != i + slaw_m4int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4int16_arrays_concat (s3, s4, NULL);
  s = slaw_m4int16_array_empty (0);
  s6 = slaw_m4int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4int16_array_concat_carray (s3, p435, 114);
  s8 = slaw_m4int16_array_concat_carray_f (s3, p435, 114);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m4unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m4unt16 p437;
  m4unt16 p438;
  m4unt16 p439[1041];
  m4unt16 *p440;
  p437.coef[0] = random_unt16 (q1);
  p437.coef[1] = random_unt16 (q1);
  p437.coef[2] = random_unt16 (q1);
  p437.coef[3] = random_unt16 (q1);
  p437.coef[4] = random_unt16 (q1);
  p437.coef[5] = random_unt16 (q1);
  p437.coef[6] = random_unt16 (q1);
  p437.coef[7] = random_unt16 (q1);
  p437.coef[8] = random_unt16 (q1);
  p437.coef[9] = random_unt16 (q1);
  p437.coef[10] = random_unt16 (q1);
  p437.coef[11] = random_unt16 (q1);
  p437.coef[12] = random_unt16 (q1);
  p437.coef[13] = random_unt16 (q1);
  p437.coef[14] = random_unt16 (q1);
  p437.coef[15] = random_unt16 (q1);
  p438.coef[0] = random_unt16 (q2);
  p438.coef[1] = random_unt16 (q2);
  p438.coef[2] = random_unt16 (q2);
  p438.coef[3] = random_unt16 (q2);
  p438.coef[4] = random_unt16 (q2);
  p438.coef[5] = random_unt16 (q2);
  p438.coef[6] = random_unt16 (q2);
  p438.coef[7] = random_unt16 (q2);
  p438.coef[8] = random_unt16 (q2);
  p438.coef[9] = random_unt16 (q2);
  p438.coef[10] = random_unt16 (q2);
  p438.coef[11] = random_unt16 (q2);
  p438.coef[12] = random_unt16 (q2);
  p438.coef[13] = random_unt16 (q2);
  p438.coef[14] = random_unt16 (q2);
  p438.coef[15] = random_unt16 (q2);
  s = slaw_m4unt16 (p437);
  TestAgainstPredicates (eSlawType_m4unt16, s);
  if (memcmp (&p438, slaw_m4unt16_emit (s), sizeof (m4unt16)) != 0)
    error_exit ("compare failed for m4unt16\n");
  if (memcmp (&p438, slaw_m4unt16_emit_nocheck (s), sizeof (m4unt16)) != 0)
    error_exit ("compare failed for m4unt16\n");
  slaw_free (s);
  for (i = 0; i < 1041; i++)
    {
      p439[i].coef[0] = random_unt16 (q3);
      p439[i].coef[1] = random_unt16 (q3);
      p439[i].coef[2] = random_unt16 (q3);
      p439[i].coef[3] = random_unt16 (q3);
      p439[i].coef[4] = random_unt16 (q3);
      p439[i].coef[5] = random_unt16 (q3);
      p439[i].coef[6] = random_unt16 (q3);
      p439[i].coef[7] = random_unt16 (q3);
      p439[i].coef[8] = random_unt16 (q3);
      p439[i].coef[9] = random_unt16 (q3);
      p439[i].coef[10] = random_unt16 (q3);
      p439[i].coef[11] = random_unt16 (q3);
      p439[i].coef[12] = random_unt16 (q3);
      p439[i].coef[13] = random_unt16 (q3);
      p439[i].coef[14] = random_unt16 (q3);
      p439[i].coef[15] = random_unt16 (q3);
    }
  s1 = slaw_m4unt16_array_raw (1041, &p440);
  s2 = slaw_m4unt16_array_empty (random_unt8 (q1));
  s3 = slaw_m4unt16_array_filled (random_unt8 (q1), p437);
  s4 = slaw_m4unt16_array (p439, 1041);
  TestAgainstPredicates (eSlawType_m4unt16_array, s1);
  TestAgainstPredicates (eSlawType_m4unt16_array, s2);
  TestAgainstPredicates (eSlawType_m4unt16_array, s3);
  TestAgainstPredicates (eSlawType_m4unt16_array, s4);
  n = sizeof (m4unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m4unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p438, i + slaw_m4unt16_array_emit (s3), sizeof (m4unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p440, p439, sizeof (p439));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m4unt16_array_emit_nth (s3, i)
          != i + slaw_m4unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m4unt16_arrays_concat (s3, s4, NULL);
  s = slaw_m4unt16_array_empty (0);
  s6 = slaw_m4unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m4unt16_array_concat_carray (s3, p439, 1041);
  s8 = slaw_m4unt16_array_concat_carray_f (s3, p439, 1041);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5int32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5int32 p441;
  m5int32 p442;
  m5int32 p443[746];
  m5int32 *p444;
  p441.coef[0] = random_int32 (q1);
  p441.coef[1] = random_int32 (q1);
  p441.coef[2] = random_int32 (q1);
  p441.coef[3] = random_int32 (q1);
  p441.coef[4] = random_int32 (q1);
  p441.coef[5] = random_int32 (q1);
  p441.coef[6] = random_int32 (q1);
  p441.coef[7] = random_int32 (q1);
  p441.coef[8] = random_int32 (q1);
  p441.coef[9] = random_int32 (q1);
  p441.coef[10] = random_int32 (q1);
  p441.coef[11] = random_int32 (q1);
  p441.coef[12] = random_int32 (q1);
  p441.coef[13] = random_int32 (q1);
  p441.coef[14] = random_int32 (q1);
  p441.coef[15] = random_int32 (q1);
  p441.coef[16] = random_int32 (q1);
  p441.coef[17] = random_int32 (q1);
  p441.coef[18] = random_int32 (q1);
  p441.coef[19] = random_int32 (q1);
  p441.coef[20] = random_int32 (q1);
  p441.coef[21] = random_int32 (q1);
  p441.coef[22] = random_int32 (q1);
  p441.coef[23] = random_int32 (q1);
  p441.coef[24] = random_int32 (q1);
  p441.coef[25] = random_int32 (q1);
  p441.coef[26] = random_int32 (q1);
  p441.coef[27] = random_int32 (q1);
  p441.coef[28] = random_int32 (q1);
  p441.coef[29] = random_int32 (q1);
  p441.coef[30] = random_int32 (q1);
  p441.coef[31] = random_int32 (q1);
  p442.coef[0] = random_int32 (q2);
  p442.coef[1] = random_int32 (q2);
  p442.coef[2] = random_int32 (q2);
  p442.coef[3] = random_int32 (q2);
  p442.coef[4] = random_int32 (q2);
  p442.coef[5] = random_int32 (q2);
  p442.coef[6] = random_int32 (q2);
  p442.coef[7] = random_int32 (q2);
  p442.coef[8] = random_int32 (q2);
  p442.coef[9] = random_int32 (q2);
  p442.coef[10] = random_int32 (q2);
  p442.coef[11] = random_int32 (q2);
  p442.coef[12] = random_int32 (q2);
  p442.coef[13] = random_int32 (q2);
  p442.coef[14] = random_int32 (q2);
  p442.coef[15] = random_int32 (q2);
  p442.coef[16] = random_int32 (q2);
  p442.coef[17] = random_int32 (q2);
  p442.coef[18] = random_int32 (q2);
  p442.coef[19] = random_int32 (q2);
  p442.coef[20] = random_int32 (q2);
  p442.coef[21] = random_int32 (q2);
  p442.coef[22] = random_int32 (q2);
  p442.coef[23] = random_int32 (q2);
  p442.coef[24] = random_int32 (q2);
  p442.coef[25] = random_int32 (q2);
  p442.coef[26] = random_int32 (q2);
  p442.coef[27] = random_int32 (q2);
  p442.coef[28] = random_int32 (q2);
  p442.coef[29] = random_int32 (q2);
  p442.coef[30] = random_int32 (q2);
  p442.coef[31] = random_int32 (q2);
  s = slaw_m5int32 (p441);
  TestAgainstPredicates (eSlawType_m5int32, s);
  if (memcmp (&p442, slaw_m5int32_emit (s), sizeof (m5int32)) != 0)
    error_exit ("compare failed for m5int32\n");
  if (memcmp (&p442, slaw_m5int32_emit_nocheck (s), sizeof (m5int32)) != 0)
    error_exit ("compare failed for m5int32\n");
  slaw_free (s);
  for (i = 0; i < 746; i++)
    {
      p443[i].coef[0] = random_int32 (q3);
      p443[i].coef[1] = random_int32 (q3);
      p443[i].coef[2] = random_int32 (q3);
      p443[i].coef[3] = random_int32 (q3);
      p443[i].coef[4] = random_int32 (q3);
      p443[i].coef[5] = random_int32 (q3);
      p443[i].coef[6] = random_int32 (q3);
      p443[i].coef[7] = random_int32 (q3);
      p443[i].coef[8] = random_int32 (q3);
      p443[i].coef[9] = random_int32 (q3);
      p443[i].coef[10] = random_int32 (q3);
      p443[i].coef[11] = random_int32 (q3);
      p443[i].coef[12] = random_int32 (q3);
      p443[i].coef[13] = random_int32 (q3);
      p443[i].coef[14] = random_int32 (q3);
      p443[i].coef[15] = random_int32 (q3);
      p443[i].coef[16] = random_int32 (q3);
      p443[i].coef[17] = random_int32 (q3);
      p443[i].coef[18] = random_int32 (q3);
      p443[i].coef[19] = random_int32 (q3);
      p443[i].coef[20] = random_int32 (q3);
      p443[i].coef[21] = random_int32 (q3);
      p443[i].coef[22] = random_int32 (q3);
      p443[i].coef[23] = random_int32 (q3);
      p443[i].coef[24] = random_int32 (q3);
      p443[i].coef[25] = random_int32 (q3);
      p443[i].coef[26] = random_int32 (q3);
      p443[i].coef[27] = random_int32 (q3);
      p443[i].coef[28] = random_int32 (q3);
      p443[i].coef[29] = random_int32 (q3);
      p443[i].coef[30] = random_int32 (q3);
      p443[i].coef[31] = random_int32 (q3);
    }
  s1 = slaw_m5int32_array_raw (746, &p444);
  s2 = slaw_m5int32_array_empty (random_unt8 (q1));
  s3 = slaw_m5int32_array_filled (random_unt8 (q1), p441);
  s4 = slaw_m5int32_array (p443, 746);
  TestAgainstPredicates (eSlawType_m5int32_array, s1);
  TestAgainstPredicates (eSlawType_m5int32_array, s2);
  TestAgainstPredicates (eSlawType_m5int32_array, s3);
  TestAgainstPredicates (eSlawType_m5int32_array, s4);
  n = sizeof (m5int32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5int32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p442, i + slaw_m5int32_array_emit (s3), sizeof (m5int32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p444, p443, sizeof (p443));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5int32_array_emit_nth (s3, i)
          != i + slaw_m5int32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5int32_arrays_concat (s3, s4, NULL);
  s = slaw_m5int32_array_empty (0);
  s6 = slaw_m5int32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5int32_array_concat_carray (s3, p443, 746);
  s8 = slaw_m5int32_array_concat_carray_f (s3, p443, 746);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5unt32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5unt32 p445;
  m5unt32 p446;
  m5unt32 p447[1078];
  m5unt32 *p448;
  p445.coef[0] = random_unt32 (q1);
  p445.coef[1] = random_unt32 (q1);
  p445.coef[2] = random_unt32 (q1);
  p445.coef[3] = random_unt32 (q1);
  p445.coef[4] = random_unt32 (q1);
  p445.coef[5] = random_unt32 (q1);
  p445.coef[6] = random_unt32 (q1);
  p445.coef[7] = random_unt32 (q1);
  p445.coef[8] = random_unt32 (q1);
  p445.coef[9] = random_unt32 (q1);
  p445.coef[10] = random_unt32 (q1);
  p445.coef[11] = random_unt32 (q1);
  p445.coef[12] = random_unt32 (q1);
  p445.coef[13] = random_unt32 (q1);
  p445.coef[14] = random_unt32 (q1);
  p445.coef[15] = random_unt32 (q1);
  p445.coef[16] = random_unt32 (q1);
  p445.coef[17] = random_unt32 (q1);
  p445.coef[18] = random_unt32 (q1);
  p445.coef[19] = random_unt32 (q1);
  p445.coef[20] = random_unt32 (q1);
  p445.coef[21] = random_unt32 (q1);
  p445.coef[22] = random_unt32 (q1);
  p445.coef[23] = random_unt32 (q1);
  p445.coef[24] = random_unt32 (q1);
  p445.coef[25] = random_unt32 (q1);
  p445.coef[26] = random_unt32 (q1);
  p445.coef[27] = random_unt32 (q1);
  p445.coef[28] = random_unt32 (q1);
  p445.coef[29] = random_unt32 (q1);
  p445.coef[30] = random_unt32 (q1);
  p445.coef[31] = random_unt32 (q1);
  p446.coef[0] = random_unt32 (q2);
  p446.coef[1] = random_unt32 (q2);
  p446.coef[2] = random_unt32 (q2);
  p446.coef[3] = random_unt32 (q2);
  p446.coef[4] = random_unt32 (q2);
  p446.coef[5] = random_unt32 (q2);
  p446.coef[6] = random_unt32 (q2);
  p446.coef[7] = random_unt32 (q2);
  p446.coef[8] = random_unt32 (q2);
  p446.coef[9] = random_unt32 (q2);
  p446.coef[10] = random_unt32 (q2);
  p446.coef[11] = random_unt32 (q2);
  p446.coef[12] = random_unt32 (q2);
  p446.coef[13] = random_unt32 (q2);
  p446.coef[14] = random_unt32 (q2);
  p446.coef[15] = random_unt32 (q2);
  p446.coef[16] = random_unt32 (q2);
  p446.coef[17] = random_unt32 (q2);
  p446.coef[18] = random_unt32 (q2);
  p446.coef[19] = random_unt32 (q2);
  p446.coef[20] = random_unt32 (q2);
  p446.coef[21] = random_unt32 (q2);
  p446.coef[22] = random_unt32 (q2);
  p446.coef[23] = random_unt32 (q2);
  p446.coef[24] = random_unt32 (q2);
  p446.coef[25] = random_unt32 (q2);
  p446.coef[26] = random_unt32 (q2);
  p446.coef[27] = random_unt32 (q2);
  p446.coef[28] = random_unt32 (q2);
  p446.coef[29] = random_unt32 (q2);
  p446.coef[30] = random_unt32 (q2);
  p446.coef[31] = random_unt32 (q2);
  s = slaw_m5unt32 (p445);
  TestAgainstPredicates (eSlawType_m5unt32, s);
  if (memcmp (&p446, slaw_m5unt32_emit (s), sizeof (m5unt32)) != 0)
    error_exit ("compare failed for m5unt32\n");
  if (memcmp (&p446, slaw_m5unt32_emit_nocheck (s), sizeof (m5unt32)) != 0)
    error_exit ("compare failed for m5unt32\n");
  slaw_free (s);
  for (i = 0; i < 1078; i++)
    {
      p447[i].coef[0] = random_unt32 (q3);
      p447[i].coef[1] = random_unt32 (q3);
      p447[i].coef[2] = random_unt32 (q3);
      p447[i].coef[3] = random_unt32 (q3);
      p447[i].coef[4] = random_unt32 (q3);
      p447[i].coef[5] = random_unt32 (q3);
      p447[i].coef[6] = random_unt32 (q3);
      p447[i].coef[7] = random_unt32 (q3);
      p447[i].coef[8] = random_unt32 (q3);
      p447[i].coef[9] = random_unt32 (q3);
      p447[i].coef[10] = random_unt32 (q3);
      p447[i].coef[11] = random_unt32 (q3);
      p447[i].coef[12] = random_unt32 (q3);
      p447[i].coef[13] = random_unt32 (q3);
      p447[i].coef[14] = random_unt32 (q3);
      p447[i].coef[15] = random_unt32 (q3);
      p447[i].coef[16] = random_unt32 (q3);
      p447[i].coef[17] = random_unt32 (q3);
      p447[i].coef[18] = random_unt32 (q3);
      p447[i].coef[19] = random_unt32 (q3);
      p447[i].coef[20] = random_unt32 (q3);
      p447[i].coef[21] = random_unt32 (q3);
      p447[i].coef[22] = random_unt32 (q3);
      p447[i].coef[23] = random_unt32 (q3);
      p447[i].coef[24] = random_unt32 (q3);
      p447[i].coef[25] = random_unt32 (q3);
      p447[i].coef[26] = random_unt32 (q3);
      p447[i].coef[27] = random_unt32 (q3);
      p447[i].coef[28] = random_unt32 (q3);
      p447[i].coef[29] = random_unt32 (q3);
      p447[i].coef[30] = random_unt32 (q3);
      p447[i].coef[31] = random_unt32 (q3);
    }
  s1 = slaw_m5unt32_array_raw (1078, &p448);
  s2 = slaw_m5unt32_array_empty (random_unt8 (q1));
  s3 = slaw_m5unt32_array_filled (random_unt8 (q1), p445);
  s4 = slaw_m5unt32_array (p447, 1078);
  TestAgainstPredicates (eSlawType_m5unt32_array, s1);
  TestAgainstPredicates (eSlawType_m5unt32_array, s2);
  TestAgainstPredicates (eSlawType_m5unt32_array, s3);
  TestAgainstPredicates (eSlawType_m5unt32_array, s4);
  n = sizeof (m5unt32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5unt32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p446, i + slaw_m5unt32_array_emit (s3), sizeof (m5unt32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p448, p447, sizeof (p447));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5unt32_array_emit_nth (s3, i)
          != i + slaw_m5unt32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5unt32_arrays_concat (s3, s4, NULL);
  s = slaw_m5unt32_array_empty (0);
  s6 = slaw_m5unt32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5unt32_array_concat_carray (s3, p447, 1078);
  s8 = slaw_m5unt32_array_concat_carray_f (s3, p447, 1078);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5int64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5int64 p449;
  m5int64 p450;
  m5int64 p451[1205];
  m5int64 *p452;
  p449.coef[0] = random_int64 (q1);
  p449.coef[1] = random_int64 (q1);
  p449.coef[2] = random_int64 (q1);
  p449.coef[3] = random_int64 (q1);
  p449.coef[4] = random_int64 (q1);
  p449.coef[5] = random_int64 (q1);
  p449.coef[6] = random_int64 (q1);
  p449.coef[7] = random_int64 (q1);
  p449.coef[8] = random_int64 (q1);
  p449.coef[9] = random_int64 (q1);
  p449.coef[10] = random_int64 (q1);
  p449.coef[11] = random_int64 (q1);
  p449.coef[12] = random_int64 (q1);
  p449.coef[13] = random_int64 (q1);
  p449.coef[14] = random_int64 (q1);
  p449.coef[15] = random_int64 (q1);
  p449.coef[16] = random_int64 (q1);
  p449.coef[17] = random_int64 (q1);
  p449.coef[18] = random_int64 (q1);
  p449.coef[19] = random_int64 (q1);
  p449.coef[20] = random_int64 (q1);
  p449.coef[21] = random_int64 (q1);
  p449.coef[22] = random_int64 (q1);
  p449.coef[23] = random_int64 (q1);
  p449.coef[24] = random_int64 (q1);
  p449.coef[25] = random_int64 (q1);
  p449.coef[26] = random_int64 (q1);
  p449.coef[27] = random_int64 (q1);
  p449.coef[28] = random_int64 (q1);
  p449.coef[29] = random_int64 (q1);
  p449.coef[30] = random_int64 (q1);
  p449.coef[31] = random_int64 (q1);
  p450.coef[0] = random_int64 (q2);
  p450.coef[1] = random_int64 (q2);
  p450.coef[2] = random_int64 (q2);
  p450.coef[3] = random_int64 (q2);
  p450.coef[4] = random_int64 (q2);
  p450.coef[5] = random_int64 (q2);
  p450.coef[6] = random_int64 (q2);
  p450.coef[7] = random_int64 (q2);
  p450.coef[8] = random_int64 (q2);
  p450.coef[9] = random_int64 (q2);
  p450.coef[10] = random_int64 (q2);
  p450.coef[11] = random_int64 (q2);
  p450.coef[12] = random_int64 (q2);
  p450.coef[13] = random_int64 (q2);
  p450.coef[14] = random_int64 (q2);
  p450.coef[15] = random_int64 (q2);
  p450.coef[16] = random_int64 (q2);
  p450.coef[17] = random_int64 (q2);
  p450.coef[18] = random_int64 (q2);
  p450.coef[19] = random_int64 (q2);
  p450.coef[20] = random_int64 (q2);
  p450.coef[21] = random_int64 (q2);
  p450.coef[22] = random_int64 (q2);
  p450.coef[23] = random_int64 (q2);
  p450.coef[24] = random_int64 (q2);
  p450.coef[25] = random_int64 (q2);
  p450.coef[26] = random_int64 (q2);
  p450.coef[27] = random_int64 (q2);
  p450.coef[28] = random_int64 (q2);
  p450.coef[29] = random_int64 (q2);
  p450.coef[30] = random_int64 (q2);
  p450.coef[31] = random_int64 (q2);
  s = slaw_m5int64 (p449);
  TestAgainstPredicates (eSlawType_m5int64, s);
  if (memcmp (&p450, slaw_m5int64_emit (s), sizeof (m5int64)) != 0)
    error_exit ("compare failed for m5int64\n");
  if (memcmp (&p450, slaw_m5int64_emit_nocheck (s), sizeof (m5int64)) != 0)
    error_exit ("compare failed for m5int64\n");
  slaw_free (s);
  for (i = 0; i < 1205; i++)
    {
      p451[i].coef[0] = random_int64 (q3);
      p451[i].coef[1] = random_int64 (q3);
      p451[i].coef[2] = random_int64 (q3);
      p451[i].coef[3] = random_int64 (q3);
      p451[i].coef[4] = random_int64 (q3);
      p451[i].coef[5] = random_int64 (q3);
      p451[i].coef[6] = random_int64 (q3);
      p451[i].coef[7] = random_int64 (q3);
      p451[i].coef[8] = random_int64 (q3);
      p451[i].coef[9] = random_int64 (q3);
      p451[i].coef[10] = random_int64 (q3);
      p451[i].coef[11] = random_int64 (q3);
      p451[i].coef[12] = random_int64 (q3);
      p451[i].coef[13] = random_int64 (q3);
      p451[i].coef[14] = random_int64 (q3);
      p451[i].coef[15] = random_int64 (q3);
      p451[i].coef[16] = random_int64 (q3);
      p451[i].coef[17] = random_int64 (q3);
      p451[i].coef[18] = random_int64 (q3);
      p451[i].coef[19] = random_int64 (q3);
      p451[i].coef[20] = random_int64 (q3);
      p451[i].coef[21] = random_int64 (q3);
      p451[i].coef[22] = random_int64 (q3);
      p451[i].coef[23] = random_int64 (q3);
      p451[i].coef[24] = random_int64 (q3);
      p451[i].coef[25] = random_int64 (q3);
      p451[i].coef[26] = random_int64 (q3);
      p451[i].coef[27] = random_int64 (q3);
      p451[i].coef[28] = random_int64 (q3);
      p451[i].coef[29] = random_int64 (q3);
      p451[i].coef[30] = random_int64 (q3);
      p451[i].coef[31] = random_int64 (q3);
    }
  s1 = slaw_m5int64_array_raw (1205, &p452);
  s2 = slaw_m5int64_array_empty (random_unt8 (q1));
  s3 = slaw_m5int64_array_filled (random_unt8 (q1), p449);
  s4 = slaw_m5int64_array (p451, 1205);
  TestAgainstPredicates (eSlawType_m5int64_array, s1);
  TestAgainstPredicates (eSlawType_m5int64_array, s2);
  TestAgainstPredicates (eSlawType_m5int64_array, s3);
  TestAgainstPredicates (eSlawType_m5int64_array, s4);
  n = sizeof (m5int64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5int64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p450, i + slaw_m5int64_array_emit (s3), sizeof (m5int64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p452, p451, sizeof (p451));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5int64_array_emit_nth (s3, i)
          != i + slaw_m5int64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5int64_arrays_concat (s3, s4, NULL);
  s = slaw_m5int64_array_empty (0);
  s6 = slaw_m5int64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5int64_array_concat_carray (s3, p451, 1205);
  s8 = slaw_m5int64_array_concat_carray_f (s3, p451, 1205);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5unt64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5unt64 p453;
  m5unt64 p454;
  m5unt64 p455[585];
  m5unt64 *p456;
  p453.coef[0] = random_unt64 (q1);
  p453.coef[1] = random_unt64 (q1);
  p453.coef[2] = random_unt64 (q1);
  p453.coef[3] = random_unt64 (q1);
  p453.coef[4] = random_unt64 (q1);
  p453.coef[5] = random_unt64 (q1);
  p453.coef[6] = random_unt64 (q1);
  p453.coef[7] = random_unt64 (q1);
  p453.coef[8] = random_unt64 (q1);
  p453.coef[9] = random_unt64 (q1);
  p453.coef[10] = random_unt64 (q1);
  p453.coef[11] = random_unt64 (q1);
  p453.coef[12] = random_unt64 (q1);
  p453.coef[13] = random_unt64 (q1);
  p453.coef[14] = random_unt64 (q1);
  p453.coef[15] = random_unt64 (q1);
  p453.coef[16] = random_unt64 (q1);
  p453.coef[17] = random_unt64 (q1);
  p453.coef[18] = random_unt64 (q1);
  p453.coef[19] = random_unt64 (q1);
  p453.coef[20] = random_unt64 (q1);
  p453.coef[21] = random_unt64 (q1);
  p453.coef[22] = random_unt64 (q1);
  p453.coef[23] = random_unt64 (q1);
  p453.coef[24] = random_unt64 (q1);
  p453.coef[25] = random_unt64 (q1);
  p453.coef[26] = random_unt64 (q1);
  p453.coef[27] = random_unt64 (q1);
  p453.coef[28] = random_unt64 (q1);
  p453.coef[29] = random_unt64 (q1);
  p453.coef[30] = random_unt64 (q1);
  p453.coef[31] = random_unt64 (q1);
  p454.coef[0] = random_unt64 (q2);
  p454.coef[1] = random_unt64 (q2);
  p454.coef[2] = random_unt64 (q2);
  p454.coef[3] = random_unt64 (q2);
  p454.coef[4] = random_unt64 (q2);
  p454.coef[5] = random_unt64 (q2);
  p454.coef[6] = random_unt64 (q2);
  p454.coef[7] = random_unt64 (q2);
  p454.coef[8] = random_unt64 (q2);
  p454.coef[9] = random_unt64 (q2);
  p454.coef[10] = random_unt64 (q2);
  p454.coef[11] = random_unt64 (q2);
  p454.coef[12] = random_unt64 (q2);
  p454.coef[13] = random_unt64 (q2);
  p454.coef[14] = random_unt64 (q2);
  p454.coef[15] = random_unt64 (q2);
  p454.coef[16] = random_unt64 (q2);
  p454.coef[17] = random_unt64 (q2);
  p454.coef[18] = random_unt64 (q2);
  p454.coef[19] = random_unt64 (q2);
  p454.coef[20] = random_unt64 (q2);
  p454.coef[21] = random_unt64 (q2);
  p454.coef[22] = random_unt64 (q2);
  p454.coef[23] = random_unt64 (q2);
  p454.coef[24] = random_unt64 (q2);
  p454.coef[25] = random_unt64 (q2);
  p454.coef[26] = random_unt64 (q2);
  p454.coef[27] = random_unt64 (q2);
  p454.coef[28] = random_unt64 (q2);
  p454.coef[29] = random_unt64 (q2);
  p454.coef[30] = random_unt64 (q2);
  p454.coef[31] = random_unt64 (q2);
  s = slaw_m5unt64 (p453);
  TestAgainstPredicates (eSlawType_m5unt64, s);
  if (memcmp (&p454, slaw_m5unt64_emit (s), sizeof (m5unt64)) != 0)
    error_exit ("compare failed for m5unt64\n");
  if (memcmp (&p454, slaw_m5unt64_emit_nocheck (s), sizeof (m5unt64)) != 0)
    error_exit ("compare failed for m5unt64\n");
  slaw_free (s);
  for (i = 0; i < 585; i++)
    {
      p455[i].coef[0] = random_unt64 (q3);
      p455[i].coef[1] = random_unt64 (q3);
      p455[i].coef[2] = random_unt64 (q3);
      p455[i].coef[3] = random_unt64 (q3);
      p455[i].coef[4] = random_unt64 (q3);
      p455[i].coef[5] = random_unt64 (q3);
      p455[i].coef[6] = random_unt64 (q3);
      p455[i].coef[7] = random_unt64 (q3);
      p455[i].coef[8] = random_unt64 (q3);
      p455[i].coef[9] = random_unt64 (q3);
      p455[i].coef[10] = random_unt64 (q3);
      p455[i].coef[11] = random_unt64 (q3);
      p455[i].coef[12] = random_unt64 (q3);
      p455[i].coef[13] = random_unt64 (q3);
      p455[i].coef[14] = random_unt64 (q3);
      p455[i].coef[15] = random_unt64 (q3);
      p455[i].coef[16] = random_unt64 (q3);
      p455[i].coef[17] = random_unt64 (q3);
      p455[i].coef[18] = random_unt64 (q3);
      p455[i].coef[19] = random_unt64 (q3);
      p455[i].coef[20] = random_unt64 (q3);
      p455[i].coef[21] = random_unt64 (q3);
      p455[i].coef[22] = random_unt64 (q3);
      p455[i].coef[23] = random_unt64 (q3);
      p455[i].coef[24] = random_unt64 (q3);
      p455[i].coef[25] = random_unt64 (q3);
      p455[i].coef[26] = random_unt64 (q3);
      p455[i].coef[27] = random_unt64 (q3);
      p455[i].coef[28] = random_unt64 (q3);
      p455[i].coef[29] = random_unt64 (q3);
      p455[i].coef[30] = random_unt64 (q3);
      p455[i].coef[31] = random_unt64 (q3);
    }
  s1 = slaw_m5unt64_array_raw (585, &p456);
  s2 = slaw_m5unt64_array_empty (random_unt8 (q1));
  s3 = slaw_m5unt64_array_filled (random_unt8 (q1), p453);
  s4 = slaw_m5unt64_array (p455, 585);
  TestAgainstPredicates (eSlawType_m5unt64_array, s1);
  TestAgainstPredicates (eSlawType_m5unt64_array, s2);
  TestAgainstPredicates (eSlawType_m5unt64_array, s3);
  TestAgainstPredicates (eSlawType_m5unt64_array, s4);
  n = sizeof (m5unt64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5unt64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p454, i + slaw_m5unt64_array_emit (s3), sizeof (m5unt64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p456, p455, sizeof (p455));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5unt64_array_emit_nth (s3, i)
          != i + slaw_m5unt64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5unt64_arrays_concat (s3, s4, NULL);
  s = slaw_m5unt64_array_empty (0);
  s6 = slaw_m5unt64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5unt64_array_concat_carray (s3, p455, 585);
  s8 = slaw_m5unt64_array_concat_carray_f (s3, p455, 585);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5float32 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5float32 p457;
  m5float32 p458;
  m5float32 p459[1858];
  m5float32 *p460;
  p457.coef[0] = random_float32 (q1);
  p457.coef[1] = random_float32 (q1);
  p457.coef[2] = random_float32 (q1);
  p457.coef[3] = random_float32 (q1);
  p457.coef[4] = random_float32 (q1);
  p457.coef[5] = random_float32 (q1);
  p457.coef[6] = random_float32 (q1);
  p457.coef[7] = random_float32 (q1);
  p457.coef[8] = random_float32 (q1);
  p457.coef[9] = random_float32 (q1);
  p457.coef[10] = random_float32 (q1);
  p457.coef[11] = random_float32 (q1);
  p457.coef[12] = random_float32 (q1);
  p457.coef[13] = random_float32 (q1);
  p457.coef[14] = random_float32 (q1);
  p457.coef[15] = random_float32 (q1);
  p457.coef[16] = random_float32 (q1);
  p457.coef[17] = random_float32 (q1);
  p457.coef[18] = random_float32 (q1);
  p457.coef[19] = random_float32 (q1);
  p457.coef[20] = random_float32 (q1);
  p457.coef[21] = random_float32 (q1);
  p457.coef[22] = random_float32 (q1);
  p457.coef[23] = random_float32 (q1);
  p457.coef[24] = random_float32 (q1);
  p457.coef[25] = random_float32 (q1);
  p457.coef[26] = random_float32 (q1);
  p457.coef[27] = random_float32 (q1);
  p457.coef[28] = random_float32 (q1);
  p457.coef[29] = random_float32 (q1);
  p457.coef[30] = random_float32 (q1);
  p457.coef[31] = random_float32 (q1);
  p458.coef[0] = random_float32 (q2);
  p458.coef[1] = random_float32 (q2);
  p458.coef[2] = random_float32 (q2);
  p458.coef[3] = random_float32 (q2);
  p458.coef[4] = random_float32 (q2);
  p458.coef[5] = random_float32 (q2);
  p458.coef[6] = random_float32 (q2);
  p458.coef[7] = random_float32 (q2);
  p458.coef[8] = random_float32 (q2);
  p458.coef[9] = random_float32 (q2);
  p458.coef[10] = random_float32 (q2);
  p458.coef[11] = random_float32 (q2);
  p458.coef[12] = random_float32 (q2);
  p458.coef[13] = random_float32 (q2);
  p458.coef[14] = random_float32 (q2);
  p458.coef[15] = random_float32 (q2);
  p458.coef[16] = random_float32 (q2);
  p458.coef[17] = random_float32 (q2);
  p458.coef[18] = random_float32 (q2);
  p458.coef[19] = random_float32 (q2);
  p458.coef[20] = random_float32 (q2);
  p458.coef[21] = random_float32 (q2);
  p458.coef[22] = random_float32 (q2);
  p458.coef[23] = random_float32 (q2);
  p458.coef[24] = random_float32 (q2);
  p458.coef[25] = random_float32 (q2);
  p458.coef[26] = random_float32 (q2);
  p458.coef[27] = random_float32 (q2);
  p458.coef[28] = random_float32 (q2);
  p458.coef[29] = random_float32 (q2);
  p458.coef[30] = random_float32 (q2);
  p458.coef[31] = random_float32 (q2);
  s = slaw_m5float32 (p457);
  TestAgainstPredicates (eSlawType_m5float32, s);
  if (memcmp (&p458, slaw_m5float32_emit (s), sizeof (m5float32)) != 0)
    error_exit ("compare failed for m5float32\n");
  if (memcmp (&p458, slaw_m5float32_emit_nocheck (s), sizeof (m5float32)) != 0)
    error_exit ("compare failed for m5float32\n");
  slaw_free (s);
  for (i = 0; i < 1858; i++)
    {
      p459[i].coef[0] = random_float32 (q3);
      p459[i].coef[1] = random_float32 (q3);
      p459[i].coef[2] = random_float32 (q3);
      p459[i].coef[3] = random_float32 (q3);
      p459[i].coef[4] = random_float32 (q3);
      p459[i].coef[5] = random_float32 (q3);
      p459[i].coef[6] = random_float32 (q3);
      p459[i].coef[7] = random_float32 (q3);
      p459[i].coef[8] = random_float32 (q3);
      p459[i].coef[9] = random_float32 (q3);
      p459[i].coef[10] = random_float32 (q3);
      p459[i].coef[11] = random_float32 (q3);
      p459[i].coef[12] = random_float32 (q3);
      p459[i].coef[13] = random_float32 (q3);
      p459[i].coef[14] = random_float32 (q3);
      p459[i].coef[15] = random_float32 (q3);
      p459[i].coef[16] = random_float32 (q3);
      p459[i].coef[17] = random_float32 (q3);
      p459[i].coef[18] = random_float32 (q3);
      p459[i].coef[19] = random_float32 (q3);
      p459[i].coef[20] = random_float32 (q3);
      p459[i].coef[21] = random_float32 (q3);
      p459[i].coef[22] = random_float32 (q3);
      p459[i].coef[23] = random_float32 (q3);
      p459[i].coef[24] = random_float32 (q3);
      p459[i].coef[25] = random_float32 (q3);
      p459[i].coef[26] = random_float32 (q3);
      p459[i].coef[27] = random_float32 (q3);
      p459[i].coef[28] = random_float32 (q3);
      p459[i].coef[29] = random_float32 (q3);
      p459[i].coef[30] = random_float32 (q3);
      p459[i].coef[31] = random_float32 (q3);
    }
  s1 = slaw_m5float32_array_raw (1858, &p460);
  s2 = slaw_m5float32_array_empty (random_unt8 (q1));
  s3 = slaw_m5float32_array_filled (random_unt8 (q1), p457);
  s4 = slaw_m5float32_array (p459, 1858);
  TestAgainstPredicates (eSlawType_m5float32_array, s1);
  TestAgainstPredicates (eSlawType_m5float32_array, s2);
  TestAgainstPredicates (eSlawType_m5float32_array, s3);
  TestAgainstPredicates (eSlawType_m5float32_array, s4);
  n = sizeof (m5float32) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5float32_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p458, i + slaw_m5float32_array_emit (s3), sizeof (m5float32))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p460, p459, sizeof (p459));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5float32_array_emit_nth (s3, i)
          != i + slaw_m5float32_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5float32_arrays_concat (s3, s4, NULL);
  s = slaw_m5float32_array_empty (0);
  s6 = slaw_m5float32_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5float32_array_concat_carray (s3, p459, 1858);
  s8 = slaw_m5float32_array_concat_carray_f (s3, p459, 1858);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5float64 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5float64 p461;
  m5float64 p462;
  m5float64 p463[1685];
  m5float64 *p464;
  p461.coef[0] = random_float64 (q1);
  p461.coef[1] = random_float64 (q1);
  p461.coef[2] = random_float64 (q1);
  p461.coef[3] = random_float64 (q1);
  p461.coef[4] = random_float64 (q1);
  p461.coef[5] = random_float64 (q1);
  p461.coef[6] = random_float64 (q1);
  p461.coef[7] = random_float64 (q1);
  p461.coef[8] = random_float64 (q1);
  p461.coef[9] = random_float64 (q1);
  p461.coef[10] = random_float64 (q1);
  p461.coef[11] = random_float64 (q1);
  p461.coef[12] = random_float64 (q1);
  p461.coef[13] = random_float64 (q1);
  p461.coef[14] = random_float64 (q1);
  p461.coef[15] = random_float64 (q1);
  p461.coef[16] = random_float64 (q1);
  p461.coef[17] = random_float64 (q1);
  p461.coef[18] = random_float64 (q1);
  p461.coef[19] = random_float64 (q1);
  p461.coef[20] = random_float64 (q1);
  p461.coef[21] = random_float64 (q1);
  p461.coef[22] = random_float64 (q1);
  p461.coef[23] = random_float64 (q1);
  p461.coef[24] = random_float64 (q1);
  p461.coef[25] = random_float64 (q1);
  p461.coef[26] = random_float64 (q1);
  p461.coef[27] = random_float64 (q1);
  p461.coef[28] = random_float64 (q1);
  p461.coef[29] = random_float64 (q1);
  p461.coef[30] = random_float64 (q1);
  p461.coef[31] = random_float64 (q1);
  p462.coef[0] = random_float64 (q2);
  p462.coef[1] = random_float64 (q2);
  p462.coef[2] = random_float64 (q2);
  p462.coef[3] = random_float64 (q2);
  p462.coef[4] = random_float64 (q2);
  p462.coef[5] = random_float64 (q2);
  p462.coef[6] = random_float64 (q2);
  p462.coef[7] = random_float64 (q2);
  p462.coef[8] = random_float64 (q2);
  p462.coef[9] = random_float64 (q2);
  p462.coef[10] = random_float64 (q2);
  p462.coef[11] = random_float64 (q2);
  p462.coef[12] = random_float64 (q2);
  p462.coef[13] = random_float64 (q2);
  p462.coef[14] = random_float64 (q2);
  p462.coef[15] = random_float64 (q2);
  p462.coef[16] = random_float64 (q2);
  p462.coef[17] = random_float64 (q2);
  p462.coef[18] = random_float64 (q2);
  p462.coef[19] = random_float64 (q2);
  p462.coef[20] = random_float64 (q2);
  p462.coef[21] = random_float64 (q2);
  p462.coef[22] = random_float64 (q2);
  p462.coef[23] = random_float64 (q2);
  p462.coef[24] = random_float64 (q2);
  p462.coef[25] = random_float64 (q2);
  p462.coef[26] = random_float64 (q2);
  p462.coef[27] = random_float64 (q2);
  p462.coef[28] = random_float64 (q2);
  p462.coef[29] = random_float64 (q2);
  p462.coef[30] = random_float64 (q2);
  p462.coef[31] = random_float64 (q2);
  s = slaw_m5float64 (p461);
  TestAgainstPredicates (eSlawType_m5float64, s);
  if (memcmp (&p462, slaw_m5float64_emit (s), sizeof (m5float64)) != 0)
    error_exit ("compare failed for m5float64\n");
  if (memcmp (&p462, slaw_m5float64_emit_nocheck (s), sizeof (m5float64)) != 0)
    error_exit ("compare failed for m5float64\n");
  slaw_free (s);
  for (i = 0; i < 1685; i++)
    {
      p463[i].coef[0] = random_float64 (q3);
      p463[i].coef[1] = random_float64 (q3);
      p463[i].coef[2] = random_float64 (q3);
      p463[i].coef[3] = random_float64 (q3);
      p463[i].coef[4] = random_float64 (q3);
      p463[i].coef[5] = random_float64 (q3);
      p463[i].coef[6] = random_float64 (q3);
      p463[i].coef[7] = random_float64 (q3);
      p463[i].coef[8] = random_float64 (q3);
      p463[i].coef[9] = random_float64 (q3);
      p463[i].coef[10] = random_float64 (q3);
      p463[i].coef[11] = random_float64 (q3);
      p463[i].coef[12] = random_float64 (q3);
      p463[i].coef[13] = random_float64 (q3);
      p463[i].coef[14] = random_float64 (q3);
      p463[i].coef[15] = random_float64 (q3);
      p463[i].coef[16] = random_float64 (q3);
      p463[i].coef[17] = random_float64 (q3);
      p463[i].coef[18] = random_float64 (q3);
      p463[i].coef[19] = random_float64 (q3);
      p463[i].coef[20] = random_float64 (q3);
      p463[i].coef[21] = random_float64 (q3);
      p463[i].coef[22] = random_float64 (q3);
      p463[i].coef[23] = random_float64 (q3);
      p463[i].coef[24] = random_float64 (q3);
      p463[i].coef[25] = random_float64 (q3);
      p463[i].coef[26] = random_float64 (q3);
      p463[i].coef[27] = random_float64 (q3);
      p463[i].coef[28] = random_float64 (q3);
      p463[i].coef[29] = random_float64 (q3);
      p463[i].coef[30] = random_float64 (q3);
      p463[i].coef[31] = random_float64 (q3);
    }
  s1 = slaw_m5float64_array_raw (1685, &p464);
  s2 = slaw_m5float64_array_empty (random_unt8 (q1));
  s3 = slaw_m5float64_array_filled (random_unt8 (q1), p461);
  s4 = slaw_m5float64_array (p463, 1685);
  TestAgainstPredicates (eSlawType_m5float64_array, s1);
  TestAgainstPredicates (eSlawType_m5float64_array, s2);
  TestAgainstPredicates (eSlawType_m5float64_array, s3);
  TestAgainstPredicates (eSlawType_m5float64_array, s4);
  n = sizeof (m5float64) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5float64_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p462, i + slaw_m5float64_array_emit (s3), sizeof (m5float64))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p464, p463, sizeof (p463));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5float64_array_emit_nth (s3, i)
          != i + slaw_m5float64_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5float64_arrays_concat (s3, s4, NULL);
  s = slaw_m5float64_array_empty (0);
  s6 = slaw_m5float64_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5float64_array_concat_carray (s3, p463, 1685);
  s8 = slaw_m5float64_array_concat_carray_f (s3, p463, 1685);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5int8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5int8 p465;
  m5int8 p466;
  m5int8 p467[1511];
  m5int8 *p468;
  p465.coef[0] = random_int8 (q1);
  p465.coef[1] = random_int8 (q1);
  p465.coef[2] = random_int8 (q1);
  p465.coef[3] = random_int8 (q1);
  p465.coef[4] = random_int8 (q1);
  p465.coef[5] = random_int8 (q1);
  p465.coef[6] = random_int8 (q1);
  p465.coef[7] = random_int8 (q1);
  p465.coef[8] = random_int8 (q1);
  p465.coef[9] = random_int8 (q1);
  p465.coef[10] = random_int8 (q1);
  p465.coef[11] = random_int8 (q1);
  p465.coef[12] = random_int8 (q1);
  p465.coef[13] = random_int8 (q1);
  p465.coef[14] = random_int8 (q1);
  p465.coef[15] = random_int8 (q1);
  p465.coef[16] = random_int8 (q1);
  p465.coef[17] = random_int8 (q1);
  p465.coef[18] = random_int8 (q1);
  p465.coef[19] = random_int8 (q1);
  p465.coef[20] = random_int8 (q1);
  p465.coef[21] = random_int8 (q1);
  p465.coef[22] = random_int8 (q1);
  p465.coef[23] = random_int8 (q1);
  p465.coef[24] = random_int8 (q1);
  p465.coef[25] = random_int8 (q1);
  p465.coef[26] = random_int8 (q1);
  p465.coef[27] = random_int8 (q1);
  p465.coef[28] = random_int8 (q1);
  p465.coef[29] = random_int8 (q1);
  p465.coef[30] = random_int8 (q1);
  p465.coef[31] = random_int8 (q1);
  p466.coef[0] = random_int8 (q2);
  p466.coef[1] = random_int8 (q2);
  p466.coef[2] = random_int8 (q2);
  p466.coef[3] = random_int8 (q2);
  p466.coef[4] = random_int8 (q2);
  p466.coef[5] = random_int8 (q2);
  p466.coef[6] = random_int8 (q2);
  p466.coef[7] = random_int8 (q2);
  p466.coef[8] = random_int8 (q2);
  p466.coef[9] = random_int8 (q2);
  p466.coef[10] = random_int8 (q2);
  p466.coef[11] = random_int8 (q2);
  p466.coef[12] = random_int8 (q2);
  p466.coef[13] = random_int8 (q2);
  p466.coef[14] = random_int8 (q2);
  p466.coef[15] = random_int8 (q2);
  p466.coef[16] = random_int8 (q2);
  p466.coef[17] = random_int8 (q2);
  p466.coef[18] = random_int8 (q2);
  p466.coef[19] = random_int8 (q2);
  p466.coef[20] = random_int8 (q2);
  p466.coef[21] = random_int8 (q2);
  p466.coef[22] = random_int8 (q2);
  p466.coef[23] = random_int8 (q2);
  p466.coef[24] = random_int8 (q2);
  p466.coef[25] = random_int8 (q2);
  p466.coef[26] = random_int8 (q2);
  p466.coef[27] = random_int8 (q2);
  p466.coef[28] = random_int8 (q2);
  p466.coef[29] = random_int8 (q2);
  p466.coef[30] = random_int8 (q2);
  p466.coef[31] = random_int8 (q2);
  s = slaw_m5int8 (p465);
  TestAgainstPredicates (eSlawType_m5int8, s);
  if (memcmp (&p466, slaw_m5int8_emit (s), sizeof (m5int8)) != 0)
    error_exit ("compare failed for m5int8\n");
  if (memcmp (&p466, slaw_m5int8_emit_nocheck (s), sizeof (m5int8)) != 0)
    error_exit ("compare failed for m5int8\n");
  slaw_free (s);
  for (i = 0; i < 1511; i++)
    {
      p467[i].coef[0] = random_int8 (q3);
      p467[i].coef[1] = random_int8 (q3);
      p467[i].coef[2] = random_int8 (q3);
      p467[i].coef[3] = random_int8 (q3);
      p467[i].coef[4] = random_int8 (q3);
      p467[i].coef[5] = random_int8 (q3);
      p467[i].coef[6] = random_int8 (q3);
      p467[i].coef[7] = random_int8 (q3);
      p467[i].coef[8] = random_int8 (q3);
      p467[i].coef[9] = random_int8 (q3);
      p467[i].coef[10] = random_int8 (q3);
      p467[i].coef[11] = random_int8 (q3);
      p467[i].coef[12] = random_int8 (q3);
      p467[i].coef[13] = random_int8 (q3);
      p467[i].coef[14] = random_int8 (q3);
      p467[i].coef[15] = random_int8 (q3);
      p467[i].coef[16] = random_int8 (q3);
      p467[i].coef[17] = random_int8 (q3);
      p467[i].coef[18] = random_int8 (q3);
      p467[i].coef[19] = random_int8 (q3);
      p467[i].coef[20] = random_int8 (q3);
      p467[i].coef[21] = random_int8 (q3);
      p467[i].coef[22] = random_int8 (q3);
      p467[i].coef[23] = random_int8 (q3);
      p467[i].coef[24] = random_int8 (q3);
      p467[i].coef[25] = random_int8 (q3);
      p467[i].coef[26] = random_int8 (q3);
      p467[i].coef[27] = random_int8 (q3);
      p467[i].coef[28] = random_int8 (q3);
      p467[i].coef[29] = random_int8 (q3);
      p467[i].coef[30] = random_int8 (q3);
      p467[i].coef[31] = random_int8 (q3);
    }
  s1 = slaw_m5int8_array_raw (1511, &p468);
  s2 = slaw_m5int8_array_empty (random_unt8 (q1));
  s3 = slaw_m5int8_array_filled (random_unt8 (q1), p465);
  s4 = slaw_m5int8_array (p467, 1511);
  TestAgainstPredicates (eSlawType_m5int8_array, s1);
  TestAgainstPredicates (eSlawType_m5int8_array, s2);
  TestAgainstPredicates (eSlawType_m5int8_array, s3);
  TestAgainstPredicates (eSlawType_m5int8_array, s4);
  n = sizeof (m5int8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5int8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p466, i + slaw_m5int8_array_emit (s3), sizeof (m5int8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p468, p467, sizeof (p467));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5int8_array_emit_nth (s3, i) != i + slaw_m5int8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5int8_arrays_concat (s3, s4, NULL);
  s = slaw_m5int8_array_empty (0);
  s6 = slaw_m5int8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5int8_array_concat_carray (s3, p467, 1511);
  s8 = slaw_m5int8_array_concat_carray_f (s3, p467, 1511);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5unt8 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5unt8 p469;
  m5unt8 p470;
  m5unt8 p471[771];
  m5unt8 *p472;
  p469.coef[0] = random_unt8 (q1);
  p469.coef[1] = random_unt8 (q1);
  p469.coef[2] = random_unt8 (q1);
  p469.coef[3] = random_unt8 (q1);
  p469.coef[4] = random_unt8 (q1);
  p469.coef[5] = random_unt8 (q1);
  p469.coef[6] = random_unt8 (q1);
  p469.coef[7] = random_unt8 (q1);
  p469.coef[8] = random_unt8 (q1);
  p469.coef[9] = random_unt8 (q1);
  p469.coef[10] = random_unt8 (q1);
  p469.coef[11] = random_unt8 (q1);
  p469.coef[12] = random_unt8 (q1);
  p469.coef[13] = random_unt8 (q1);
  p469.coef[14] = random_unt8 (q1);
  p469.coef[15] = random_unt8 (q1);
  p469.coef[16] = random_unt8 (q1);
  p469.coef[17] = random_unt8 (q1);
  p469.coef[18] = random_unt8 (q1);
  p469.coef[19] = random_unt8 (q1);
  p469.coef[20] = random_unt8 (q1);
  p469.coef[21] = random_unt8 (q1);
  p469.coef[22] = random_unt8 (q1);
  p469.coef[23] = random_unt8 (q1);
  p469.coef[24] = random_unt8 (q1);
  p469.coef[25] = random_unt8 (q1);
  p469.coef[26] = random_unt8 (q1);
  p469.coef[27] = random_unt8 (q1);
  p469.coef[28] = random_unt8 (q1);
  p469.coef[29] = random_unt8 (q1);
  p469.coef[30] = random_unt8 (q1);
  p469.coef[31] = random_unt8 (q1);
  p470.coef[0] = random_unt8 (q2);
  p470.coef[1] = random_unt8 (q2);
  p470.coef[2] = random_unt8 (q2);
  p470.coef[3] = random_unt8 (q2);
  p470.coef[4] = random_unt8 (q2);
  p470.coef[5] = random_unt8 (q2);
  p470.coef[6] = random_unt8 (q2);
  p470.coef[7] = random_unt8 (q2);
  p470.coef[8] = random_unt8 (q2);
  p470.coef[9] = random_unt8 (q2);
  p470.coef[10] = random_unt8 (q2);
  p470.coef[11] = random_unt8 (q2);
  p470.coef[12] = random_unt8 (q2);
  p470.coef[13] = random_unt8 (q2);
  p470.coef[14] = random_unt8 (q2);
  p470.coef[15] = random_unt8 (q2);
  p470.coef[16] = random_unt8 (q2);
  p470.coef[17] = random_unt8 (q2);
  p470.coef[18] = random_unt8 (q2);
  p470.coef[19] = random_unt8 (q2);
  p470.coef[20] = random_unt8 (q2);
  p470.coef[21] = random_unt8 (q2);
  p470.coef[22] = random_unt8 (q2);
  p470.coef[23] = random_unt8 (q2);
  p470.coef[24] = random_unt8 (q2);
  p470.coef[25] = random_unt8 (q2);
  p470.coef[26] = random_unt8 (q2);
  p470.coef[27] = random_unt8 (q2);
  p470.coef[28] = random_unt8 (q2);
  p470.coef[29] = random_unt8 (q2);
  p470.coef[30] = random_unt8 (q2);
  p470.coef[31] = random_unt8 (q2);
  s = slaw_m5unt8 (p469);
  TestAgainstPredicates (eSlawType_m5unt8, s);
  if (memcmp (&p470, slaw_m5unt8_emit (s), sizeof (m5unt8)) != 0)
    error_exit ("compare failed for m5unt8\n");
  if (memcmp (&p470, slaw_m5unt8_emit_nocheck (s), sizeof (m5unt8)) != 0)
    error_exit ("compare failed for m5unt8\n");
  slaw_free (s);
  for (i = 0; i < 771; i++)
    {
      p471[i].coef[0] = random_unt8 (q3);
      p471[i].coef[1] = random_unt8 (q3);
      p471[i].coef[2] = random_unt8 (q3);
      p471[i].coef[3] = random_unt8 (q3);
      p471[i].coef[4] = random_unt8 (q3);
      p471[i].coef[5] = random_unt8 (q3);
      p471[i].coef[6] = random_unt8 (q3);
      p471[i].coef[7] = random_unt8 (q3);
      p471[i].coef[8] = random_unt8 (q3);
      p471[i].coef[9] = random_unt8 (q3);
      p471[i].coef[10] = random_unt8 (q3);
      p471[i].coef[11] = random_unt8 (q3);
      p471[i].coef[12] = random_unt8 (q3);
      p471[i].coef[13] = random_unt8 (q3);
      p471[i].coef[14] = random_unt8 (q3);
      p471[i].coef[15] = random_unt8 (q3);
      p471[i].coef[16] = random_unt8 (q3);
      p471[i].coef[17] = random_unt8 (q3);
      p471[i].coef[18] = random_unt8 (q3);
      p471[i].coef[19] = random_unt8 (q3);
      p471[i].coef[20] = random_unt8 (q3);
      p471[i].coef[21] = random_unt8 (q3);
      p471[i].coef[22] = random_unt8 (q3);
      p471[i].coef[23] = random_unt8 (q3);
      p471[i].coef[24] = random_unt8 (q3);
      p471[i].coef[25] = random_unt8 (q3);
      p471[i].coef[26] = random_unt8 (q3);
      p471[i].coef[27] = random_unt8 (q3);
      p471[i].coef[28] = random_unt8 (q3);
      p471[i].coef[29] = random_unt8 (q3);
      p471[i].coef[30] = random_unt8 (q3);
      p471[i].coef[31] = random_unt8 (q3);
    }
  s1 = slaw_m5unt8_array_raw (771, &p472);
  s2 = slaw_m5unt8_array_empty (random_unt8 (q1));
  s3 = slaw_m5unt8_array_filled (random_unt8 (q1), p469);
  s4 = slaw_m5unt8_array (p471, 771);
  TestAgainstPredicates (eSlawType_m5unt8_array, s1);
  TestAgainstPredicates (eSlawType_m5unt8_array, s2);
  TestAgainstPredicates (eSlawType_m5unt8_array, s3);
  TestAgainstPredicates (eSlawType_m5unt8_array, s4);
  n = sizeof (m5unt8) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5unt8_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p470, i + slaw_m5unt8_array_emit (s3), sizeof (m5unt8)) != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p472, p471, sizeof (p471));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5unt8_array_emit_nth (s3, i) != i + slaw_m5unt8_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5unt8_arrays_concat (s3, s4, NULL);
  s = slaw_m5unt8_array_empty (0);
  s6 = slaw_m5unt8_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5unt8_array_concat_carray (s3, p471, 771);
  s8 = slaw_m5unt8_array_concat_carray_f (s3, p471, 771);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5int16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5int16 p473;
  m5int16 p474;
  m5int16 p475[1065];
  m5int16 *p476;
  p473.coef[0] = random_int16 (q1);
  p473.coef[1] = random_int16 (q1);
  p473.coef[2] = random_int16 (q1);
  p473.coef[3] = random_int16 (q1);
  p473.coef[4] = random_int16 (q1);
  p473.coef[5] = random_int16 (q1);
  p473.coef[6] = random_int16 (q1);
  p473.coef[7] = random_int16 (q1);
  p473.coef[8] = random_int16 (q1);
  p473.coef[9] = random_int16 (q1);
  p473.coef[10] = random_int16 (q1);
  p473.coef[11] = random_int16 (q1);
  p473.coef[12] = random_int16 (q1);
  p473.coef[13] = random_int16 (q1);
  p473.coef[14] = random_int16 (q1);
  p473.coef[15] = random_int16 (q1);
  p473.coef[16] = random_int16 (q1);
  p473.coef[17] = random_int16 (q1);
  p473.coef[18] = random_int16 (q1);
  p473.coef[19] = random_int16 (q1);
  p473.coef[20] = random_int16 (q1);
  p473.coef[21] = random_int16 (q1);
  p473.coef[22] = random_int16 (q1);
  p473.coef[23] = random_int16 (q1);
  p473.coef[24] = random_int16 (q1);
  p473.coef[25] = random_int16 (q1);
  p473.coef[26] = random_int16 (q1);
  p473.coef[27] = random_int16 (q1);
  p473.coef[28] = random_int16 (q1);
  p473.coef[29] = random_int16 (q1);
  p473.coef[30] = random_int16 (q1);
  p473.coef[31] = random_int16 (q1);
  p474.coef[0] = random_int16 (q2);
  p474.coef[1] = random_int16 (q2);
  p474.coef[2] = random_int16 (q2);
  p474.coef[3] = random_int16 (q2);
  p474.coef[4] = random_int16 (q2);
  p474.coef[5] = random_int16 (q2);
  p474.coef[6] = random_int16 (q2);
  p474.coef[7] = random_int16 (q2);
  p474.coef[8] = random_int16 (q2);
  p474.coef[9] = random_int16 (q2);
  p474.coef[10] = random_int16 (q2);
  p474.coef[11] = random_int16 (q2);
  p474.coef[12] = random_int16 (q2);
  p474.coef[13] = random_int16 (q2);
  p474.coef[14] = random_int16 (q2);
  p474.coef[15] = random_int16 (q2);
  p474.coef[16] = random_int16 (q2);
  p474.coef[17] = random_int16 (q2);
  p474.coef[18] = random_int16 (q2);
  p474.coef[19] = random_int16 (q2);
  p474.coef[20] = random_int16 (q2);
  p474.coef[21] = random_int16 (q2);
  p474.coef[22] = random_int16 (q2);
  p474.coef[23] = random_int16 (q2);
  p474.coef[24] = random_int16 (q2);
  p474.coef[25] = random_int16 (q2);
  p474.coef[26] = random_int16 (q2);
  p474.coef[27] = random_int16 (q2);
  p474.coef[28] = random_int16 (q2);
  p474.coef[29] = random_int16 (q2);
  p474.coef[30] = random_int16 (q2);
  p474.coef[31] = random_int16 (q2);
  s = slaw_m5int16 (p473);
  TestAgainstPredicates (eSlawType_m5int16, s);
  if (memcmp (&p474, slaw_m5int16_emit (s), sizeof (m5int16)) != 0)
    error_exit ("compare failed for m5int16\n");
  if (memcmp (&p474, slaw_m5int16_emit_nocheck (s), sizeof (m5int16)) != 0)
    error_exit ("compare failed for m5int16\n");
  slaw_free (s);
  for (i = 0; i < 1065; i++)
    {
      p475[i].coef[0] = random_int16 (q3);
      p475[i].coef[1] = random_int16 (q3);
      p475[i].coef[2] = random_int16 (q3);
      p475[i].coef[3] = random_int16 (q3);
      p475[i].coef[4] = random_int16 (q3);
      p475[i].coef[5] = random_int16 (q3);
      p475[i].coef[6] = random_int16 (q3);
      p475[i].coef[7] = random_int16 (q3);
      p475[i].coef[8] = random_int16 (q3);
      p475[i].coef[9] = random_int16 (q3);
      p475[i].coef[10] = random_int16 (q3);
      p475[i].coef[11] = random_int16 (q3);
      p475[i].coef[12] = random_int16 (q3);
      p475[i].coef[13] = random_int16 (q3);
      p475[i].coef[14] = random_int16 (q3);
      p475[i].coef[15] = random_int16 (q3);
      p475[i].coef[16] = random_int16 (q3);
      p475[i].coef[17] = random_int16 (q3);
      p475[i].coef[18] = random_int16 (q3);
      p475[i].coef[19] = random_int16 (q3);
      p475[i].coef[20] = random_int16 (q3);
      p475[i].coef[21] = random_int16 (q3);
      p475[i].coef[22] = random_int16 (q3);
      p475[i].coef[23] = random_int16 (q3);
      p475[i].coef[24] = random_int16 (q3);
      p475[i].coef[25] = random_int16 (q3);
      p475[i].coef[26] = random_int16 (q3);
      p475[i].coef[27] = random_int16 (q3);
      p475[i].coef[28] = random_int16 (q3);
      p475[i].coef[29] = random_int16 (q3);
      p475[i].coef[30] = random_int16 (q3);
      p475[i].coef[31] = random_int16 (q3);
    }
  s1 = slaw_m5int16_array_raw (1065, &p476);
  s2 = slaw_m5int16_array_empty (random_unt8 (q1));
  s3 = slaw_m5int16_array_filled (random_unt8 (q1), p473);
  s4 = slaw_m5int16_array (p475, 1065);
  TestAgainstPredicates (eSlawType_m5int16_array, s1);
  TestAgainstPredicates (eSlawType_m5int16_array, s2);
  TestAgainstPredicates (eSlawType_m5int16_array, s3);
  TestAgainstPredicates (eSlawType_m5int16_array, s4);
  n = sizeof (m5int16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5int16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p474, i + slaw_m5int16_array_emit (s3), sizeof (m5int16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p476, p475, sizeof (p475));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5int16_array_emit_nth (s3, i)
          != i + slaw_m5int16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5int16_arrays_concat (s3, s4, NULL);
  s = slaw_m5int16_array_empty (0);
  s6 = slaw_m5int16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5int16_array_concat_carray (s3, p475, 1065);
  s8 = slaw_m5int16_array_concat_carray_f (s3, p475, 1065);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

void exercise_m5unt16 (rand_state q1, rand_state q2, rand_state q3)
{
  slaw s, s1, s2, s3, s4, s5, s6, s7, s8;
  int i, n;
  m5unt16 p477;
  m5unt16 p478;
  m5unt16 p479[170];
  m5unt16 *p480;
  p477.coef[0] = random_unt16 (q1);
  p477.coef[1] = random_unt16 (q1);
  p477.coef[2] = random_unt16 (q1);
  p477.coef[3] = random_unt16 (q1);
  p477.coef[4] = random_unt16 (q1);
  p477.coef[5] = random_unt16 (q1);
  p477.coef[6] = random_unt16 (q1);
  p477.coef[7] = random_unt16 (q1);
  p477.coef[8] = random_unt16 (q1);
  p477.coef[9] = random_unt16 (q1);
  p477.coef[10] = random_unt16 (q1);
  p477.coef[11] = random_unt16 (q1);
  p477.coef[12] = random_unt16 (q1);
  p477.coef[13] = random_unt16 (q1);
  p477.coef[14] = random_unt16 (q1);
  p477.coef[15] = random_unt16 (q1);
  p477.coef[16] = random_unt16 (q1);
  p477.coef[17] = random_unt16 (q1);
  p477.coef[18] = random_unt16 (q1);
  p477.coef[19] = random_unt16 (q1);
  p477.coef[20] = random_unt16 (q1);
  p477.coef[21] = random_unt16 (q1);
  p477.coef[22] = random_unt16 (q1);
  p477.coef[23] = random_unt16 (q1);
  p477.coef[24] = random_unt16 (q1);
  p477.coef[25] = random_unt16 (q1);
  p477.coef[26] = random_unt16 (q1);
  p477.coef[27] = random_unt16 (q1);
  p477.coef[28] = random_unt16 (q1);
  p477.coef[29] = random_unt16 (q1);
  p477.coef[30] = random_unt16 (q1);
  p477.coef[31] = random_unt16 (q1);
  p478.coef[0] = random_unt16 (q2);
  p478.coef[1] = random_unt16 (q2);
  p478.coef[2] = random_unt16 (q2);
  p478.coef[3] = random_unt16 (q2);
  p478.coef[4] = random_unt16 (q2);
  p478.coef[5] = random_unt16 (q2);
  p478.coef[6] = random_unt16 (q2);
  p478.coef[7] = random_unt16 (q2);
  p478.coef[8] = random_unt16 (q2);
  p478.coef[9] = random_unt16 (q2);
  p478.coef[10] = random_unt16 (q2);
  p478.coef[11] = random_unt16 (q2);
  p478.coef[12] = random_unt16 (q2);
  p478.coef[13] = random_unt16 (q2);
  p478.coef[14] = random_unt16 (q2);
  p478.coef[15] = random_unt16 (q2);
  p478.coef[16] = random_unt16 (q2);
  p478.coef[17] = random_unt16 (q2);
  p478.coef[18] = random_unt16 (q2);
  p478.coef[19] = random_unt16 (q2);
  p478.coef[20] = random_unt16 (q2);
  p478.coef[21] = random_unt16 (q2);
  p478.coef[22] = random_unt16 (q2);
  p478.coef[23] = random_unt16 (q2);
  p478.coef[24] = random_unt16 (q2);
  p478.coef[25] = random_unt16 (q2);
  p478.coef[26] = random_unt16 (q2);
  p478.coef[27] = random_unt16 (q2);
  p478.coef[28] = random_unt16 (q2);
  p478.coef[29] = random_unt16 (q2);
  p478.coef[30] = random_unt16 (q2);
  p478.coef[31] = random_unt16 (q2);
  s = slaw_m5unt16 (p477);
  TestAgainstPredicates (eSlawType_m5unt16, s);
  if (memcmp (&p478, slaw_m5unt16_emit (s), sizeof (m5unt16)) != 0)
    error_exit ("compare failed for m5unt16\n");
  if (memcmp (&p478, slaw_m5unt16_emit_nocheck (s), sizeof (m5unt16)) != 0)
    error_exit ("compare failed for m5unt16\n");
  slaw_free (s);
  for (i = 0; i < 170; i++)
    {
      p479[i].coef[0] = random_unt16 (q3);
      p479[i].coef[1] = random_unt16 (q3);
      p479[i].coef[2] = random_unt16 (q3);
      p479[i].coef[3] = random_unt16 (q3);
      p479[i].coef[4] = random_unt16 (q3);
      p479[i].coef[5] = random_unt16 (q3);
      p479[i].coef[6] = random_unt16 (q3);
      p479[i].coef[7] = random_unt16 (q3);
      p479[i].coef[8] = random_unt16 (q3);
      p479[i].coef[9] = random_unt16 (q3);
      p479[i].coef[10] = random_unt16 (q3);
      p479[i].coef[11] = random_unt16 (q3);
      p479[i].coef[12] = random_unt16 (q3);
      p479[i].coef[13] = random_unt16 (q3);
      p479[i].coef[14] = random_unt16 (q3);
      p479[i].coef[15] = random_unt16 (q3);
      p479[i].coef[16] = random_unt16 (q3);
      p479[i].coef[17] = random_unt16 (q3);
      p479[i].coef[18] = random_unt16 (q3);
      p479[i].coef[19] = random_unt16 (q3);
      p479[i].coef[20] = random_unt16 (q3);
      p479[i].coef[21] = random_unt16 (q3);
      p479[i].coef[22] = random_unt16 (q3);
      p479[i].coef[23] = random_unt16 (q3);
      p479[i].coef[24] = random_unt16 (q3);
      p479[i].coef[25] = random_unt16 (q3);
      p479[i].coef[26] = random_unt16 (q3);
      p479[i].coef[27] = random_unt16 (q3);
      p479[i].coef[28] = random_unt16 (q3);
      p479[i].coef[29] = random_unt16 (q3);
      p479[i].coef[30] = random_unt16 (q3);
      p479[i].coef[31] = random_unt16 (q3);
    }
  s1 = slaw_m5unt16_array_raw (170, &p480);
  s2 = slaw_m5unt16_array_empty (random_unt8 (q1));
  s3 = slaw_m5unt16_array_filled (random_unt8 (q1), p477);
  s4 = slaw_m5unt16_array (p479, 170);
  TestAgainstPredicates (eSlawType_m5unt16_array, s1);
  TestAgainstPredicates (eSlawType_m5unt16_array, s2);
  TestAgainstPredicates (eSlawType_m5unt16_array, s3);
  TestAgainstPredicates (eSlawType_m5unt16_array, s4);
  n = sizeof (m5unt16) * random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (0 != ((byte *) slaw_m5unt16_array_emit (s2))[i])
        error_exit ("nonzero at byte %d\n", i);
    }
  n = random_unt8 (q2);
  for (i = 0; i < n; i++)
    {
      if (memcmp (&p478, i + slaw_m5unt16_array_emit (s3), sizeof (m5unt16))
          != 0)
        error_exit ("filled not equal at %d\n", i);
    }
  memcpy (p480, p479, sizeof (p479));
  if (!slawx_equal (s1, s4))
    error_exit ("slawx not equal\n");
  for (i = 0; i < n; i++)
    {
      if (slaw_m5unt16_array_emit_nth (s3, i)
          != i + slaw_m5unt16_array_emit (s3))
        error_exit ("addresses not equal at %d\n", i);
    }
  s5 = slaw_m5unt16_arrays_concat (s3, s4, NULL);
  s = slaw_m5unt16_array_empty (0);
  s6 = slaw_m5unt16_arrays_concat_f (s, slaw_dup (s3), s1, NULL);
  s7 = slaw_m5unt16_array_concat_carray (s3, p479, 170);
  s8 = slaw_m5unt16_array_concat_carray_f (s3, p479, 170);
  if (!slawx_equal (s5, s6))
    error_exit ("s5 != s6\n");
  if (!slawx_equal (s6, s7))
    error_exit ("s6 != s7\n");
  if (!slawx_equal (s7, s8))
    error_exit ("s7 != s8\n");
  slaw_free (s2);
  slaw_free (s4);
  slaw_free (s5);
  slaw_free (s6);
  slaw_free (s7);
  slaw_free (s8);
}

int main (int argc, char **argv)
{
  int j;
  rand_state q1, q2, q3;

  memset (q1, 0x0b, sizeof (q1));
  memset (q2, 0x0b, sizeof (q2));
  memset (q3, 0xfc, sizeof (q3));

  for (j = 0; j < 10; j++)
    {
      exercise_int32 (q1, q2, q3);
      exercise_unt32 (q1, q2, q3);
      exercise_int64 (q1, q2, q3);
      exercise_unt64 (q1, q2, q3);
      exercise_float32 (q1, q2, q3);
      exercise_float64 (q1, q2, q3);
      exercise_int8 (q1, q2, q3);
      exercise_unt8 (q1, q2, q3);
      exercise_int16 (q1, q2, q3);
      exercise_unt16 (q1, q2, q3);
      exercise_int32c (q1, q2, q3);
      exercise_unt32c (q1, q2, q3);
      exercise_int64c (q1, q2, q3);
      exercise_unt64c (q1, q2, q3);
      exercise_float32c (q1, q2, q3);
      exercise_float64c (q1, q2, q3);
      exercise_int8c (q1, q2, q3);
      exercise_unt8c (q1, q2, q3);
      exercise_int16c (q1, q2, q3);
      exercise_unt16c (q1, q2, q3);
      exercise_v2int32 (q1, q2, q3);
      exercise_v2unt32 (q1, q2, q3);
      exercise_v2int64 (q1, q2, q3);
      exercise_v2unt64 (q1, q2, q3);
      exercise_v2float32 (q1, q2, q3);
      exercise_v2float64 (q1, q2, q3);
      exercise_v2int8 (q1, q2, q3);
      exercise_v2unt8 (q1, q2, q3);
      exercise_v2int16 (q1, q2, q3);
      exercise_v2unt16 (q1, q2, q3);
      exercise_v3int32 (q1, q2, q3);
      exercise_v3unt32 (q1, q2, q3);
      exercise_v3int64 (q1, q2, q3);
      exercise_v3unt64 (q1, q2, q3);
      exercise_v3float32 (q1, q2, q3);
      exercise_v3float64 (q1, q2, q3);
      exercise_v3int8 (q1, q2, q3);
      exercise_v3unt8 (q1, q2, q3);
      exercise_v3int16 (q1, q2, q3);
      exercise_v3unt16 (q1, q2, q3);
      exercise_v4int32 (q1, q2, q3);
      exercise_v4unt32 (q1, q2, q3);
      exercise_v4int64 (q1, q2, q3);
      exercise_v4unt64 (q1, q2, q3);
      exercise_v4float32 (q1, q2, q3);
      exercise_v4float64 (q1, q2, q3);
      exercise_v4int8 (q1, q2, q3);
      exercise_v4unt8 (q1, q2, q3);
      exercise_v4int16 (q1, q2, q3);
      exercise_v4unt16 (q1, q2, q3);
      exercise_v2int32c (q1, q2, q3);
      exercise_v2unt32c (q1, q2, q3);
      exercise_v2int64c (q1, q2, q3);
      exercise_v2unt64c (q1, q2, q3);
      exercise_v2float32c (q1, q2, q3);
      exercise_v2float64c (q1, q2, q3);
      exercise_v2int8c (q1, q2, q3);
      exercise_v2unt8c (q1, q2, q3);
      exercise_v2int16c (q1, q2, q3);
      exercise_v2unt16c (q1, q2, q3);
      exercise_v3int32c (q1, q2, q3);
      exercise_v3unt32c (q1, q2, q3);
      exercise_v3int64c (q1, q2, q3);
      exercise_v3unt64c (q1, q2, q3);
      exercise_v3float32c (q1, q2, q3);
      exercise_v3float64c (q1, q2, q3);
      exercise_v3int8c (q1, q2, q3);
      exercise_v3unt8c (q1, q2, q3);
      exercise_v3int16c (q1, q2, q3);
      exercise_v3unt16c (q1, q2, q3);
      exercise_v4int32c (q1, q2, q3);
      exercise_v4unt32c (q1, q2, q3);
      exercise_v4int64c (q1, q2, q3);
      exercise_v4unt64c (q1, q2, q3);
      exercise_v4float32c (q1, q2, q3);
      exercise_v4float64c (q1, q2, q3);
      exercise_v4int8c (q1, q2, q3);
      exercise_v4unt8c (q1, q2, q3);
      exercise_v4int16c (q1, q2, q3);
      exercise_v4unt16c (q1, q2, q3);
      exercise_m2int32 (q1, q2, q3);
      exercise_m2unt32 (q1, q2, q3);
      exercise_m2int64 (q1, q2, q3);
      exercise_m2unt64 (q1, q2, q3);
      exercise_m2float32 (q1, q2, q3);
      exercise_m2float64 (q1, q2, q3);
      exercise_m2int8 (q1, q2, q3);
      exercise_m2unt8 (q1, q2, q3);
      exercise_m2int16 (q1, q2, q3);
      exercise_m2unt16 (q1, q2, q3);
      exercise_m3int32 (q1, q2, q3);
      exercise_m3unt32 (q1, q2, q3);
      exercise_m3int64 (q1, q2, q3);
      exercise_m3unt64 (q1, q2, q3);
      exercise_m3float32 (q1, q2, q3);
      exercise_m3float64 (q1, q2, q3);
      exercise_m3int8 (q1, q2, q3);
      exercise_m3unt8 (q1, q2, q3);
      exercise_m3int16 (q1, q2, q3);
      exercise_m3unt16 (q1, q2, q3);
      exercise_m4int32 (q1, q2, q3);
      exercise_m4unt32 (q1, q2, q3);
      exercise_m4int64 (q1, q2, q3);
      exercise_m4unt64 (q1, q2, q3);
      exercise_m4float32 (q1, q2, q3);
      exercise_m4float64 (q1, q2, q3);
      exercise_m4int8 (q1, q2, q3);
      exercise_m4unt8 (q1, q2, q3);
      exercise_m4int16 (q1, q2, q3);
      exercise_m4unt16 (q1, q2, q3);
      exercise_m5int32 (q1, q2, q3);
      exercise_m5unt32 (q1, q2, q3);
      exercise_m5int64 (q1, q2, q3);
      exercise_m5unt64 (q1, q2, q3);
      exercise_m5float32 (q1, q2, q3);
      exercise_m5float64 (q1, q2, q3);
      exercise_m5int8 (q1, q2, q3);
      exercise_m5unt8 (q1, q2, q3);
      exercise_m5int16 (q1, q2, q3);
      exercise_m5unt16 (q1, q2, q3);
    }

  return EXIT_SUCCESS;
}
